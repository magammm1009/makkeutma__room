<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>💗마끝마💗</title>
  <style>
    :root{
      --panel:rgba(255,255,255,.06);
      --line:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --pink2:#ffb6d6;
      --pink3:#ff77b8;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:16px;
      --tileMin:170px;
      --tileMax:230px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
      color:var(--text);
      background:#000;
      min-height:100vh;
    }

    /* Topbar */
    .topbar{
      position:sticky; top:0; z-index:30;
      display:grid; align-items:center; justify-content:stretch;
      grid-template-columns: minmax(160px, 1fr) auto minmax(320px, 1fr);
      gap:12px;
      padding:12px 14px;
      background: rgba(11,11,16,.84);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:1000; letter-spacing:-.5px;
      min-width:0;
      font-size:18px;
      white-space:nowrap;
    }
    .brand .dot{width:12px;height:12px;border-radius:999px;background:rgba(255,255,255,.22);border:1px solid rgba(255,182,214,.22);box-shadow:0 0 0 rgba(0,0,0,0)}
    body.joined .brand .dot{background:var(--pink3);border-color: rgba(255,182,214,.45);box-shadow:0 0 18px rgba(255,119,184,.65);animation: lampTwinkle 1.2s ease-in-out infinite;}
    @keyframes lampTwinkle{0%,100%{transform:scale(1);filter:brightness(1);}50%{transform:scale(1.18);filter:brightness(1.25);}}
    .brandTitle{font-weight:1100; font-size:18px; letter-spacing:-.4px;}
    .actions{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; justify-self:end}
    input, button, textarea{
      font:inherit;
      border-radius:12px;
      border:1px solid var(--line);
      color:var(--text);
      background: rgba(255,255,255,.06);
      padding:10px 12px;
      outline:none;
    }
    input::placeholder, textarea::placeholder{color:rgba(255,255,255,.4)}
    button{cursor:pointer}
    button.primary{
      background: linear-gradient(135deg, rgba(255,119,184,.92), rgba(255,182,214,.88));
      border: none;
      color:#1b1020;
      font-weight:1000;
      box-shadow: 0 14px 30px rgba(255,119,184,.18);
    }
    button.ghost{display:flex;align-items:center;justify-content:center;gap:6px;background: rgba(255,255,255,.05)}
    button:disabled, input:disabled, textarea:disabled{opacity:.45; cursor:not-allowed;}

    /* Main layout */
    .wrap{
      display:grid;
      grid-template-columns: minmax(0, 1fr) clamp(280px, 28vw, 340px);
      gap: 10px;
      padding:14px;
      width:100%;
      max-width:none;
      margin:0;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr; }
      .sidebar{order:-1; position:relative; top:auto; height:auto}
    }

    /* Sidebar */
    .sidebar{
      position:sticky;
      top:72px;
      align-self:start;
      justify-self:end;
      display:flex;
      flex-direction:column;
      gap:12px;
      height: calc(100vh - 92px);
      min-height: 520px;
    }
    .card{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h3{
      margin:0;
      padding:12px 14px;
      font-size:14px;
      color:rgba(255,255,255,.9);
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }

    /* Dashboard head (title + mission count + fold) */
    .dashHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid var(--line);
    }
    .dashHead h3{
      margin:0;
      padding:0;
      border:0;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
      white-space:nowrap;
    }
    .dashHeadRight{
      display:flex;
      align-items:center;
      gap:8px;
      flex-shrink:0;
    }
    .dashSuccess{
      font-weight:1000;
      font-size:13px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,182,214,.35);
      background: rgba(255,182,214,.10);
    }
    .dashFoldBtnSmall{
      padding:6px 10px;
      border-radius:999px;
      min-height:auto;
      line-height:1;
    }
    .dashFoldBtnSmall .dashFoldTxt{font-size:12px; opacity:.85; margin-left:6px;}
    @media (max-width: 520px){
      .dashFoldBtnSmall .dashFoldTxt{display:none;}
      .dashSuccess{padding:6px 8px;}
    }
    .card h3 span{color:var(--muted); font-weight:800; font-size:12px}
    .card .body{padding:12px 14px; display:flex; flex-direction:column; gap:10px;}

    /* Dashboard: two boxes side-by-side */
    .dashRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .dashBox{
      background: rgba(255,214,233,.10);
      border:1px solid rgba(255,182,214,.20);
      border-radius:14px;
      padding:8px 8px 6px;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:84px;
    }
    .dashTitle{font-weight:1000; display:flex; align-items:center; gap:8px;}
    .dashBig{font-size:28px; font-weight:1100; letter-spacing:-1px; line-height:1}
    .dashFoot{display:flex; justify-content:space-between; align-items:center; gap:8px; color:var(--muted); font-size:12px}
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.85);
      font-size:12px;
      font-weight:900;
    }
    .btnRow{display:flex; gap:8px;}
    .btnRow button{flex:1; min-width: 0}
    .dashGo{padding:8px 10px; font-size:12px; font-weight:1100}
    .dashFoot{font-size:11px;}
    .tiny{font-size:11px;}
    .tiny{font-size:12px; color:var(--muted); line-height:1.35}

    /* Chat */
    .chatCard{flex:1; min-height: 260px; display:flex; flex-direction:column;}
    .chatBody{display:flex; flex-direction:column; gap:10px; height:100%;}
    .chatList{
      flex:1;
      overflow:auto;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      padding:10px;
    }
    .msg{
      display:flex; flex-direction:column; gap:4px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      margin-bottom:8px;
    }
    .msg .meta{display:flex; gap:8px; align-items:center; color:rgba(255,255,255,.72); font-size:12px; font-weight:800}
    .msg .text{white-space:pre-wrap; word-break:break-word; font-size:13px; line-height:1.35}
    .chatInputRow{display:flex; gap:8px}
    .chatInputRow input{flex:1}
    .chatInputRow button{flex:0 0 auto; min-width:88px}

    /* Chat alignment (상대=왼쪽, 나=오른쪽 / 글자수에 맞춰 폭 자동) */
    .chatList{display:flex; flex-direction:column;}
    .msg{width: fit-content; max-width: 78%;}
    .msg.other{align-self:flex-start; margin-right:auto;}
    .msg.me{align-self:flex-end; margin-left:auto; border-color: rgba(255,182,214,.28); background: rgba(255,214,233,.10);}
    .msg.other .meta{justify-content:flex-start;}
    .msg.me .meta{justify-content:flex-end;}
/* Main */
    .gridHead{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:12px; padding:2px 2px 8px;
    }
    .gridHead .title{font-size:18px; font-weight:1100; letter-spacing:-.6px; display:flex; align-items:baseline; gap:10px;}
    .titleSub{font-size:12px; color:var(--muted); font-weight:900;}
    .gridHead .right{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color:rgba(255,255,255,.86);
      font-size:12px; font-weight:1000;
      display:inline-flex; align-items:center; gap:8px;
    }
    .grid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(auto-fill, minmax(var(--tileMin), var(--tileMax)));
      justify-content: center;
      padding:4px 2px 14px;
      align-items:stretch;
          align-content:start;
    }

    /* Tile */
    .tile{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: 0 16px 38px rgba(0,0,0,.28);
      aspect-ratio: 1 / 1;
      min-height: unset;
      background: rgba(255,255,255,.04);
      max-width:none;
      width:100%;
      justify-self:stretch;
      }
    .tile .bg{position:absolute; inset:0; opacity:1;}
    .tile .shade{
      position:absolute; inset:0;
      /* 패턴이 더 잘 보이도록 살짝만 어둡게 */
      background: rgba(0,0,0,.32);
      }
    .tile .content{
      position:relative;
      padding:7px;
      padding-bottom: 10px;
      display:flex;
      flex-direction:column;
      --tileGap: 10px;
      gap: var(--tileGap, 10px);
      height:100%;
      min-height:unset;
    }

    .statusBar{display:flex; justify-content:center; align-items:center; gap:8px;}
    .statusLeft{display:flex; align-items:center; gap:8px; min-width:0;}
    .statusRight{display:none;}
    
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 9px;
      border-radius:999px;
      font-size:12px;
      font-weight:1100;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.34);
    }
    .bWork{background: rgba(85, 255, 170, .12); border-color: rgba(85, 255, 170, .22)}
    .bBreak{background: rgba(255, 214, 80, .12); border-color: rgba(255, 214, 80, .22)}
    .bIdle{background: rgba(160, 160, 255, .12); border-color: rgba(160, 160, 255, .22)}
    .bOff{background: rgba(255, 255, 255, .08); border-color: rgba(255, 255, 255, .14)}

    .rowTop{display:flex; align-items:center; justify-content:center; gap:6px; padding-top:0;}
    .who{display:flex; flex-direction:column; align-items:center; gap:8px; min-width:0;}
    .avatar{
      width: var(--emoSize, 60px);
      height: var(--emoSize, 60px);
      border-radius: 16px;
      background: var(--emoBg, #2b2b2b);
      border:1px solid rgba(255,255,255,.18);
      overflow:hidden;
      flex:0 0 auto;
      display:flex; align-items:center; justify-content:center;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      font-size: calc(var(--emoSize, 60px) * 0.55);
      line-height:1;
    }
    .whoText{min-width:0; display:flex; flex-direction:column; gap:2px;}
    .name{font-weight:1100; letter-spacing:-.4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .namePill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 10px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 13px;
      letter-spacing: -.2px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.22);
      color: rgba(255,255,255,.95);
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      box-shadow: 0 10px 20px rgba(0,0,0,.20);
    }
    .bubble{
      margin:0;
      background: var(--bubbleBg, rgba(255,255,255,.10));
      border-color: var(--bubbleBorder, rgba(255,255,255,.16));
    }

    body.compact .grid{ grid-template-columns: 1fr; }

    .gridRosterWrap{
      width: 100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 18px 50px rgba(0,0,0,.25);
    }
    .gridRosterTitle{
      font-weight: 900;
      letter-spacing: -.2px;
      margin: 2px 0 10px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 6px 16px rgba(0,0,0,.25);
    }
    .gridRosterList{ display:flex; flex-direction:column; gap:10px; }
    .gridRosterItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.14);
    }
    .gridRosterLeft{ display:flex; align-items:center; gap:10px; min-width:0; }
    .gridRosterEmoji{
      width: 40px; height: 40px;
      display:flex; align-items:center; justify-content:center;
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      font-size: 20px;
    }
    .gridRosterName{
      font-weight: 850;
      max-width: 64vw;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .gridRosterStatus{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.86);
      flex: none;
    }

    #settingsModal .modalBody{ gap: 14px; }
    #settingsModal .row{ gap: 12px; }

    .motto{font-size:12px; color:rgba(255,255,255,.72); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    .idPhoto{
      width: var(--photoSize, 108px);
      height: var(--photoSize, 108px);
      border-radius:16px;
      border:1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.34);
      overflow:hidden;
      flex:0 0 auto;
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
      display:flex; align-items:center; justify-content:center;
      color: rgba(255,255,255,.78);
      font-weight: 900;
      font-size: 12px;
    }
    .idPhoto img{width:100%; height:100%; object-fit:cover; display:block;}

    .bigTimer{
      font-size: clamp(20px, 4.8vw, 30px);
      font-weight:1100;
      letter-spacing:-1px;
      line-height:1;
      display:flex; align-items:baseline; justify-content:space-between; gap:10px;
      min-width:0;
    }
    .bigTimer small{font-size:11px; font-weight:900; color:rgba(255,255,255,.70);}
    .bigTimer .time{white-space:nowrap; font-variant-numeric: tabular-nums;}

    .bubble{
  position:relative;
  margin:0;
  z-index:3;
  padding:7px 9px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.10);
  font-size:12.5px;
  line-height:1.25;
  min-height:32px;
  display:flex; align-items:center;
  word-break:break-word;
  overflow:hidden;
}
.bottomStack{
  margin-top: 0;
  display:flex;
  flex: 0 0 auto;
  flex-direction:column;
  gap: var(--tileGap, 10px);
}
.mediaRow{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  padding-top:0;
}
    .bubble.muted{opacity:.72}

    /* Bottom bar */
    .bottomBar{
      position:sticky; bottom:0; z-index:15;
      background: rgba(11,11,16,.86);
      backdrop-filter: blur(10px);
      border-top:1px solid var(--line);
      padding:10px 14px;
    }
    .bottomInner{
      max-width:1400px; margin:0 auto;
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; flex-wrap:wrap;
    }
    .leftBar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .rightBar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .miniHelp{font-size:12px; color:var(--muted); font-weight:800}

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      z-index:100; padding:16px;
    }
    .modalOverlay.show{display:flex}
    .modal{
      width:min(720px, 100%);
      background: rgba(18,18,26,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      overflow:hidden;
      max-height: calc(100vh - 32px);
      display:flex; flex-direction:column;
    }
    .modalHeader{
      padding:12px 14px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.34);
    }
    .modalHeader .t{font-weight:1100}
    .modalBody{padding:12px 14px; display:flex; flex-direction:column; gap:10px; overflow:auto; min-height:0;}
    .row{display:flex; gap:8px; flex-wrap:wrap}
    .row > *{flex:1; min-width: 220px}
    .row .tight{flex:0 0 auto; min-width:auto}
/* Profile modal layout tidy */
    #profileModal .modalBody .row{display:flex; align-items:center; gap:12px; flex-wrap:wrap}
    #profileModal .modalBody .row > *{flex:0 0 auto; min-width:0}
    #profileModal .modalBody .row label{flex:0 0 140px; max-width:140px; min-width:140px; font-weight:950; color:rgba(255,255,255,.86)}
    #profileModal .modalBody .row textarea{flex:1 1 420px; min-width:260px; height:46px; padding:10px 12px; line-height:1.35; resize:vertical}
    #profileModal .modalBody .row input[type="text"]{flex:1 1 260px; min-width:180px}
    #profileModal .modalBody .row input[type="file"]{flex:1 1 320px; min-width:220px}
    #profileModal .modalBody .row input[type="range"]{flex:1 1 340px; min-width:220px}
    #profileModal .modalBody .row select{flex:1 1 340px; min-width:220px}
    #profileModal .modalBody .row input[type="number"]{flex:0 0 86px; min-width:86px}
    #profileModal .modalBody .row .colorControls{flex:1 1 320px; min-width:220px}
    #profileModal .modalBody .row .tiny{flex:1 1 100%; margin-left:140px; min-width:0; font-size:12px; color:rgba(255,255,255,.62)}
    #profileModal .modalBody .row:last-child{justify-content:flex-end}

    .hint{font-size:12px; color:var(--muted); line-height:1.35}
    .hr{height:1px;background:rgba(255,255,255,.10); margin:4px 0}

    .toast{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:70px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px;
      border-radius:999px;
      font-size:13px;
      color:rgba(255,255,255,.9);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      z-index:999;
    }
    .toast.show{opacity:1}

    /* Color palette controls */
    .paletteWrap{display:flex; flex-direction:column; gap:8px;}
    .swatches{display:flex; flex-wrap:wrap; gap:8px;}
    #bgSwatches{display:none;}

    .swatch{
      width:22px; height:22px; border-radius:8px; cursor:pointer;
      border:1px solid rgba(255,255,255,.22);
      box-shadow: 0 8px 18px rgba(0,0,0,.20);
    }
    .swatch.active{outline:2px solid rgba(255,119,184,.9);}
    .colorControls{display:flex; gap:8px; align-items:center;}
    input[type="color"]{width:44px; height:44px; padding:0; border-radius:12px; overflow:hidden;}
    /* Embeds */
    .embedBar{display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:8px;}
    .embedBar .left{display:flex; gap:8px; align-items:center;}
    .embedFrame{
      width:100%;
      height:100%;
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background: rgba(0,0,0,.22);
    }

    
    .topCenter{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      flex:1;
      min-width: 240px;
      flex-wrap:wrap;
      position:relative;
    }

    .statusMenu{
      position:absolute;
      top:42px;
      left:50%;
      transform: translateX(-50%);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(16,16,18,.92);
      box-shadow: 0 16px 34px rgba(0,0,0,.42);
      backdrop-filter: blur(10px);
      z-index: 50;
      width: min(520px, 92vw);
    }
    .statusMenu.hidden{display:none;}
    .statusBtns{display:flex; gap:8px; flex-wrap:wrap; justify-content:center;}
    .statusMenu button{min-width:106px;}
    .statusMenu button.tight{min-width:52px; padding:10px 10px; border-radius:12px;}
    .topCenter button{
      padding:10px 12px;
      border-radius:12px;
      font-weight:1000;
      white-space:nowrap;
    }
    .miniPill{padding:7px 10px; font-size:12px;}
    .topPills{display:none;}

    .meMini{
      font-size:12px;
      color: rgba(255,255,255,.68);
      font-weight:900;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
    }
    @media (max-width: 980px){
      .topCenter{order:3; width:100%; justify-content:flex-start;}
      .actions{order:2;}
      .brand{order:1;}
      .topbar{display:flex; flex-wrap:wrap;}
    }


    .tile .rowTop{min-height: 132px;}
    .tile .bigTimer{font-size:32px;}
    @media (max-width: 420px){
      .idPhoto{width:96px; height:96px;}
      .tile .bigTimer{font-size:28px;}
    }


    /* Status animations */
    .stIcon{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:10px; background: rgba(0,0,0,.34); border:1px solid rgba(255,255,255,.14); margin-right:6px;}
    .stWork{animation: wiggle 1.25s ease-in-out infinite;}
    .stBreak{animation: puff 1.6s ease-in-out infinite;}
    .stIdle{animation: floaty 1.8s ease-in-out infinite;}
    @keyframes wiggle{0%,100%{transform:rotate(0deg) translateY(0);}50%{transform:rotate(-10deg) translateY(-1px);}}
    @keyframes puff{0%,100%{transform:translateY(0);opacity:1;}50%{transform:translateY(-2px);opacity:.85;}}
    @keyframes floaty{0%,100%{transform:translateY(0);}50%{transform:translateY(-3px);}}
    .chatEmoji{margin-right:6px;}

@media (max-width: 520px){
  /* Force at least 2 profile tiles on small screens */
  .grid{grid-template-columns: repeat(2, minmax(0, 1fr));}
  .tile{max-width:none; justify-self:stretch;}
  .rowTop{min-height: 156px;}
  .dashRow{grid-template-columns: 1fr;}
}


    /* Mini online button next to profile */
    .miniOnline{
      padding:10px 12px;
      border-radius:999px;
      font-weight:1000;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background: rgba(255,255,255,.05);
    }

    /* Chat responsive fixes (avoid input bar getting cut) */
    .chatCard{min-height: 320px;}
    .chatBody{min-height:0;}
    .chatList{min-height:0;}
    .chatInputRow{flex-wrap:wrap;}
    .chatInputRow input{min-width:0;}
    @media (max-width: 520px){
      .chatInputRow button{min-width:72px;}
    }
    @media (max-width: 380px){
      .chatInputRow button{width:100%; min-width:0;}
      .chatInputRow input{width:100%;}
    }

    
    @media (max-height: 720px){
      .sidebar{height:auto; min-height:0;}
      .chatCard{min-height:260px;}
    }

    /* Dashboard docking under settings button */
    #dashboardCard.docked{
      position: fixed;
      z-index: 60;
      width: clamp(260px, 28vw, 340px);
    }

    #chatCard.dockedChat{
      z-index: 55;
      width: clamp(260px, 28vw, 340px);
    }


    /* --- Context menu (프로필 우클릭 강퇴) --- */
    .ctxMenu{
      position: fixed;
      z-index: 9999;
      min-width: 190px;
      max-width: 260px;
      background: rgba(18,18,20,.94);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      padding: 8px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
    }
    .ctxMenu.hidden{ display:none; }
    .ctxMenu .title{
      font-size: 13px;
      color: rgba(255,255,255,.88);
      padding: 6px 10px 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      margin-bottom: 6px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .ctxMenu button{
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      font-weight: 700;
      cursor: pointer;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      margin-top: 6px;
    }
    .ctxMenu button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    .ctxMenu button:active{ transform: translateY(1px); }
    .ctxMenu button.danger{
      background: rgba(255, 90, 140, .20);
      border-color: rgba(255, 90, 140, .40);
    }
    .ctxMenu button.danger:hover{
      background: rgba(255, 90, 140, .28);
      border-color: rgba(255, 90, 140, .55);
    }
    .ctxMenu button:disabled{
      opacity: .45;
      cursor: not-allowed;
      transform: none;
    }
    /* ✅ ultra-small window: use roster layout in main (tiles hidden by JS) */
    body.compact .wrap{grid-template-columns: 1fr;}

  
    body.passok #roomPass{display:none;}
    .actions{flex-wrap:wrap}
    #roomPass{min-width:92px}

  

    /* ✅ 초소형 화면: 채팅만 남기고 메인(타일/시간/접속자목록-컴팩트)을 숨김 */
    body.compact main{ display:none !important; }
    body.compact .wrap{ grid-template-columns: 1fr !important; }
    body.compact .sidebar{
      grid-column: 1 / -1;
      height: calc(100vh - 92px);
      max-height: calc(100vh - 92px);
      overflow: auto;
    }
    body.compact .sidebar .chatCard{ height: calc(100vh - 150px); }

    .btnLabel{font-size:12px;font-weight:900;letter-spacing:-0.2px;margin-left:8px;opacity:.92;}


    /* ✅ REC(작업중) 표시 */
    .recBadge{ background: rgba(255,0,0,.14) !important; border-color: rgba(255,0,0,.35) !important; }
    .recBadge .recDot{
      width:8px;height:8px;border-radius:999px;
      background: rgb(255,60,60);
      box-shadow: 0 0 0 0 rgba(255,60,60,.55);
      animation: recPulse 1.1s infinite;
      display:inline-block;
      margin-right:6px;
      vertical-align:middle;
    }
    @keyframes recPulse{
      0%{ box-shadow:0 0 0 0 rgba(255,60,60,.50); transform:scale(1); }
      70%{ box-shadow:0 0 0 10px rgba(255,60,60,0); transform:scale(1.05); }
      100%{ box-shadow:0 0 0 0 rgba(255,60,60,0); transform:scale(1); }
    }

    /* ✅ 오늘의 미션 버튼(집중시간 라벨 자리) */
    .missionBtn{
      width: 34px; height: 18px;
      flex:0 0 auto;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.25);
      position: relative;
      padding: 0;
      cursor: pointer;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
      color: rgba(255,255,255,.95);
      font-size: 13px;
      font-weight: 1100;
      letter-spacing: -0.2px;
    }
    .missionBtn::after{
      content:"";
      position:absolute; inset: 2px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      pointer-events:none;
    }
    .missionSpacer{width:34px;height:18px; display:inline-block; flex:0 0 auto; opacity:0;}
    .missionBtn.isHot{
      border-color: rgba(255,140,0,.65);
      box-shadow:
        0 0 10px rgba(255,120,0,.25),
        0 0 22px rgba(255,80,0,.14),
        inset 0 0 0 1px rgba(0,0,0,.18);
      animation: fireFlicker 1.1s infinite;
    }
    @keyframes fireFlicker{
      0%{ filter: drop-shadow(0 0 0 rgba(255,120,0,.0)); transform: translateY(0); }
      35%{ filter: drop-shadow(0 0 4px rgba(255,120,0,.35)); transform: translateY(-.3px); }
      70%{ filter: drop-shadow(0 0 6px rgba(255,80,0,.25)); transform: translateY(.2px); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,120,0,.0)); transform: translateY(0); }
    }
    .missionBtn.isDone{
      border-color: rgba(255,255,255,.75);
      box-shadow:
        0 0 12px rgba(255,255,255,.22),
        0 0 26px rgba(255,255,255,.12),
        inset 0 0 0 1px rgba(0,0,0,.18);
      animation: sparkle 1.25s infinite;
    }
    @keyframes sparkle{
      0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
      50%{ filter: drop-shadow(0 0 6px rgba(255,255,255,.55)); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
    }

    /* ✅ 폭죽 FX 레이어 */
    #fxLayer{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
    }
    .fxPop{
      position: absolute;
      width: 6px; height: 6px;
      border-radius: 999px;
      opacity: .95;
      transform: translate(-50%,-50%);
      animation: fxFly 700ms ease-out forwards;
      background: rgba(255,255,255,.95);
    }
    @keyframes fxFly{
      to{
        transform: translate(var(--dx), var(--dy));
        opacity: 0;
      }
    }

    /* ✅ 대시보드 미션 라인 + 접기 */
    .dashMissionLine{display:flex; align-items:center; gap:10px; margin:2px 0 8px;}
    .dashFoldBtn{
      margin-left:auto;
      height: 26px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.85);
      font-weight: 900;
      cursor: pointer;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .dashFoldBtn:hover{ background: rgba(0,0,0,.22); }
    .dashFoldBody.isHidden{ display:none !important; }

/* ✅ v62: 사이드바 접기 시 채팅이 자연스럽게 위로 확장되도록 레이아웃 고정 */
.sidebar{
  display:flex !important;
  flex-direction:column !important;
  gap:12px !important;
  height: calc(100vh - 92px) !important;
  min-height: 0 !important;
}
#dashboardCard{ flex:0 0 auto !important; }
#chatCard{
  flex:1 1 auto !important;
  min-height:0 !important;
  display:flex !important;
  flex-direction:column !important;
}
/* 🔧 핵심: 스크롤은 chatList에만, 입력창은 항상 보이게 */
#chatCard .body.chatBody{
  flex:1 1 auto !important;
  min-height:0 !important;
  overflow:hidden !important;
  display:flex !important;
  flex-direction:column !important;
}
#chatList{
  flex:1 1 auto !important;
  min-height:0 !important;
  overflow:auto !important;
}

/* ✅ chatCard flex fix: header+body가 고정높이 안에서 제대로 늘어나게 */
#chatCard{display:flex; flex-direction:column;}
#chatCard > h3{flex:0 0 auto;}
#chatCard > .body{flex:1 1 auto; min-height:0;}
#chatCard .body.chatBody{flex:1 1 auto; min-height:0; height:auto;}
#chatList{flex:1 1 auto; min-height:0;}
#chatCard .chatInputRow{flex:0 0 auto;}
#dashboardCard.folded .body{ display:none !important; }
#dashboardCard .dashHeaderRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
#dashboardCard .dashHeaderRight{
  display:flex;
  align-items:center;
  gap:8px;
}
#dashFoldBtn{
  padding:6px 10px;
  border-radius:999px;
  font-weight:900;
}

    /* ✅ 채팅 입력줄/리스트 강제 복구(도킹/접기 시 0으로 눌림 방지) */
    #chatCard{display:flex; flex-direction:column;}
    #chatCard > .body{flex:1 1 auto; min-height:0; display:flex; flex-direction:column;}
    #chatCard #chatList{flex:1 1 auto; min-height:0; overflow:auto;}
    #chatCard .chatInputRow{flex:0 0 auto; margin-top:8px;}

</style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <span class="dot" title="방 불"></span>
      <div class="brandTitle">💗마끝마💗</div>
    </div>

    <!-- 가운데: 상태표시 + 내프로필 -->
    <div class="topCenter" aria-label="작업 상태">
      <button id="statusBtn" class="primary" disabled>✍️ 작업중 ▾</button>

      <div id="statusMenu" class="statusMenu hidden" role="menu" aria-label="상태 선택">
        <div class="statusBtns">
          <button id="btnWork" class="primary" disabled>✍️ 작업중</button>
          <button id="btnBreak" class="ghost" disabled>☕ 휴식중</button>
          <button id="btnIdle" class="ghost" disabled>🌙 자리비움</button>
        </div>

        

      </div>


      <div class="topPills">
        <div class="pill miniPill">🕒 <span id="lastSync">-</span></div>
      </div>

      <button id="onlineBtn" class="ghost miniOnline" disabled title="접속 인원">👥 <span id="countOnline">0</span>명</button>
      <button id="profileBtn" class="ghost">🪪 내 프로필</button>
    </div>

    <div class="actions">
      <input id="name" placeholder="닉네임" style="width:180px">
      <input id="roomPass" placeholder="입장키" type="password" style="width:120px">
      <button id="joinBtn" class="primary">입장</button>
      <button id="leaveBtn" class="ghost" disabled>퇴장</button>
      <span class="meMini" id="meHint">—</span>
      <button id="menuBtn" class="ghost" disabled title="작업방 설정">☰</button>
    </div>
  </div>

  <div class="wrap">
    <main>
      <div class="gridHead">
        <div class="title">✒️지금 시간 <span id="nowClockMain">--:--</span></div>
        <div class="right"></div>
      </div>

      <div id="grid" class="grid"></div>
    </main>

    <aside class="sidebar">
      <div class="card" id="dashboardCard">
        <div class="dashHead">
          <h3>💗 대시보드</h3>
          <div class="dashHeadRight">
            <div class="dashSuccess" title="오늘 미션 성공 인원">🎖 <span id="missionSuccessCount">0</span></div>
            <button id="dashFoldBtn" class="dashFoldBtn dashFoldBtnSmall" type="button" title="현황/바로가기 접기/펼치기">
              <span id="dashFoldIcon">▴</span>
              <span class="dashFoldTxt">접기</span>
            </button>
          </div>
        </div>
        <div class="body">
          <div id="dashFoldBody" class="dashFoldBody">
          <div class="dashRow">
            <div class="dashBox">
              <div class="dashTitle">⏰ 공용 뽀모</div>
              <div class="dashBig"><span id="pomoCount">—</span><span style="font-size:16px;font-weight:900;margin-left:6px">명</span></div>
              <div class="btnRow">
                <button id="goPomo" class="primary dashGo" title="바로가기">👉💗</button>
              </div>
              <div class="dashFoot">
                <span>연결: <b id="pomoOk">연결됨</b></span>
                <span class="chip">LIVE</span>
              </div>
            </div>

            <div class="dashBox">
              <div class="dashTitle">💣 폭파 수다</div>
              <div class="dashBig"><span id="sudaCount">—</span><span style="font-size:16px;font-weight:900;margin-left:6px">명</span></div>
              <div class="btnRow">
                <button id="goSuda" class="primary dashGo" title="바로가기">👉💗</button>
              </div>
              <div class="dashFoot">
                <span>연결: <b id="sudaOk">연결됨</b></span>
                <span class="chip">LIVE</span>
              </div>
            </div>
          </div>

          <div class="btnRow">
            <button id="goChool" class="ghost" title="출근부">🔥<span class="btnLabel">출근부</span></button>
            <button id="goSheet" class="ghost" title="뽀모 시트">📎<span class="btnLabel">뽀모시트</span></button>
          </div>

          <div class="tiny">
            업데이트: <span id="dashUpdated">-</span> · 대시보드 링크는 ☰에서 바꿀 수 있어요.
          </div>
        </div>
      </div>

      <div class="card chatCard" id="chatCard">
        <h3>💬 채팅 <span class="tiny">짧게, 빠르게</span></h3>
        <div class="body chatBody">
          
          <div id="embedBar" class="embedBar" style="display:none">
            <div class="left">
              <span class="pill">🫧 임베드</span>
              <span id="embedTitle" class="tiny">열린 창</span>
            </div>
            <div class="right" style="display:flex; gap:8px; align-items:center">
              <button id="embedOpen" class="ghost tight">새 창</button>
              <button id="embedClose" class="ghost tight">닫기</button>
            </div>
          </div>
          <iframe id="embedFrame" class="embedFrame" style="display:none" loading="lazy" referrerpolicy="no-referrer"></iframe>

          <div id="chatList" class="chatList"></div>
          <div class="chatInputRow">

            <input id="chatInput" placeholder="메시지…" disabled />
            <button id="sendBtn" class="primary" disabled>전송</button>
          </div>
        </div>
      </div>
    </aside>
  </div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">🪪 내 프로필</div>
        <button id="closeProfile" class="ghost">닫기</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <label>이모지</label>
          <input id="emoji" placeholder="예: ✍️, 💓, 🧠" maxlength="4" style="width:120px">
          <span class="tiny">프로필 타일에 표시돼요.</span>
        </div>

        <div class="row">
          <label>이모지 크기</label>
          <input id="emojiSize" type="range" min="26" max="100" value="40" style="flex:1">
          <input id="emojiSizeNum" type="number" min="26" max="100" value="40" style="width:76px">
        </div>

        <div class="row">
          <label>💓 사진 업로드</label>
          <input id="photoFile" type="file" accept="image/*,.gif" />
          <button id="uploadPhotoBtn" class="primary tight">업로드</button>
        </div>

        <div class="row">
          <label>사진 크기</label>
          <input id="photoSize" type="range" min="52" max="100" value="68" style="flex:1">
          <input id="photoSizeNum" type="number" min="52" max="100" value="68" style="width:76px">
        </div>

        <div class="row">
          <label>이모지 배경</label>
          <div class="colorControls">
            <input id="emojiBgPicker" type="color" value="#2b2b2b" />
            <input id="emojiBgColor" value="#2b2b2b" style="width:110px" />
          </div>
          <span class="tiny">투명 없음(원색).</span>
        </div>

        <div class="row" style="align-items:flex-start;">
          <label>💓 배경색</label>
          <div id="swatches" class="swatches" style="display:none"></div>
          <div class="colorControls">
            <input id="bgPicker" type="color" value="#ffd0e2" />
            <input id="bgColor" value="#ffd0e2" style="width:110px" />
          </div>
        </div>

        <div class="row">
          <label>닉네임</label>
          <input id="profileNick" type="text" maxlength="20" placeholder="닉네임 (최대 20자)">
          <span class="tiny">저장하면 상단/채팅/접속자 목록에 즉시 반영돼요.</span>
        </div>


        <div class="row">
          <label>배경 패턴</label>
          <select id="bgPattern" class="ghost" style="flex:1; background:#111; color:#fff; border:1px solid rgba(255,255,255,.18);">
            <option value="none">없음</option>
            <option value="dots">도트</option>
            <option value="hearts">하트</option>
            <option value="stars">별</option>
            <option value="moon">달</option>
            <option value="flowers">꽃</option>
            <option value="clouds">구름</option>
            <option value="catpaws">고양이 발바닥</option>
            <option value="dogpaws">강아지 발바닥</option>
            <option value="stripes">스트라이프</option>
            <option value="grid">그리드</option>
            <option value="papergrid">종이 그리드</option>
            <option value="waves">웨이브</option>
          </select>
          <span class="tiny">선택창 배경도 어둡게.</span>
        </div>


<div class="row">
  <label>패턴 색</label>
  <div class="colorControls">
    <input id="patternPicker" type="color" value="#ffffff" />
    <input id="patternColor" value="#ffffff" style="width:110px" />
  </div>
  <span class="tiny">패턴(도트/하트/줄무늬 등) 색만 바꿔요.</span>
</div>

<div class="row">
          <label>말풍선 글(140자)</label>
          <textarea id="bubbleText" placeholder="지금 상태 한 마디!" maxlength="140"></textarea>
        </div>

        <div class="row">
          <label>말풍선 배경</label>
          <div class="colorControls">
            <input id="bubblePicker" type="color" value="#ffd0e2" />
            <input id="bubbleColor" value="#ffd0e2" style="width:110px" />
          </div>
        </div>

        <div class="row">
          <label>💓 시간 색</label>
          <div class="colorControls">
            <input id="timePicker" type="color" value="#ffffff" />
            <input id="timeColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny">집중=선택색, 휴식/자리비움=회색 고정</span>
        </div>

        <div class="row">
          <label>자동 전환</label>
          <div style="display:flex; gap:10px; width:100%; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:8px;">
              <span class="tiny" style="min-width:86px; opacity:.9;">휴식(분)</span>
              <input id="autoBreakMin" type="number" min="1" max="180" value="10" style="width:76px">
            </div>
            <div style="display:flex; align-items:center; gap:8px;">
              <span class="tiny" style="min-width:86px; opacity:.9;">자리비움(분)</span>
              <input id="autoIdleMin" type="number" min="1" max="180" value="15" style="width:76px">
            </div>
          </div>
          <span class="tiny">작업중일 때만 적용돼요. (기본: 10/15분)</span>
        </div>

<div class="row">
          <button id="applyProfile" class="ghost">저장</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Room Settings Modal (Admin) -->
  <div id="settingsModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">⚙️ 작업방 설정</div>
        <button id="closeSettings" class="ghost">닫기</button>
      </div>
      <div class="modalBody">
        <div class="hint">
          처음 설정하는 사람은 “관리자 비번”을 등록하고, 이후부터는 비번이 있어야 변경할 수 있어요.
        </div>
        <div class="row">
          <input id="adminPass" type="password" placeholder="관리자 비번" />
          <button id="adminUnlock" class="primary tight">확인</button>
        </div>

        <div id="adminArea" style="display:none">
          <div class="hr"></div>
          <div class="hint">대시보드 링크(룸 공용)</div>
          <div class="row">
            <input id="pomoUrl" placeholder="⏰ 공용 뽀모 링크" />
            <input id="sudaUrl" placeholder="💣 폭파 수다 링크" />
          </div>
          <div class="row">
            <input id="choolUrl" placeholder="🔥 출근부 링크" />
            <input id="sheetUrl" placeholder="🔗 뽀모 시트 링크" />
          </div>
          <div class="row">
            <input id="dashApiUrl" placeholder="📡 대시보드 인원 API (Apps Script .../exec?api=counts&callback=cb)" />
          </div>
          <div class="row">
            <button id="saveDash" class="primary">저장</button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <div id="ctxMenu" class="ctxMenu hidden" role="menu" aria-hidden="true">
    <div class="title" id="ctxTitle">프로필</div>
    <button id="ctxKick" class="danger" type="button">🚫 강퇴</button>
    <button id="ctxClose" type="button">닫기</button>
  </div>

  <div id="toast" class="toast">저장했어!</div>

  
  <!-- Mission Modal -->
  <div id="missionModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">🎯 오늘의 미션</div>
        <button id="closeMission" class="ghost" type="button">닫기</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <label>미션</label>
          <input id="missionText" placeholder="예: 2000자 쓰기 / 25분 2세트" maxlength="60" style="flex:1">
        </div>
        <div class="row">
          <label>성공</label>
          <label style="display:flex;align-items:center;gap:10px; font-weight:900;">
            <input id="missionDone" type="checkbox" />
            오늘 미션 완료했어요 🎉
          </label>
        </div>
        <div class="tiny" style="opacity:.8; line-height:1.4;">
          - 자정(KST)에 자동 초기화돼요.<br>
          - 성공 체크하면 버튼이 반짝 + 훈장 + 작은 폭죽!
        </div>
      </div>
      <div class="modalFooter">
        <button id="saveMission" class="primary" type="button">저장</button>
      </div>
    </div>
  </div>

  <!-- FX layer for fireworks -->
  <div id="fxLayer" aria-hidden="true"></div>

<script type="module">
    // BOOT FLAG (module ok)
    window.__MK_BOOT_OK__ = true;

    // -----------------------------
    // 고정 룸 아이디 (통일)
    // -----------------------------
    const FIXED_ROOM_ID = "magamm";
    // -----------------------------
    // ✅ 클라이언트 입장키(간이 게이트)
    // - 보안 "강화"용(완전 차단은 Firestore Rules/인증이 필요)
    // -----------------------------
    const ROOM_PASS = "mkm1919";
    

    // ✅ Root helpers (module 최상단) — 스코프 꼬임/중복 선언 방지
    function showToast(msg, ms=1600){
      try{
        const el = document.getElementById("toast");
        if(!el){ console.log("toast:", msg); return; }
        el.textContent = msg;
        el.classList.add("show");
        if(window.__toastTimer) clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(()=>el.classList.remove("show"), ms);
      }catch(e){
        console.log("toast:", msg);
      }
    }

    // ✅ 집중시간(24시간 누적, 자정 리셋) — 최상단 전역 유틸
    const __LS_FOCUS_DAY = "mk_focus_day";
    const __LS_FOCUS_SEC = "mk_focus_sec";
    function __seoulDateKey(){
      try{
        const now = new Date();
        const utc = now.getTime() + now.getTimezoneOffset()*60000;
        const kst = new Date(utc + 9*3600000);
        const y = kst.getFullYear();
        const m = String(kst.getMonth()+1).padStart(2,"0");
        const d = String(kst.getDate()).padStart(2,"0");
        return `${y}-${m}-${d}`;
      }catch(e){
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
      }
    }
    function focusLoadSeconds(){
      const today = __seoulDateKey();
      try{
        const day = localStorage.getItem(__LS_FOCUS_DAY) || "";
        const sec = Number(localStorage.getItem(__LS_FOCUS_SEC) || 0);
        if(day !== today){
          localStorage.setItem(__LS_FOCUS_DAY, today);
          localStorage.setItem(__LS_FOCUS_SEC, "0");
          return 0;
        }
        return isFinite(sec) ? Math.max(0, sec) : 0;
      }catch(e){
        return 0;
      }
    }
    function focusSaveSeconds(sec){
      const today = __seoulDateKey();
      try{
        localStorage.setItem(__LS_FOCUS_DAY, today);
        localStorage.setItem(__LS_FOCUS_SEC, String(Math.max(0, Math.floor(Number(sec)||0))));
      }catch(e){}
    }
    function persistMyFocusToLocal(){
      try{ focusSaveSeconds((state && state.focusSecondsTotal) || 0); }catch(e){}
    }

const PASS_TTL_MS = 24 * 60 * 60 * 1000; // 24h
    const LS_PASS = "mk_room_pass";
    const LS_PASS_EXP = "mk_room_pass_exp";
    const LS_PROFILE = "mk_profile_pref_v1";

    // ✅ 집중시간(24시간 누적, 자정 리셋)
    const LS_FOCUS_DAY = "mk_focus_day_v1";
    const LS_FOCUS_SEC = "mk_focus_sec_v1";

    // ✅ 대시보드 실시간 API 기본값
    // - 설정에서 비워도 이 값으로 자동 사용
    const DEFAULT_DASH_API_URL = "https://script.googleusercontent.com/macros/echo?user_content_key=AehSKLhCZiB9bWPP17OFdi8Iun-HZQ2m-_RV3MTXTyoLlkhP1tZh7Ezl6woyiCzx7OeNnJ7qIjVyMaYns_7dHcxYaqak8uJPcJmkjDfdVWKJErRsnFO_T98PyWjMHLA_XFClehZR9s1-3hnRXdXGh2fPETxMzfsTY-ugf7XlXmml3xX2DCIqNFxTmUIM8u61FWKdtZCUjnEXANH8TaPp0BfGbqLSmz8IfiaAd3c8C0zNAIjLfw-AIpndxPgDHsGQCnDR5qxsI_cVfkbbAWkcmJPRxVVrWNKlcYtpRmeLUjzjo324hiSgKFEAnBA9p353E1pTH3vDi1N8&lib=MvZy7pc3gESHKkPg0RUcEYKjZiy7tesAR";


    let els = {};

    function loadPassOK(){
      try{
        const p = localStorage.getItem(LS_PASS) || "";
        const exp = Number(localStorage.getItem(LS_PASS_EXP) || 0);
        if(p && exp && exp > Date.now() && p === ROOM_PASS){
          document.body.classList.add("passok");
          if(els.roomPass) els.roomPass.value = p;
          return true;
        }
      }catch(e){}
      document.body.classList.remove("passok");
      return false;
    }
    function savePassOK(pass){
      try{
        localStorage.setItem(LS_PASS, pass);
        localStorage.setItem(LS_PASS_EXP, String(Date.now() + PASS_TTL_MS));
      }catch(e){}
      document.body.classList.add("passok");
    }
    function clearPass(){
      try{ localStorage.removeItem(LS_PASS); localStorage.removeItem(LS_PASS_EXP); }catch(e){}
      document.body.classList.remove("passok");
    }
    function requirePassOK(){
      if(loadPassOK()) return true;
      const pass = (els.roomPass?.value || "").trim();
      if(pass !== ROOM_PASS){
        showToast("입장키가 필요해! (mkm1919)", 2500);
        try{ els.roomPass?.focus(); }catch(e){}
        return false;
      }
      savePassOK(pass);
      return true;
    }

    function loadLocalProfile(){
      try{
        const raw = localStorage.getItem(LS_PROFILE);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || typeof obj !== "object") return null;
        return obj;
      }catch(e){ return null; }
    }
    function saveLocalProfile(obj){
      try{
        localStorage.setItem(LS_PROFILE, JSON.stringify(obj || {}));
      }catch(e){}
    }


    // -----------------------------
    // Firebase 설정 (여기만 본인 값으로 교체)
    // -----------------------------
   const firebaseConfig = {
    apiKey: "AIzaSyAmhsxF7syCPNfgIVb2ZIQBxgGV_rZ2nDI",
    authDomain: "magamm00-5baee.firebaseapp.com",
    projectId: "magamm00-5baee",
    storageBucket: "magamm00-5baee.firebasestorage.app",
    messagingSenderId: "829544685832",
    appId: "1:829544685832:web:7ae0a5a2cd48cb62a6ccbd",
    measurementId: "G-CFQ6KZ7R7B"
  };

    // Firebase imports (CDN)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc,
      collection, onSnapshot, serverTimestamp, addDoc, query, orderBy, limit
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

; (async ()=>{


    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

    // DOM
    const $ = (id) => document.getElementById(id);
    els = {
      name: $("name"),
      roomPass: $("roomPass"),
      joinBtn: $("joinBtn"),
      leaveBtn: $("leaveBtn"),
      menuBtn: $("menuBtn"),
      grid: $("grid"),
      countOnline: $("countOnline"),
      lastSync: $("lastSync"),
      nowClockMain: $("nowClockMain"),

      ctxMenu: $("ctxMenu"),
      ctxTitle: $("ctxTitle"),
      ctxKick: $("ctxKick"),
      ctxClose: $("ctxClose"),

      dashUpdated: $("dashUpdated"),
      pomoCount: $("pomoCount"),
      sudaCount: $("sudaCount"),
      pomoOk: $("pomoOk"),
      sudaOk: $("sudaOk"),
      goPomo: $("goPomo"),
      goPomoMini: $("goPomoMini"),
      goSudaMini: $("goSudaMini"),
      statusRosterList: $("statusRosterList"),
      goSuda: $("goSuda"),
      goChool: $("goChool"),
      goSheet: $("goSheet"),

      chatList: $("chatList"),
      chatInput: $("chatInput"),
      sendBtn: $("sendBtn"),
      embedBar: $("embedBar"),
      embedTitle: $("embedTitle"),
      embedOpen: $("embedOpen"),
      embedClose: $("embedClose"),
      embedFrame: $("embedFrame"),
      embedModal: $("embedModal"),
      closeEmbedModal: $("closeEmbedModal"),
      embedModalTitle: $("embedModalTitle"),
      embedModalOpen: $("embedModalOpen"),
      embedModalFrame: $("embedModalFrame"),

      btnWork: $("btnWork"),
      btnBreak: $("btnBreak"),
      btnIdle: $("btnIdle"),
      statusBtn: $("statusBtn"),
      statusMenu: $("statusMenu"),
      profileBtn: $("profileBtn"),
      onlineBtn: $("onlineBtn"),
      meHint: $("meHint"),

      profileModal: $("profileModal"),
      closeProfile: $("closeProfile"),
      emoji: $("emoji"),
      emojiBgPicker: $("emojiBgPicker"),
      emojiBgColor: $("emojiBgColor"),
      emojiSize: $("emojiSize"),
      emojiSizeNum: $("emojiSizeNum"),
      photoSize: $("photoSize"),
      photoSizeNum: $("photoSizeNum"),
      swatches: $("swatches"),
      bgPicker: $("bgPicker"),
      bgColor: $("bgColor"),
      bgPattern: $("bgPattern"),
      patternPicker: $("patternPicker"),
      patternColor: $("patternColor"),
      bubbleText: $("bubbleText"),
      bubblePicker: $("bubblePicker"),
      bubbleColor: $("bubbleColor"),
      timePicker: $("timePicker"),
      timeColor: $("timeColor"),
      photoFile: $("photoFile"),
      uploadPhotoBtn: $("uploadPhotoBtn"),
      profileNick: $("profileNick"),
      autoBreakMin: $("autoBreakMin"),
      autoIdleMin: $("autoIdleMin"),
      applyProfile: $("applyProfile"),

      dashboardCard: $("dashboardCard"),
      chatCard: $("chatCard"),

      settingsModal: $("settingsModal"),
      closeSettings: $("closeSettings"),
      adminPass: $("adminPass"),
      adminUnlock: $("adminUnlock"),
      adminArea: $("adminArea"),
      pomoUrl: $("pomoUrl"),
      sudaUrl: $("sudaUrl"),
      choolUrl: $("choolUrl"),
      sheetUrl: $("sheetUrl"),
      saveDash: $("saveDash"),

      toast: $("toast"),
    };

    
    function isConfigPlaceholder(v){
      return typeof v === "string" && (v.startsWith("YOUR_") || v.includes("YOUR_PROJECT"));
    }
    function validateFirebaseConfig(){
      const missing = [];
      if(!firebaseConfig || typeof firebaseConfig !== "object"){ missing.push("firebaseConfig"); return missing; }
      const keys = ["apiKey","authDomain","projectId","storageBucket"];
      for(const k of keys){
        const v = firebaseConfig[k];
        if(!v || isConfigPlaceholder(v)) missing.push(k);
      }
      return missing;
    }
    function friendlyAuthHint(code){
      if(!code) return "";
      if(code.includes("auth/operation-not-allowed")) return "➡️ Firebase Authentication에서 '익명(Anonymous)' 로그인 활성화가 필요해.";
      if(code.includes("auth/invalid-api-key")) return "➡️ firebaseConfig의 apiKey가 잘못됐어.";
      if(code.includes("auth/invalid-credential")) return "➡️ firebaseConfig가 프로젝트와 맞는지 확인해줘.";
      if(code.includes("auth/network-request-failed")) return "➡️ 네트워크/방화벽 문제일 수 있어. 다른 네트워크로도 테스트해봐.";
      return "";
    }

    const state = {
      myMission: null,
      uid: null,
      roomId: FIXED_ROOM_ID,
      unsubParticipants: null,
      _lastDayKey: null,
      unsubRoom: null,
      unsubChat: null,
      unsubKick: null,
      tickTimer: null,
      hbTimer: null,
      currentParticipants: new Map(),
      myPhotoUrl: "",
      adminOk: false,
      adminHash: null,
      roomSettings: {
        dashboard: {pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL},
        dashCounts: {pomoCount:null, sudaCount:null, updatedAtMs:null},
        adminHash: null
      },
      localDashCounts: {pomoCount:null, sudaCount:null, updatedAtMs:null},
      dashPollTimer: null,
      dashPollUrl: "",
      lastRendered: new Map(),
      lastActivityMs: Date.now(),
      activityWatchTimer: null,
      activityThrottleMs: 0,
      joined: false,
      ctxTarget: { uid:null, name:null },

    };

    // Helpers
    

    function setMyNickUI(nick){
      try{
        const n = (nick || "").toString().trim().slice(0,20);
        if(!n) return;
        // 상단 닉네임 pill (있다면)
        if(els.nickPill) els.nickPill.textContent = n;
        // 참가자 목록/타일은 Firestore 업데이트로 자동 반영되지만,
        // 로컬 state에도 반영해두면 즉시 표시가 자연스러움
      }catch(e){}
    }
function toast(msg, ms=1600){
      try{
        els.toast.textContent = msg;
        els.toast.classList.add("show");
        if(window.__toastTimer) clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(()=>els.toast.classList.remove("show"), ms);
      }catch(e){
        console.log("toast:", msg);
      }
    }

    // onSnapshot 연결이 룰/권한 문제로 터져도 입장 자체가 죽지 않게 보호
    function safeOnSnapshot(refOrQuery, next){
      try{
        return onSnapshot(refOrQuery, next, (err)=>{
          console.warn('onSnapshot error', err);
        });
        // ✅ 내 전송 직후 바닥으로 이동(점프 최소화)
        try{ els.chatList.scrollTop = els.chatList.scrollHeight; }catch(e){}
      }catch(err){
        console.warn('onSnapshot attach failed', err);
        return ()=>{};
      }
    }


    // --- 우클릭 컨텍스트 메뉴 ---
    function hideCtxMenu(){
      if(!els.ctxMenu) return;
      els.ctxMenu.classList.add("hidden");
      els.ctxMenu.setAttribute("aria-hidden","true");
      state.ctxTarget = {uid:null, name:null};
    }
    function openCtxMenu(x, y, p){
      if(!els.ctxMenu) return;
      state.ctxTarget = { uid: p.id, name: p.name || p.id };
      els.ctxTitle.textContent = `${state.ctxTarget.name}`;
      const canKick = !!(state.joined && state.uid && p.id && p.id !== state.uid);
      els.ctxKick.disabled = !canKick;

      const m = els.ctxMenu;
      m.classList.remove("hidden");
      m.setAttribute("aria-hidden","false");

      // 위치: 화면 밖으로 튀지 않게 보정
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      m.style.left = "0px"; m.style.top = "0px";
      const rect = m.getBoundingClientRect();
      let left = x, top = y;
      if(left + rect.width + 10 > vw) left = Math.max(10, vw - rect.width - 10);
      if(top + rect.height + 10 > vh) top = Math.max(10, vh - rect.height - 10);
      left = Math.max(10, left);
      top = Math.max(10, top);
      m.style.left = `${left}px`;
      m.style.top = `${top}px`;
    }

    const KICK_BLOCK_MS = 2 * 60 * 60 * 1000; // 2시간 재입장 차단(원하면 조절 가능)

    async function requestKick(targetUid, targetName){
      if(!state.roomId || !state.uid || !targetUid) return;
      try{
        const now = Date.now();
        await setDoc(kickRef(state.roomId, targetUid), {
          kickedAtMs: now,
          expiresAtMs: now + KICK_BLOCK_MS,
          byUid: state.uid,
          byName: (els.meHint?.textContent || "익명"),
          targetName: targetName || ""
        }, {merge:true});
        showToast("🚫 강퇴 처리했어");
      }catch(e){
        console.error(e);
        showToast("강퇴 실패(권한/룰 확인)");
      }
    }

    function subscribeKicks(){
      if(state.unsubKick) state.unsubKick();
      state.unsubKick = null;
      if(!state.roomId || !state.uid) return;

      // 룰에 /kicks 매치가 없으면 여기서 권한 에러가 날 수 있어.
      // 그 경우에도 입장/채팅 등 나머지는 정상 동작하도록 '안전'하게 붙인다.
      state.unsubKick = safeOnSnapshot(kickRef(state.roomId, state.uid), (snap)=>{
        if(!snap.exists()) return;
        const k = snap.data() || {};
        const exp = Number(k.expiresAtMs || 0);
        const now = Date.now();
        if(exp && exp < now) return; // 만료
        const by = k.byName || "누군가";
        if(state.joined){
          showToast(`🚫 ${by}님이 강퇴했어`);
          setTimeout(()=>{ if(state.joined) leaveRoom(); }, 350);
        }
      });
    }

    function pad2(n){ return String(n).padStart(2,"0"); }
    function fmtHMS(sec){
      sec = Math.max(0, Math.floor(sec || 0));
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec%60;
      return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
    }
    function nowTimeStr(withSeconds=true){
      const opt = withSeconds ? { timeZone: "Asia/Seoul", hour:"2-digit", minute:"2-digit", second:"2-digit", hour12:false }
                              : { timeZone: "Asia/Seoul", hour:"2-digit", minute:"2-digit", hour12:false };
      return new Intl.DateTimeFormat("ko-KR", opt).format(new Date());
    }
    function updateClocks(){
      const tFull = nowTimeStr(true);
      const tShort = nowTimeStr(false);
      if(els.lastSync) els.lastSync.textContent = tFull;
      if(els.nowClockMain) els.nowClockMain.textContent = tShort;
    }

    
    // -----------------------------
    // ✅ 오늘의 미션(로컬 저장 + 자정 리셋)
    // -----------------------------
    const MK_MISSION_KEY = "mk_mission_v1";
    function loadMissionLocal(){
      try{
        const raw = localStorage.getItem(MK_MISSION_KEY);
        if(!raw) return { dayKey:"", text:"", done:false, doneAt:"" };
        const obj = JSON.parse(raw);
        return {
          dayKey: (obj.dayKey||"").toString(),
          text: (obj.text||"").toString(),
          done: !!obj.done,
          doneAt: (obj.doneAt||"").toString()
        };
      }catch(e){
        return { dayKey:"", text:"", done:false, doneAt:"" };
      }
    }
    function saveMissionLocal(m){
      try{ localStorage.setItem(MK_MISSION_KEY, JSON.stringify(m||{})); }catch(e){}
    }
    function openMissionModal(){
      try{
        const overlay = document.getElementById("missionModal");
        if(!overlay) return;
        const dayKey = seoulDateKey();
        const cur = state.myMission || loadMissionLocal();
        if(cur.dayKey !== dayKey){
          state.myMission = { dayKey, text:"", done:false, doneAt:"" };
          saveMissionLocal(state.myMission);
        }else{
          state.myMission = cur;
        }
        document.getElementById("missionText").value = (state.myMission?.text||"");
        document.getElementById("missionDone").checked = !!state.myMission?.done;
        overlay.classList.add("show");
        overlay.setAttribute("aria-hidden","false");
      }catch(e){}
    }
    function closeMissionModal(){
      try{
        const overlay = document.getElementById("missionModal");
        if(!overlay) return;
        overlay.classList.remove("show");
        overlay.setAttribute("aria-hidden","true");
      }catch(e){}
    }
    function setMissionButtonState(){
      try{
        const btn = document.querySelector(".missionBtn");
        if(!btn) return;
        const m = state.myMission || loadMissionLocal();
        btn.classList.remove("isHot","isDone");
        btn.textContent = "";
        if(m.done){
          btn.classList.add("isDone");
          btn.textContent = "🎖";
          btn.title = `미션 성공! ${m.text||""}`.trim();
          btn.setAttribute("aria-label", `미션 성공: ${m.text||"오늘의 미션"}`);
        }else{
          btn.classList.add("isHot");
          btn.title = m.text ? `오늘의 미션: ${m.text}` : "오늘의 미션 설정하기";
          btn.setAttribute("aria-label", m.text ? `오늘의 미션: ${m.text}` : "오늘의 미션 설정하기");
        }
      }catch(e){}
    }
    function fxFireworksAt(el){
      try{
        const layer = document.getElementById("fxLayer");
        if(!layer || !el) return;
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width/2;
        const cy = r.top + r.height/2;
        const pops = 18;
        for(let i=0;i<pops;i++){
          const p = document.createElement("div");
          p.className = "fxPop";
          const ang = (Math.PI*2) * (i/pops);
          const dist = 24 + Math.random()*22;
          const dx = Math.cos(ang)*dist;
          const dy = Math.sin(ang)*dist;
          p.style.left = cx + "px";
          p.style.top = cy + "px";
          p.style.setProperty("--dx", dx + "px");
          p.style.setProperty("--dy", dy + "px");
          layer.appendChild(p);
          setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 900);
        }
      }catch(e){}
    }

    // -----------------------------
    // ✅ 대시보드 접기/펼치기
    // -----------------------------
    const MK_DASH_FOLD_KEY = "mk_dash_fold_v1";
    function loadDashFold(){ try{ return localStorage.getItem(MK_DASH_FOLD_KEY)==="1"; }catch(e){ return false; } }
    function saveDashFold(v){ try{ localStorage.setItem(MK_DASH_FOLD_KEY, v?"1":"0"); }catch(e){} }
function seoulDateKey(){
      const parts = new Intl.DateTimeFormat("sv-SE", {
        timeZone: "Asia/Seoul", year:"numeric", month:"2-digit", day:"2-digit"
      }).formatToParts(new Date()).reduce((a,p)=> (a[p.type]=p.value, a), {});
      return `${parts.year}-${parts.month}-${parts.day}`;
    }
    const ONLINE_TTL_MS = 5 * 60 * 1000; // 5분: 백그라운드 탭/타이머 쓰로틀링 대비
    function isOnline(lastSeenAtMs){
      if(!lastSeenAtMs) return false;
      return (Date.now() - lastSeenAtMs) < ONLINE_TTL_MS;
    }
    function openUrl(url){
      if(!url){ showToast("설정된 링크가 없어! (☰에서 저장)"); return; }
      window.open(url, "_blank", "noopener,noreferrer");
    }

    // -----------------------------
    // 대시보드 실시간 인원(앱스크립트) JSONP 폴링
    // - CORS 회피용: Apps Script doGet에서 callback 지원이 필요해요.
    // -----------------------------
    function loadJsonp(url, cb){
      try{
        const cbName = "__mk_cb_" + Math.random().toString(36).slice(2);
        window[cbName] = (data)=>{
          try{ cb(null, data); } finally {
            delete window[cbName];
          }
        };
        const hasQ = url.includes("?");
        const withCb = url + (hasQ ? "&" : "?") + "callback=" + cbName + "&_=" + Date.now();
        const sc = document.createElement("script");
        sc.src = withCb;
        sc.async = true;
        sc.onerror = ()=>{ try{ cb(new Error("jsonp error")); } finally { delete window[cbName]; } };
        document.head.appendChild(sc);
        // cleanup later
        setTimeout(()=>{ if(sc.parentNode) sc.parentNode.removeChild(sc); }, 15_000);
      }catch(err){ cb(err); }
    }

    
    async function loadJsonAny(url, cb){
      // 1) try CORS JSON fetch (works with script.googleusercontent.com/macros/echo... 형태도 가능)
      try{
        const u = new URL(url, location.href);
        u.searchParams.set("_", String(Date.now()));
        const res = await fetch(u.toString(), { cache:"no-store", credentials:"omit", mode:"cors" });
        if(res && res.ok){
          const ct = (res.headers.get("content-type") || "").toLowerCase();
          const txt = await res.text();
          // JSON only
          try{
            const data = JSON.parse(txt);
            cb(null, data);
            return;
          }catch(e){
            // not JSON → fallthrough to JSONP
          }
        }
      }catch(e){
        // fetch blocked → fallthrough to JSONP
      }
      // 2) fallback JSONP (requires callback 지원)
      loadJsonp(url, cb);
    }
function ensureDashPolling(){
      const url = (state.roomSettings.dashboard && state.roomSettings.dashboard.dashApiUrl) ? state.roomSettings.dashboard.dashApiUrl.trim() : "";
      if(!url){
        if(state.dashPollTimer){ clearInterval(state.dashPollTimer); state.dashPollTimer=null; }
        state.dashPollUrl = "";
        state.localDashCounts = {pomoCount:null, sudaCount:null, updatedAtMs:null};
        return;
      }
      if(state.dashPollUrl === url && state.dashPollTimer) return;
      state.dashPollUrl = url;
      if(state.dashPollTimer) clearInterval(state.dashPollTimer);

      const tick = ()=>{
        loadJsonAny(url, (err, data)=>{
          if(err) return;
          if(!data || typeof data !== "object") return;
          const pomo = (data.pomo != null) ? data.pomo : (data.pomoCount != null ? data.pomoCount : null);
          const suda = (data.suda != null) ? data.suda : (data.sudaCount != null ? data.sudaCount : null);
          const upd  = data.updatedAtMs || Date.now();
          state.localDashCounts = {pomoCount: pomo, sudaCount: suda, updatedAtMs: upd};
          renderDashboard();
        });
      };
      tick();
      state.dashPollTimer = setInterval(tick, 10_000);
    }

    // ---------- Embeds (optional) ----------
    function openInlineEmbed(title, url){
      openUrl(url);
    }
    function closeInlineEmbed(){
      els.embedBar.style.display = "none";
      els.embedFrame.style.display = "none";
      els.embedFrame.src = "about:blank";
      els.chatList.style.display = "block";
      const row = els.chatInput.closest(".chatInputRow");
      if(row) row.style.display = "";
    }
    function openEmbedModal(title, url){
      openUrl(url);
    }
    function closeEmbedModal(){
      hideModal(els.embedModal);
      els.embedModalFrame.src = "about:blank";
    }

    
    // -----------------------------
    // Dashboard docking: stick dashboard card right under the settings (☰) button
    // - On wide screens: dashboard becomes fixed and follows the button's position
    // - On small screens: dashboard returns to normal flow (so it doesn't cover the UI)
    // -----------------------------
    function dockRightRail(){
      try{ ensureChatUI(); }catch(e){}
      const dash = els.dashboardCard || document.getElementById("dashboardCard");
      const chat = els.chatCard || document.getElementById("chatCard");
      const anchor = els.menuBtn;
      if(!dash || !anchor) return;

      const wide = window.innerWidth > 980;

      const reset = (el, cls)=>{
        if(!el) return;
        el.classList.remove(cls);
        el.style.position = "";
        el.style.top = "";
        el.style.right = "";
        el.style.left = "";
        el.style.width = "";
        el.style.maxHeight = "";
        el.style.height = "";
        el.style.overflow = "";
      };

      if(!wide){
        reset(dash, "docked");
        reset(chat, "dockedChat");
        return;
      }

      const r = anchor.getBoundingClientRect();
      const right = Math.max(10, window.innerWidth - r.right);
      const top = Math.max(12, r.bottom + 18);     // ✅ 상단바↔대시보드 여백
      const gap = 12;                               // ✅ 대시보드↔채팅 여백

      dash.classList.add("docked");
      dash.style.top = top + "px";
      dash.style.right = right + "px";
      dash.style.maxHeight = `calc(100vh - ${top + 18}px)`;
      dash.style.overflow = "auto";

      if(chat){
        // chat should sit right under dashboard, same width, and stretch down.
        const dr = dash.getBoundingClientRect();
        const minChatTop = top + 56; // ✅ 접기 시 빈 패널(잔상) 방지
        const chatTop = Math.max(dr.bottom + gap, minChatTop);
        const bottomPad = 14;

        chat.classList.add("dockedChat");
        chat.style.position = "fixed";
        chat.style.right = right + "px";
        chat.style.top = chatTop + "px";
        chat.style.width = dr.width + "px";
        chat.style.height = `calc(100vh - ${chatTop + bottomPad}px)`;
        chat.style.maxHeight = `calc(100vh - ${chatTop + bottomPad}px)`;
        chat.style.overflow = "hidden";
        try{ ensureChatUI(); }catch(e){}
      }
    }



    
    // ✅ Chat UI 보강: 접기/도킹/리사이즈 중 내부 레이아웃이 0으로 눌려 '빈 패널'처럼 보이는 경우 방지
    function ensureChatUI(){
      try{
        const card = document.getElementById("chatCard");
        if(!card) return;
        // Make card a flex column so header+body lay out correctly even when height is forced (docked)
        card.style.display = "flex";
        card.style.flexDirection = "column";

        // Ensure body exists
        let body = card.querySelector(".body.chatBody") || card.querySelector(".body");
        if(!body){
          body = document.createElement("div");
          body.className = "body chatBody";
          card.appendChild(body);
        }
        body.style.display = "flex";
        body.style.flexDirection = "column";
        body.style.flex = "1 1 auto";
        body.style.minHeight = "0";
        body.style.overflow = "hidden";

        // Ensure chat list
        let list = body.querySelector("#chatList");
        if(!list){
          list = document.createElement("div");
          list.id = "chatList";
          list.className = "chatList";
          body.appendChild(list);
        }
        list.style.flex = "1 1 auto";
        list.style.minHeight = "0";
        list.style.overflow = "auto";

        // Ensure input row
        let row = body.querySelector(".chatInputRow");
        if(!row){
          row = document.createElement("div");
          row.className = "chatInputRow";
          const inp = document.createElement("input");
          inp.id = "chatInput";
          inp.placeholder = "메시지…";
          const btn = document.createElement("button");
          btn.id = "sendBtn";
          btn.className = "primary";
          btn.textContent = "전송";
          row.appendChild(inp);
          row.appendChild(btn);
          body.appendChild(row);
        }
        row.style.display = "flex";
        row.style.gap = "8px";
        row.style.flex = "0 0 auto";

        // If something is covering clicks, keep chat on top
        card.style.position = card.style.position || "";
        card.style.zIndex = card.style.zIndex || "55";
        card.style.pointerEvents = "auto";
        body.style.pointerEvents = "auto";
        list.style.pointerEvents = "auto";
        row.style.pointerEvents = "auto";
      }catch(e){}
    }


    function setControlsEnabled(joined){
      els.leaveBtn.disabled = !joined;
      els.joinBtn.disabled = joined;
      els.name.disabled = joined;
      els.menuBtn.disabled = !joined;

      // hide/show nickname & pass area on join
      els.name.style.display = joined ? "none" : "";
      if(els.roomPass) els.roomPass.style.display = (joined || document.body.classList.contains("passok")) ? "none" : "";
      els.joinBtn.style.display = joined ? "none" : "";
      els.leaveBtn.style.display = joined ? "" : "";
      els.meHint.style.display = joined ? "" : "";

      els.btnWork.disabled = !joined;
      els.btnBreak.disabled = !joined;
      els.btnIdle.disabled = !joined;
      els.statusBtn.disabled = !joined;
      // 프로필은 입장 전에도 꾸밀 수 있게 항상 활성
      els.profileBtn.disabled = false;
      if(els.onlineBtn) els.onlineBtn.disabled = !joined;

      els.chatInput.disabled = !joined;
      els.sendBtn.disabled = !joined;

      // lamp
      document.body.classList.toggle("joined", joined);
      state.joined = joined;
      // keep dashboard positioned under ☰
      dockRightRail();
    }
    
    function syncMyStatusUI(){
      const me = state.currentParticipants.get(state.uid);
      const st = (me && me.status) ? me.status : "idle";
      const label = (st==="work") ? "✍️ 작업중" : (st==="break") ? "☕ 휴식중" : "🌙 자리비움";
      if(els.statusBtn) els.statusBtn.textContent = `${label} ▾`;
      if(els.btnWork) els.btnWork.className = (st==="work") ? "primary" : "ghost";
      if(els.btnBreak) els.btnBreak.className = (st==="break") ? "primary" : "ghost";
      if(els.btnIdle) els.btnIdle.className = (st==="idle") ? "primary" : "ghost";
    }

function showModal(el){ el.classList.add("show"); }
    function hideModal(el){ el.classList.remove("show"); }

    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const hashBuf = await crypto.subtle.digest("SHA-256", enc);
      const arr = Array.from(new Uint8Array(hashBuf));
      return arr.map(b=>b.toString(16).padStart(2,"0")).join("");
    }
    function clampNum(v, min, max, def){
      const n = Number(v);
      if(!Number.isFinite(n)) return def;
      return Math.min(max, Math.max(min, n));
    }

    function clampHexColor(s){
      s = (s||"").trim();
      if(!s) return "#ffd0e2";
      if(/^#[0-9a-fA-F]{6}$/.test(s)) return s;
      if(/^#[0-9a-fA-F]{3}$/.test(s)){
        return "#" + s.slice(1).split("").map(c=>c+c).join("");
      }
      return "#ffd0e2";
    }

    function hexToRgba(hex, a){
      const c = clampHexColor(hex);
      const r = parseInt(c.slice(1,3),16);
      const g = parseInt(c.slice(3,5),16);
      const b = parseInt(c.slice(5,7),16);
      const alpha = (a===undefined || a===null) ? 1 : Math.max(0, Math.min(1, Number(a)));
      return `rgba(${r},${g},${b},${alpha})`;
    }

    const DEFAULT_SWATCHES = [
      "#ffffff",
      "#dedede",
      "#b3b3b3",
      "#666666",
      "#262626",
      "#000000",
      "#ffd0e2",
      "#fe9dc0",
      "#ff5b98",
      "#ff005e",
      "#ffcdfe",
      "#fd92fa",
      "#ff41f9",
      "#fe00f6",
      "#e2c6ff",
      "#c185ff",
      "#9e42ff",
      "#7b00ff",
      "#d2e3ff",
      "#96bdff",
      "#4a90ff",
      "#0060ff",
      "#c8f7ff",
      "#87ecff",
      "#46e1ff",
      "#01d6fe",
      "#c6fff8",
      "#8ffff1",
      "#4bfee8",
      "#00ffdf",
      "#ccffc6",
      "#9eff94",
      "#63ff54",
      "#15ff00",
      "#f5ffcb",
      "#ebff9e",
      "#ddff51",
      "#cbff00",
      "#feffd3",
      "#fbfa9d",
      "#feff75",
      "#ffff00",
      "#fff1dc",
      "#fddeaf",
      "#ffc162",
      "#ff9a00",
      "#ffe5d8",
      "#fdc19f",
      "#fa8649",
      "#ff5800",
      "#ffc9c9",
      "#fe9c9b",
      "#fb5352",
      "#fe0000",
      "#fff8e8",
      "#fff1d6",
      "#ffe5b4",
      "#e2c490",
      "#efc2ab",
      "#d49b7e",
      "#a46b4e",
      "#835136"
    ];

    function setBgColorAll(hex){
      const c = clampHexColor(hex);
      if(els.bgColor) els.bgColor.value = c;
      if(els.bgPicker) els.bgPicker.value = c;
      // active swatch highlight
      if(els.swatches){
        [...els.swatches.querySelectorAll(".swatch")].forEach(s=>{
          s.classList.toggle("active", s.dataset.hex.toLowerCase() === c.toLowerCase());
        });
      }
    }

    function initPalette(){
      if(!els.swatches || !els.bgPicker || !els.bgColor) return;

      // render swatches once
      if(!els.swatches.dataset.ready){
        els.swatches.innerHTML = "";
        for(const hex of DEFAULT_SWATCHES){
          const b = document.createElement("button");
          b.type = "button";
          b.className = "swatch";
          b.style.background = hex;
          b.dataset.hex = hex;
          b.title = hex;
          b.addEventListener("click", ()=>setBgColorAll(hex));
          els.swatches.appendChild(b);
        }
        els.swatches.dataset.ready = "1";
      }
      function setEmojiBgAll(hex){
        const c = clampHexColor(hex || "#2b2b2b");
        if(els.emojiBgColor) els.emojiBgColor.value = c;
        if(els.emojiBgPicker) els.emojiBgPicker.value = c;
      }
      function setBubbleColorAll(hex){
        const fallback = (els.bgColor && els.bgColor.value) ? els.bgColor.value : "#ffd0e2";
        const c = clampHexColor(hex || fallback);
        if(els.bubbleColor) els.bubbleColor.value = c;
        if(els.bubblePicker) els.bubblePicker.value = c;
      }


      function setTimeColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.timeColor) els.timeColor.value = c;
        if(els.timePicker) els.timePicker.value = c;
      }


      // sync: picker -> code
      els.bgPicker.addEventListener("input", ()=>setBgColorAll(els.bgPicker.value));
      // sync: code -> picker (on blur + enter)
      els.bgColor.addEventListener("change", ()=>setBgColorAll(els.bgColor.value));
      els.bgColor.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); setBgColorAll(els.bgColor.value); }
      });

      // initial
      setBgColorAll(els.bgColor.value || els.bgPicker.value || "#ffd0e2");
      // emoji bg color controls
      if(els.emojiBgPicker && els.emojiBgColor){
        els.emojiBgPicker.addEventListener("input", ()=>setEmojiBgAll(els.emojiBgPicker.value));
        els.emojiBgColor.addEventListener("change", ()=>setEmojiBgAll(els.emojiBgColor.value));
        els.emojiBgColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setEmojiBgAll(els.emojiBgColor.value); }
        });
        setEmojiBgAll(els.emojiBgColor.value || els.emojiBgPicker.value || "#2b2b2b");
      }

      // bubble color controls
      if(els.bubblePicker && els.bubbleColor){
        els.bubblePicker.addEventListener("input", ()=>setBubbleColorAll(els.bubblePicker.value));
        els.bubbleColor.addEventListener("change", ()=>setBubbleColorAll(els.bubbleColor.value));
        els.bubbleColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setBubbleColorAll(els.bubbleColor.value); }
        });
        setBubbleColorAll(els.bubbleColor.value || els.bubblePicker.value || (els.bgColor ? els.bgColor.value : "#ffd0e2"));
      }

      // time color controls (work time only)
      if(els.timePicker && els.timeColor){
        els.timePicker.addEventListener("input", ()=>setTimeColorAll(els.timePicker.value));
        els.timeColor.addEventListener("change", ()=>setTimeColorAll(els.timeColor.value));
        els.timeColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setTimeColorAll(els.timeColor.value); }
        });
        
// pattern color controls
function setPatternColorAll(v){
  if(!els.patternPicker || !els.patternColor) return;
  const hex = clampHexColor(v || "#ffffff");
  els.patternPicker.value = hex;
  els.patternColor.value = hex;
}

    
    function normalizeHexInput(v){
      try{
        let s = (v || "").toString().trim();
        if(!s) return "";
        if(!s.startsWith("#")) s = "#" + s;
        // allow shorthand
        if(/^#([0-9a-fA-F]{3})$/.test(s)){
          const a = s[1], b = s[2], c = s[3];
          s = "#" + a+a + b+b + c+c;
        }
        if(/^#([0-9a-fA-F]{6})$/.test(s)) return s.toLowerCase();
        return "";
      }catch(e){ return ""; }
    }
    function attachColorSync(textEl, pickerEl){
      if(!textEl || !pickerEl) return;
      const sync = ()=>{
        const norm = normalizeHexInput(textEl.value) || clampHexColor(textEl.value);
        if(norm){
          textEl.value = norm;
          pickerEl.value = norm;
        }
      };
      textEl.addEventListener("change", sync);
      textEl.addEventListener("blur", sync);
      textEl.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ sync(); textEl.blur(); }});
      pickerEl.addEventListener("input", ()=>{
        textEl.value = pickerEl.value;
      });
    }
// ✅ 이모지 1개만 허용 (grapheme 기준)
    function firstEmojiGrapheme(str){
      try{
        const s = (str || "").toString().trim();
        if(!s) return "";
        if(typeof Intl !== "undefined" && Intl.Segmenter){
          const seg = new Intl.Segmenter("en", { granularity: "grapheme" });
          for(const it of seg.segment(s)){
            return it.segment;
          }

    // ✅ 안전장치: 다른 스크립트/번들에서 누락되더라도 저장 버튼이 죽지 않게
    try{ if(typeof window!=="undefined" && typeof window.firstEmojiGrapheme!=="function"){ window.firstEmojiGrapheme = firstEmojiGrapheme; } }catch(e){}
          return "";
        }
        // fallback: 첫 codepoint
        const cp = Array.from(s);
        return cp[0] || "";
      }catch(e){
        return "";
      }
    }


    // ✅ 집중시간(24시간 누적, 자정 리셋) — 전역 유틸
    function loadFocusSeconds(){
      const today = seoulDateKey();
      // ✅ 미션 로컬 로드 + 날짜 불일치면 초기화
      try{
        const m0 = loadMissionLocal();
        if(m0.dayKey !== today){
          state.myMission = { dayKey: today, text:"", done:false, doneAt:"" };
          saveMissionLocal(state.myMission);
        }else{
          state.myMission = m0;
        }
      }catch(e){ state.myMission = { dayKey: today, text:"", done:false, doneAt:"" }; }

      try{
        const day = localStorage.getItem(LS_FOCUS_DAY) || "";
        const sec = Number(localStorage.getItem(LS_FOCUS_SEC) || 0);
        if(day !== today){
          localStorage.setItem(LS_FOCUS_DAY, today);
          localStorage.setItem(LS_FOCUS_SEC, "0");
          return 0;
        }
        return isFinite(sec) ? Math.max(0, sec) : 0;
      }catch(e){
        return 0;
      }
    }
    function saveFocusSeconds(sec){
      const today = seoulDateKey();
      try{
        localStorage.setItem(LS_FOCUS_DAY, today);
        localStorage.setItem(LS_FOCUS_SEC, String(Math.max(0, Math.floor(Number(sec)||0))));
      }catch(e){}
    }
    function persistMyFocusToLocal(){
      try{
        const me = state.currentParticipants.get(state.uid);
        if(!me) return;
        const totalNow = computeDisplayedTotal(me); // seconds
        focusSaveSeconds(totalNow);
      }catch(e){}
    }


    // (dedup) focus helpers already declared above

if(els.patternPicker && els.patternColor){
  els.patternPicker.addEventListener("input", ()=>setPatternColorAll(els.patternPicker.value));
  els.patternColor.addEventListener("change", ()=>setPatternColorAll(els.patternColor.value));
  els.patternColor.addEventListener("keydown", (e)=>{
    if(e.key==="Enter"){ e.preventDefault(); setPatternColorAll(els.patternColor.value); }
  });
  setPatternColorAll(els.patternColor.value || els.patternPicker.value || "#ffffff");
}

setTimeColorAll(els.timeColor.value || els.timePicker.value || "#ffffff");
      }

      // size controls (emoji/photo)
      function setEmojiSizeAll(v){
        if(!els.emojiSize || !els.emojiSizeNum) return;
        const n = clampNum(v, 26, 100, 40);
        els.emojiSize.value = String(n);
        els.emojiSizeNum.value = String(n);
      }
      function setPhotoSizeAll(v){
        if(!els.photoSize || !els.photoSizeNum) return;
        const n = clampNum(v, 52, 100, 68);
        els.photoSize.value = String(n);
        els.photoSizeNum.value = String(n);
      }
      if(els.emojiSize && els.emojiSizeNum){
        els.emojiSize.addEventListener("input", ()=>setEmojiSizeAll(els.emojiSize.value));
        els.emojiSizeNum.addEventListener("change", ()=>setEmojiSizeAll(els.emojiSizeNum.value));
        els.emojiSizeNum.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setEmojiSizeAll(els.emojiSizeNum.value); }
        });
        setEmojiSizeAll(els.emojiSize.value || els.emojiSizeNum.value || 54);
      }
      if(els.photoSize && els.photoSizeNum){
        els.photoSize.addEventListener("input", ()=>setPhotoSizeAll(els.photoSize.value));
        els.photoSizeNum.addEventListener("change", ()=>setPhotoSizeAll(els.photoSizeNum.value));
        els.photoSizeNum.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setPhotoSizeAll(els.photoSizeNum.value); }
        });
        setPhotoSizeAll(els.photoSize.value || els.photoSizeNum.value || 68);
      }


    }

    function bgStyle(color, pattern, patColor){
      const c = clampHexColor(color);
      const p = (pattern || "none").trim();

      const pc = clampHexColor(patColor || "#ffffff");
      const pc32 = hexToRgba(pc, 0.32);
      const pc30 = hexToRgba(pc, 0.30);
      const pc28 = hexToRgba(pc, 0.28);
      const pc26 = hexToRgba(pc, 0.26);
      const pc24 = hexToRgba(pc, 0.24);
      const pc22 = hexToRgba(pc, 0.22);
      const pc20 = hexToRgba(pc, 0.20);
      const pc18 = hexToRgba(pc, 0.18);
      const pc16 = hexToRgba(pc, 0.16);
      const pc14 = hexToRgba(pc, 0.14);
      const pc12 = hexToRgba(pc, 0.12);
      const pc10 = hexToRgba(pc, 0.10);
      const pc08 = hexToRgba(pc, 0.08);


      // pattern layers (top-most first)
      const layers = [];

      const base = `linear-gradient(0deg, ${c}, ${c})`;

      if(p === "dots"){
        layers.push(`radial-gradient(circle at 9px 9px, ${pc32} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 19px 19px, ${pc22} 2px, transparent 2.4px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "microdots"){
        layers.push(`radial-gradient(circle at 6px 6px, ${pc28} 1.2px, transparent 1.6px)`);
        layers.push(`radial-gradient(circle at 14px 14px, ${pc18} 1.2px, transparent 1.6px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "grid"){
        layers.push(`linear-gradient(${pc18} 1px, transparent 1px)`);
        layers.push(`linear-gradient(90deg, ${pc18} 1px, transparent 1px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "papergrid"){
        layers.push(`linear-gradient(${pc08} 1px, transparent 1px)`);
        layers.push(`linear-gradient(90deg, ${pc08} 1px, transparent 1px)`);
layers.push(base);
        return layers.join(", ");
      }
      if(p === "stripes"){
        layers.push(`repeating-linear-gradient(45deg, ${pc22} 0 10px, transparent 10px 20px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "diagonal"){
        layers.push(`repeating-linear-gradient(135deg, ${pc22} 0 8px, transparent 8px 18px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "checker"){
        layers.push(`linear-gradient(45deg, ${pc18} 25%, transparent 25% 75%, ${pc18} 75%)`);
        layers.push(`linear-gradient(45deg, ${pc10} 25%, transparent 25% 75%, ${pc10} 75%)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "waves"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="80" height="40" viewBox="0 0 80 40">
          <path d="M0 20c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="${pc22}" stroke-width="3" stroke-linecap="round"/>
          <path d="M0 32c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="${pc14}" stroke-width="2" stroke-linecap="round"/>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "sparkles"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60">
          <g fill="${pc26}">
            <path d="M30 10l2.3 6.7L39 19l-6.7 2.3L30 28l-2.3-6.7L21 19l6.7-2.3z"/>
            <circle cx="12" cy="14" r="1.6" fill="${pc22}"/>
            <circle cx="48" cy="40" r="1.9" fill="${pc18}"/>
            <circle cx="18" cy="46" r="1.3" fill="${pc18}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "confetti"){
        layers.push(`radial-gradient(circle at 12px 10px, ${pc30} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 26px 24px, ${pc20} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 44px 14px, ${pc08} 2px, transparent 2.4px)`);
        layers.push(`repeating-linear-gradient(0deg, ${pc10} 0 1px, transparent 1px 16px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "stars"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc24}">
            <path d="M12 14l1.7 4.8L18 20l-4.3 1.2L12 26l-1.7-4.8L6 20l4.3-1.2z"/>
            <path d="M44 10l2 5.6L51 17l-5 1.4L44 24l-2-5.6L37 17l5-1.4z" fill="${pc18}"/>
            <path d="M50 44l1.8 5.2L56 51l-4.2 1.2L50 58l-1.8-5.2L44 51l4.2-1.2z"/>
            <circle cx="26" cy="46" r="1.5" fill="${pc18}"/>
            <circle cx="18" cy="34" r="1.2" fill="${pc16}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "moon"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="72" height="72" viewBox="0 0 72 72">
          <g>
            <path d="M46 12c-6.5 2.6-11 9-11 16.5 0 10 8 18 18 18 2.4 0 4.7-.5 6.8-1.3C57.8 54.3 49 60.5 38.8 60.5 24.8 60.5 13.5 49.2 13.5 35.2 13.5 22.7 22.3 12.1 33.9 9.4c4.1-1 8.3-.7 12.1 2.6z"
              fill="${pc22}"/>
            <circle cx="18" cy="18" r="1.3" fill="${pc16}"/>
            <circle cx="24" cy="12" r="1.0" fill="${pc12}"/>
            <circle cx="14" cy="30" r="1.1" fill="${pc14}"/>
            <circle cx="56" cy="18" r="1.2" fill="${pc12}"/>
            <circle cx="60" cy="30" r="1.0" fill="${pc10}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "flowers"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="72" height="72" viewBox="0 0 72 72">
          <g fill="none" stroke="none">
            <g transform="translate(10 10)">
              <g>
                <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc18}"/>
                <circle cx="14" cy="18" r="3" fill="${pc30}"/>
              </g>
            </g>
            <g transform="translate(38 30) scale(0.9)">
              <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc14}"/>
              <circle cx="14" cy="18" r="3" fill="${pc26}"/>
            </g>
            <g transform="translate(30 6) scale(0.7)">
              <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc12}"/>
              <circle cx="14" cy="18" r="3" fill="${pc22}"/>
            </g>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "clouds"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="96" height="64" viewBox="0 0 96 64">
          <g fill="${pc18}">
            <path d="M30 42c-7 0-12-5-12-11 0-5 3-9 8-10 2-8 9-14 18-14 9 0 17 6 19 15 6 1 11 6 11 12 0 7-6 13-13 13H30z" opacity="0.9"/>
            <path d="M10 54c-5 0-9-4-9-8 0-4 2-7 6-8 1-6 7-10 13-10 7 0 13 5 14 12 5 1 8 4 8 9 0 5-4 9-9 9H10z" opacity="0.65"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "catpaws"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc22}">
            <circle cx="18" cy="20" r="4"/>
            <circle cx="28" cy="16" r="4"/>
            <circle cx="38" cy="16" r="4"/>
            <circle cx="48" cy="20" r="4"/>
            <path d="M32 30c-7 0-12 6-12 12 0 6 5 10 12 10s12-4 12-10c0-6-5-12-12-12z" fill="${pc18}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "dogpaws"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc22}">
            <ellipse cx="18" cy="18" rx="4.2" ry="5.0"/>
            <ellipse cx="28" cy="14" rx="4.2" ry="5.0"/>
            <ellipse cx="36" cy="14" rx="4.2" ry="5.0"/>
            <ellipse cx="46" cy="18" rx="4.2" ry="5.0"/>
            <path d="M32 28c-8 0-14 7-14 14 0 7 6 12 14 12s14-5 14-12c0-7-6-14-14-14z" fill="${pc16}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "hearts"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36">
          <path d="M18 30s-9-5.6-12.3-10.7C3 14.6 5.4 10 10 10c2.2 0 4.1 1.1 5.2 2.7C16.2 11.1 18.1 10 20.3 10 24.9 10 27.3 14.6 30.3 19.3 27 24.4 18 30 18 30z"
            fill="rgba(255,255,255,0.28)"/>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      // none
      return base;
    }



    // Firestore paths
    function roomRef(roomId){ return doc(db, "rooms", roomId); }
    function meRef(roomId, uid){ return doc(db, "rooms", roomId, "participants", uid); }
    function participantsCol(roomId){ return collection(db, "rooms", roomId, "participants"); }
    function chatCol(roomId){ return collection(db, "rooms", roomId, "messages"); }
    function kicksCol(roomId){ return collection(db, "rooms", roomId, "kicks"); }
    function kickRef(roomId, uid){ return doc(db, "rooms", roomId, "kicks", uid); }

    async function ensureRoom(roomId){
      const r = roomRef(roomId);
      const snap = await getDoc(r);
      if(!snap.exists()){
        await setDoc(r, {
          createdAt: serverTimestamp(),
          title: roomId,
          adminHash: null,
          dashboard: { pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL },
          dashCounts: { pomoCount:null, sudaCount:null, updatedAtMs: null }
        });
      }
    }
    function defaultTheme(){
      const lp = loadLocalProfile();
      if(lp && lp.theme){
        return {
          emoji: (lp.theme.emoji || "✍️").trim(),
          bgColor: clampHexColor(lp.theme.bgColor || "#ffd0e2"),
          pattern: (lp.theme.pattern || "none"),
          patternColor: clampHexColor(lp.theme.patternColor || "#ffffff"),
          photoUrl: (lp.theme.photoUrl || ""),
          emojiBg: clampHexColor(lp.theme.emojiBg || "#2b2b2b"),
          bubbleColor: clampHexColor(lp.theme.bubbleColor || lp.theme.bgColor || "#ffd0e2"),
          timeColor: clampHexColor(lp.theme.timeColor || "#ffffff"),
          emojiSize: Number(lp.theme.emojiSize || 40),
          photoSize: Number(lp.theme.photoSize || 68)
        };
      }
      return { emoji: "✍️", bgColor: "#ffd0e2", pattern: "none", patternColor:"#ffffff", photoUrl: "", emojiBg:"#2b2b2b", bubbleColor:"#ffd0e2", timeColor:"#ffffff", emojiSize:40, photoSize:68 };
    }
    async function ensureMeDoc(){
      const ref = meRef(state.roomId, state.uid);
      const snap = await getDoc(ref);
      const today = seoulDateKey();
      if(!snap.exists()){
        await setDoc(ref, {
          name: els.name.value.trim(),
          dateKey: today,
          status: "idle",
          totalSecondsToday: focusLoadSeconds(),
          sessionStartedAtMs: null,
          bubbleText: (((loadLocalProfile()||{}).bubbleText || "").toString().trim().slice(0,140)),
          theme: defaultTheme(),
          mission: state.myMission || { dayKey: today, text:"", done:false, doneAt:"" },
          lastSeenAtMs: Date.now(),
          updatedAt: Date.now(),
        });
      } else {
        const data = snap.data();
        // ✅ 기존 데이터에도 미션 필드 동기화(구버전 호환)
        try{
          const m = state.myMission || loadMissionLocal();
          const need = (!data.mission) || (data.mission?.dayKey !== today);
          if(need){
            const m2 = (m.dayKey===today) ? m : { dayKey: today, text:"", done:false, doneAt:"" };
            state.myMission = m2;
            saveMissionLocal(m2);
            await updateDoc(ref, { mission: m2, updatedAt: Date.now(), lastSeenAtMs: Date.now() });
          }
        }catch(e){}

        // ✅ bubbleText가 아예 없으면(구버전 데이터) 로컬에 저장된 말풍선을 1회 시드
        if((data.bubbleText === undefined || data.bubbleText === null) ){
          try{
            const lp = loadLocalProfile() || {};
            const bt = (lp.bubbleText || "").toString().trim().slice(0,140);
            if(bt) await updateDoc(ref, { bubbleText: bt, updatedAt: Date.now(), lastSeenAtMs: Date.now() });
          }catch(e){}
        }
        if(data.dateKey !== today){
          focusSaveSeconds(0);
          await updateDoc(ref, {
            dateKey: today,
            totalSecondsToday: 0,
            sessionStartedAtMs: null,
            status: "idle",
            updatedAt: Date.now(),
          });
        }
      }
    }
    async function heartbeat(){
      if(!state.roomId || !state.uid) return;
      try{
        await updateDoc(meRef(state.roomId, state.uid), {
          lastSeenAtMs: Date.now(),
          updatedAt: Date.now(),
        });
      }catch(e){}
    }
    function computeDisplayedTotal(p){
      const base = Number(p.totalSecondsToday || 0);
      if(p.status === "work" && p.sessionStartedAtMs){
        return base + Math.max(0, (Date.now() - p.sessionStartedAtMs)/1000);
      }
      return base;
    }

    // --- 활동 감지 (집중 시간 자동 전환) ---
    function bumpActivity(){
      const now = Date.now();
      // 너무 잦은 이벤트는 살짝 줄이기
      if(now - (state.activityThrottleMs || 0) < 800) return;
      state.activityThrottleMs = now;
      state.lastActivityMs = now;
    }
    ["mousemove","mousedown","keydown","scroll","touchstart"].forEach((ev)=>{
      window.addEventListener(ev, bumpActivity, {passive:true});
    });
    document.addEventListener("visibilitychange", ()=>{
      if(document.visibilityState === "visible") bumpActivity();
    });

    function stopActivityWatch(){
      if(state.activityWatchTimer){
        clearInterval(state.activityWatchTimer);
        state.activityWatchTimer = null;
      }
      if(state.dayWatchTimer){
        clearInterval(state.dayWatchTimer);
        state.dayWatchTimer = null;
      }
    }
    function startActivityWatch(){
      stopActivityWatch();
      state.activityWatchTimer = setInterval(()=>{
        if(!state.joined || !state.roomId || !state.uid) return;

        const me = state.currentParticipants ? state.currentParticipants.get(state.uid) : null;
        const status = me?.status || "idle";
        if(status !== "work") return;

        const idleMs = Date.now() - (state.lastActivityMs || Date.now());
        // ✅ 로컬(내 프로필)에서 자동 전환 시간(분)을 읽어 적용
        let ab = 10, ai = 15;
        try{
          const lp = loadLocalProfile() || {};
          ab = Math.min(180, Math.max(1, Number(lp.autoBreakMin ?? 10)));
          ai = Math.min(180, Math.max(1, Number(lp.autoIdleMin ?? 15)));
          if(ai < ab) ai = Math.min(180, ab + 5);
        }catch(e){}
        if(idleMs >= ai*60*1000){
          transitionTo("idle");
          showToast(`${ai}분 무반응 → 자리비움`);
        }else if(idleMs >= ab*60*1000){
          transitionTo("break");
          showToast(`${ab}분 무반응 → 휴식중`);
        }
      }, 15000);

      // ✅ 자정(KST) 넘어가면 집중시간 로컬/내 문서 리셋
      if(state.dayWatchTimer) clearInterval(state.dayWatchTimer);
      state._lastDayKey = state._lastDayKey || seoulDateKey();
      state.dayWatchTimer = setInterval(async ()=>{
        try{
          const dk = seoulDateKey();
          if(!state._lastDayKey) state._lastDayKey = dk;
          if(state._lastDayKey !== dk){
            state._lastDayKey = dk;
            focusSaveSeconds(0);
            // 내가 방에 들어와 있는 상태면 내 문서도 리셋
            if(state.uid && state.roomId){
              const ref = meRef(state.roomId, state.uid);
              await updateDoc(ref, { dateKey: dk, status: "idle", totalSecondsToday: 0, sessionStartedAtMs: null, updatedAt: Date.now(), lastSeenAtMs: Date.now() });
            }
          }
        }catch(e){}
      }, 60000);

    }

    async function transitionTo(nextStatus){
      // ✅ 상태 전환 직전 현재 집중시간을 로컬에 누적 저장
      persistMyFocusToLocal();
      const ref = meRef(state.roomId, state.uid);
      const snap = await getDoc(ref);
      if(!snap.exists()) return;
      const p = snap.data();
      const now = Date.now();
      const patch = { status: nextStatus, updatedAt: now, lastSeenAtMs: now };
      if(nextStatus === "work") { state.lastActivityMs = now; }

      if(p.status === "work" && p.sessionStartedAtMs){
        const deltaSec = Math.max(0, Math.floor((now - p.sessionStartedAtMs)/1000));
        patch.totalSecondsToday = (p.totalSecondsToday || 0) + deltaSec;
        patch.sessionStartedAtMs = null;
      }
      if(nextStatus === "work" && p.status !== "work"){
        patch.sessionStartedAtMs = now;
      }
      await updateDoc(ref, patch);
    }
    async function applyProfile(){
      const theme = {
        emoji: (typeof firstEmojiGrapheme==="function" ? firstEmojiGrapheme : (s=> (Array.from(((s||"").toString().trim()))[0]||"")))(els.emoji.value || "✍️"),
        bgColor: clampHexColor(els.bgColor.value),
        pattern: (els.bgPattern && els.bgPattern.value ? els.bgPattern.value : "none"),
        patternColor: clampHexColor((els.patternColor && els.patternColor.value) ? els.patternColor.value : "#ffffff"),
        photoUrl: state.myPhotoUrl || "",
        emojiBg: clampHexColor((els.emojiBgColor && els.emojiBgColor.value) ? els.emojiBgColor.value : "#2b2b2b"),
        bubbleColor: clampHexColor((els.bubbleColor && els.bubbleColor.value) ? els.bubbleColor.value : (els.bgColor ? els.bgColor.value : "#ffd0e2")),
        timeColor: clampHexColor((els.timeColor && els.timeColor.value) ? els.timeColor.value : "#ffffff"),
        emojiSize: 82,
        photoSize: 82
      };
      const bubbleText = (els.bubbleText.value || "").trim().slice(0, 140);
      const newNick = (els.profileNick?.value || "").trim().slice(0,20);
      if(newNick){
        state.nickname = newNick;
        if(els.name) els.name.value = newNick;
        try{ localStorage.setItem("mk_last_name", newNick); }catch(e){}
      }


      // ✅ 자동 전환(분) — 작업중일 때만 적용
      const autoBreakMin = Math.min(180, Math.max(1, Number(els.autoBreakMin?.value || 10)));
      const autoIdleMin  = Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || 15)));
      if(autoIdleMin < autoBreakMin){ /* 안전장치 */
        // 자리비움이 휴식보다 빨라지면 휴식+5로 보정
        const fixed = Math.min(180, autoBreakMin + 5);
        if(els.autoIdleMin) els.autoIdleMin.value = String(fixed);
      }


      // ✅ 브라우저에 프리셋 저장(로그인/입장 전에도 유지)
      try{
        const lp = loadLocalProfile() || {};
        lp.theme = theme;
        lp.bubbleText = bubbleText;
        if(state.nickname) lp.nickname = state.nickname;
        lp.autoBreakMin = Math.min(180, Math.max(1, Number(els.autoBreakMin?.value || lp.autoBreakMin || 10)));
        lp.autoIdleMin  = Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || lp.autoIdleMin || 15)));
        if(lp.autoIdleMin < lp.autoBreakMin) lp.autoIdleMin = Math.min(180, lp.autoBreakMin + 5);
        saveLocalProfile(lp);
      }catch(e){}

      // 입장 전(아직 uid 없음)이면 로컬만 저장하고 끝
      if(!state.uid || !state.roomId){
        showToast("저장! (이 브라우저에 기억해둘게)");
        hideModal(els.profileModal);
        return;
      }

      const ref = meRef(state.roomId, state.uid);
      await updateDoc(ref, { theme, bubbleText, name: (state.nickname || undefined), autoBreakMin, autoIdleMin: Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || 15))), updatedAt: Date.now(), lastSeenAtMs: Date.now() });
      showToast("저장!");
      hideModal(els.profileModal);
    }

    // Photo upload (Storage)
    async function uploadPhoto(){
      const f = els.photoFile.files?.[0];
      if(!f){ showToast("파일 선택!"); return; }
      if(f.size > 2 * 1024 * 1024){ showToast("2MB 이하 추천!"); return; }
      if(!/^image\//.test(f.type) && !/\.gif$/i.test(f.name)){ showToast("이미지 파일만!"); return; }

      const path = `rooms/${state.roomId}/avatars/${state.uid}/profile`; // overwrite-friendly
      const ref = sRef(storage, path);

      try{
        await uploadBytes(ref, f, { contentType: f.type || "image/gif" });
        const url = await getDownloadURL(ref);
        state.myPhotoUrl = url;
        // ✅ 업로드 시 로컬 설정에도 즉시 저장(재입장 시 유지)
        try{ const lp = loadLocalProfile() || {}; lp.theme = lp.theme || {}; lp.theme.photoUrl = url; saveLocalProfile(lp); }catch(e){}
        await updateDoc(meRef(state.roomId, state.uid), {
          "theme.photoUrl": url,
          updatedAt: Date.now(),
          lastSeenAtMs: Date.now()
        });
        showToast("업로드 완료!");
      }catch(e){
        console.error(e);
        showToast("업로드 실패(스토리지 규칙/설정 확인)");
      }
    }

    // Room subscribe (dashboard links)
    function coerceCount(v){
  if(v==null) return null;
  if(typeof v==="number" && isFinite(v)) return v;
  if(typeof v==="string"){
    const s=v.trim().replace(/,/g,"");
    if(s==="" ) return null;
    const n=Number(s);
    if(!Number.isNaN(n) && isFinite(n)) return n;
    return v; // fallback keep string
  }
  if(Array.isArray(v)) return v.length;
  if(typeof v==="object"){
    // common keys
    const keys = ["count","online","onlineCount","users","userCount","members","memberCount","value","total","n","num","size","length"];
    for(const k of keys){
      if(v[k]!=null){
        const r=coerceCount(v[k]);
        if(r!=null) return r;
      }
    }
    // first numeric-looking property
    for(const [k,val] of Object.entries(v)){
      const r=coerceCount(val);
      if(typeof r==="number") return r;
    }
    return null;
  }
  return null;
}

    function renderDashboard(){
      const d = state.roomSettings.dashboard || {};
      const cRemote = state.roomSettings.dashCounts || {};
      const cLocal = state.localDashCounts || {};
      const c = (cLocal && (cLocal.pomoCount!=null || cLocal.sudaCount!=null)) ? cLocal : cRemote;

      const pomoVal = coerceCount(c.pomoCount);
      const sudaVal = coerceCount(c.sudaCount);
      els.pomoCount.textContent = (pomoVal!=null ? pomoVal : "—");
      els.sudaCount.textContent = (sudaVal!=null ? sudaVal : "—");
      // raw 값이 객체면 툴팁으로 확인 가능하게
      els.pomoCount.title = (typeof c.pomoCount==="object" ? JSON.stringify(c.pomoCount) : "");
      els.sudaCount.title = (typeof c.sudaCount==="object" ? JSON.stringify(c.sudaCount) : "");
      const updated = c.updatedAtMs ? new Date(c.updatedAtMs).toLocaleString("ko-KR") : "-";
      els.dashUpdated.textContent = updated;

      // 링크는 새 탭으로만 (앱스크립트/보안정책 때문에 내부 임베드 제거)
      els.goPomo.onclick = ()=>openUrl(d.pomoUrl);
      if(els.goPomoMini){ els.goPomoMini.disabled = !d.pomoUrl; els.goPomoMini.onclick = ()=>openUrl(d.pomoUrl); }
      els.goSuda.onclick = ()=>openUrl(d.sudaUrl);
      if(els.goSudaMini){ els.goSudaMini.disabled = !d.sudaUrl; els.goSudaMini.onclick = ()=>openUrl(d.sudaUrl); }
      els.goChool.onclick = ()=>openUrl(d.choolUrl);
      els.goSheet.onclick = ()=>openUrl(d.sheetUrl);

      els.pomoUrl.value = d.pomoUrl || "";
      els.sudaUrl.value = d.sudaUrl || "";
      els.choolUrl.value = d.choolUrl || "";
      els.sheetUrl.value = d.sheetUrl || "";
      if(els.dashApiUrl) els.dashApiUrl.value = d.dashApiUrl || "";
    }
    function subscribeRoom(){
      if(state.unsubRoom) state.unsubRoom();
      state.unsubRoom = safeOnSnapshot(roomRef(state.roomId), (snap)=>{
        if(!snap.exists()) return;
        const r = snap.data();
        const _dash = Object.assign({pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL}, (r.dashboard || {}));
      if(!_dash.dashApiUrl || !_dash.dashApiUrl.trim()) _dash.dashApiUrl = DEFAULT_DASH_API_URL;
      state.roomSettings.dashboard = _dash;
        ensureDashPolling();
        state.roomSettings.dashCounts = r.dashCounts || {pomoCount:null, sudaCount:null, updatedAtMs:null};
        state.roomSettings.adminHash = r.adminHash || null;
        state.adminHash = state.roomSettings.adminHash;
        renderDashboard();
      });
    }

    // Admin settings
    async function unlockAdmin(){
      const pass = (els.adminPass.value || "").trim();
      if(!pass){ showToast("관리자 비번 입력"); return; }
      const hash = await sha256Hex(pass);

      if(!state.adminHash){
        await updateDoc(roomRef(state.roomId), { adminHash: hash });
        state.adminHash = hash;
        state.adminOk = true;
        els.adminArea.style.display = "block";
        showToast("비번 등록!");
        return;
      }
      if(hash === state.adminHash){
        state.adminOk = true;
        els.adminArea.style.display = "block";
        showToast("확인 완료!");
      }else{
        state.adminOk = false;
        els.adminArea.style.display = "none";
        showToast("비번이 달라…");
      }
    }
    async function saveDashboard(){
      if(!state.adminOk){ showToast("관리자 확인부터!"); return; }
      const dashboard = {
        pomoUrl: (els.pomoUrl.value || "").trim(),
        sudaUrl: (els.sudaUrl.value || "").trim(),
        choolUrl: (els.choolUrl.value || "").trim(),
        sheetUrl: (els.sheetUrl.value || "").trim(),
        dashApiUrl: (els.dashApiUrl && els.dashApiUrl.value ? els.dashApiUrl.value : "").trim(),
      };
      await updateDoc(roomRef(state.roomId), { dashboard });
      showToast("저장!");
    }

    // Chat
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function subscribeChat(){
      if(state.unsubChat) state.unsubChat();
      const q = query(chatCol(state.roomId), orderBy("tsMs", "desc"), limit(120));
      state.unsubChat = safeOnSnapshot(q, (qs)=>{
        const items = [];
        qs.forEach(d=>items.push(d.data()));
        items.reverse();

        // ✅ 스크롤 점프 방지: 사용자가 거의 바닥에 있을 때만 자동 스크롤
        const nearBottom = (()=>{
          try{
            const el = els.chatList;
            const threshold = 24;
            return (el.scrollTop + el.clientHeight >= el.scrollHeight - threshold);
          }catch(e){ return true; }
        })();

        els.chatList.innerHTML = "";
        for(const m of items){
          const div = document.createElement("div");
          const isMe = (m.uid && state.uid && m.uid === state.uid);
          div.className = "msg " + (isMe ? "me" : "other");
          const p = (m.uid && state.currentParticipants) ? state.currentParticipants.get(m.uid) : null;
          const emoji = (p && p.theme && p.theme.emoji) ? String(p.theme.emoji) : "💬";
          const nick = (m.name || (p && p.name) || "익명");
          div.innerHTML = `
            <div class="meta"><span><span class="chatEmoji">${escapeHtml(emoji)}</span><span class="chatName">${escapeHtml(nick)}</span></span></div>
            <div class="text">${escapeHtml(m.text || "")}</div>
          `;
          els.chatList.appendChild(div);
        }
        if(nearBottom){ els.chatList.scrollTop = els.chatList.scrollHeight; }
      });
    }
    async function sendChat(){
      try{
        const text = (els.chatInput.value || "").trim();
        if(!text) return;
        els.chatInput.value = "";
        const meSnap = await getDoc(meRef(state.roomId, state.uid));
        const me = meSnap.exists() ? meSnap.data() : { name: els.name.value.trim() };
        await addDoc(chatCol(state.roomId), {
          uid: state.uid,
          name: me.name || els.name.value.trim(),
          text: text.slice(0, 500),
          tsMs: Date.now()
        });
        // ✅ 내 전송 직후 바닥으로 이동(점프 최소화)
        try{ els.chatList.scrollTop = els.chatList.scrollHeight; }catch(e){}
      }catch(err){
        console.error("sendChat error", err);
        showToast("채팅 전송 실패… Firebase 규칙/네트워크를 확인해줘");
      }
    }

    // Tiles
    function statusBadge(p){
      const online = isOnline(p.lastSeenAtMs);
      if(!online) return { text: "offline", cls: "bOff", emoji:"🫥" };
      if(p.status === "work")  return { text:"REC", cls:"bWork recBadge", emoji:"" };
      if(p.status === "break") return { text:"휴식중", cls:"bBreak", emoji:"☕" };
      return { text:"자리비움", cls:"bIdle", emoji:"🌙" };
    }
    function tileKey(p){
      return JSON.stringify({
        name:p.name, status:p.status, total:p.totalSecondsToday, started:p.sessionStartedAtMs,
        bubble:p.bubbleText, emo:p.theme?.emoji, emoBg:p.theme?.emojiBg, emoSize:p.theme?.emojiSize, photoSize:p.theme?.photoSize, bg:p.theme?.bgColor, bubbleColor:p.theme?.bubbleColor, patColor:p.theme?.patternColor, photo:p.theme?.photoUrl,
        online:isOnline(p.lastSeenAtMs)
      });
    }
    function renderTile(p){
      const key = tileKey(p);
      const prev = state.lastRendered.get(p.id);
      if(prev && prev.key === key && prev.el) return prev.el;

      const t = document.createElement("div");
      t.className = "tile";
      // 우클릭 메뉴(강퇴)
      t.addEventListener("contextmenu", (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        openCtxMenu(ev.clientX, ev.clientY, p);
      });

      const bg = document.createElement("div");
      bg.className = "bg";
      bg.style.background = bgStyle(p.theme?.bgColor || "#ffd0e2", p.theme?.pattern || "none", p.theme?.patternColor || "#ffffff");
      // pattern sizing tweaks
      if((p.theme?.pattern||"") === "dots"){ bg.style.backgroundSize = "22px 22px, 22px 22px, auto"; }
      if((p.theme?.pattern||"") === "grid"){ bg.style.backgroundSize = "18px 18px, 18px 18px, auto"; }
      if((p.theme?.pattern||"") === "stripes"){ bg.style.backgroundSize = "auto, auto"; }
      if((p.theme?.pattern||"") === "hearts"){ bg.style.backgroundRepeat = "repeat, no-repeat"; bg.style.backgroundSize = "36px 36px, auto"; }

      const shade = document.createElement("div");
      shade.className = "shade";

      const content = document.createElement("div");
      content.className = "content";

      const statusBar = document.createElement("div");
      statusBar.className = "statusBar";

      const statusLeft = document.createElement("div");
      statusLeft.className = "statusLeft";

      const statusRight = document.createElement("div");
      statusRight.className = "statusRight";

      const badge = statusBadge(p);
      const b = document.createElement("div");
      b.className = `badge ${badge.cls}`;
      const isRec = (badge.text==="REC");
      const iconCls = (badge.text==="REC") ? "" : (badge.text==="휴식중") ? "stBreak" : (badge.text==="자리비움") ? "stIdle" : "";
      b.innerHTML = isRec ? `<span class="recDot"></span><span style="font-weight:1100;">🔴REC</span>` : `<span class="stIcon ${iconCls}">${badge.emoji}</span><span>${badge.text}</span>`;

      const namePill = document.createElement("div");
      namePill.className = "namePill";
      namePill.textContent = p.name || p.id;
      const nameAccent = clampHexColor(p.theme?.bubbleColor || p.theme?.bgColor || "#ffd0e2");
      namePill.style.background = hexToRgba(nameAccent, 0.22);
      namePill.style.borderColor = hexToRgba(nameAccent,0.55);

      statusLeft.appendChild(b);
      statusLeft.appendChild(namePill);

      // 오른쪽 영역(추후 배지/아이콘 확장용)
      statusRight.appendChild(document.createElement("div"));

      statusBar.appendChild(statusLeft);
      statusBar.appendChild(statusRight);// tile sizes (emoji/photo)
const emoSize = 82;
const photoSize = 82;
t.style.setProperty("--emoSize", emoSize + "px");
t.style.setProperty("--photoSize", photoSize + "px");

const avatar = document.createElement("div");
avatar.className = "avatar";
avatar.textContent = (p.theme?.emoji || "✍️");

const emoBg = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
t.style.setProperty("--emoBg", emoBg);
avatar.style.background = emoBg;
avatar.style.borderColor = hexToRgba(emoBg, 0.95);

const idPhoto = document.createElement("div");
idPhoto.className = "idPhoto";
const photoUrl = (p.theme?.photoUrl || "").trim();
if(photoUrl){
  const img = document.createElement("img");
  img.src = photoUrl;
  img.loading = "lazy";
  img.onerror = ()=>{ idPhoto.textContent = "사진"; };
  idPhoto.appendChild(img);
}else{
  idPhoto.textContent = "사진";
}

const timer = document.createElement("div");
timer.className = "bigTimer";
      const isMeTile = (p && p.id && state.uid) ? (p.id === state.uid) : false;
timer.innerHTML = `<span class="time">--:--:--</span>` + (isMeTile ? `<button class="missionBtn isHot" type="button" title="오늘의 미션" aria-label="오늘의 미션"></button>` : `<span class="missionSpacer"></span>`);

const bubble = document.createElement("div");
bubble.className = "bubble";
const bubbleAccent = clampHexColor(p.theme?.bubbleColor || p.theme?.bgColor || "#ffd0e2");
bubble.style.background = hexToRgba(bubbleAccent, 0.22);
bubble.style.borderColor = hexToRgba(bubbleAccent, 0.55);
const bubbleText = (p.bubbleText || "").trim();
if(bubbleText){
  bubble.textContent = bubbleText;
}else{
  bubble.textContent = "…";
  bubble.classList.add("muted");
}

const bottomStack = document.createElement("div");
bottomStack.className = "bottomStack";

const mediaRow = document.createElement("div");
mediaRow.className = "mediaRow";
mediaRow.appendChild(avatar);
mediaRow.appendChild(idPhoto);

bottomStack.appendChild(bubble);
bottomStack.appendChild(mediaRow);

content.appendChild(statusBar);
content.appendChild(timer);
content.appendChild(bottomStack);
t.appendChild(bg);
      t.appendChild(shade);
      t.appendChild(content);

      state.lastRendered.set(p.id, { key, el: t });
      return t;
    }
    function updateTimersLive(){
      for(const [uid, rec] of state.lastRendered.entries()){
        const p = state.currentParticipants.get(uid);
        if(!p || !rec.el) continue;
        const timeEl = rec.el.querySelector(".time");
        if(!timeEl) continue;
        timeEl.textContent = fmtHMS(computeDisplayedTotal(p));
        // time color: work = user color, break/idle = fixed grey
        const tc = clampHexColor(p.theme?.timeColor || "#ffffff");
        timeEl.style.color = (p.status==="work") ? tc : "#9aa0a6";
      }
    }


    // Compact mode: on very small windows, replace tiles with a fast roster list (요청 7)
    const COMPACT_W = 560; // px

    // ✅ 뷰포트 폭을 더 안정적으로 계산(초기 로딩 시 innerWidth=0 케이스 방어)
    function getViewportW(){
      try{
        const w1 = (window.innerWidth || 0);
        const w2 = (document.documentElement && document.documentElement.clientWidth) ? document.documentElement.clientWidth : 0;
        return Math.max(w1, w2);
      }catch(e){
        return (window.innerWidth || 0);
      }
    }

    function isCompactNow(){
      const w = getViewportW();
      if(!w) return false; // 0이면 compact로 오판하지 않기
      return w <= COMPACT_W;
    }

    function applyCompactMode(force){
      const compact = (typeof force === "boolean") ? force : isCompactNow();
      document.body.classList.toggle("compact", compact);
      return compact;
    }

    function renderStatusRoster(onlineArr){
      if(!els.statusRosterList) return;
      els.statusRosterList.innerHTML = "";
      for(const p of onlineArr){
        const item = document.createElement("div");
        item.className = "statusRosterItem";

        const left = document.createElement("div");
        left.className = "statusRosterLeft";

        const emo = document.createElement("div");
        emo.className = "statusRosterEmoji";
        emo.textContent = (p.theme?.emoji || "🙂");
        const eb = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
        emo.style.background = eb;
        emo.style.borderColor = hexToRgba("#ffffff", 0.16);

        const nm = document.createElement("div");
        nm.className = "statusRosterName";
        nm.textContent = p.name || p.id;

        left.appendChild(emo);
        left.appendChild(nm);

        const st = document.createElement("div");
        st.className = "statusRosterStatus";
        const bd = statusBadge(p);
        st.textContent = `${bd.emoji} ${bd.text}`;

        item.appendChild(left);
        item.appendChild(st);
        els.statusRosterList.appendChild(item);
      }
    }

    function renderCompactRoster(onlineArr){
      if(!els.grid) return;
      els.grid.innerHTML = "";

      const wrap = document.createElement("div");
      wrap.className = "gridRosterWrap";

      const title = document.createElement("div");
      title.className = "gridRosterTitle";
      title.textContent = `👥 접속자 목록 (${onlineArr.length})`;

      const list = document.createElement("div");
      list.className = "gridRosterList";

      for(const p of onlineArr){
        const item = document.createElement("div");
        item.className = "gridRosterItem";

        const left = document.createElement("div");
        left.className = "gridRosterLeft";

        const emoji = document.createElement("div");
        emoji.className = "gridRosterEmoji";
        emoji.textContent = (p.theme?.emoji || "✍️");
        const emoBg = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
        emoji.style.background = hexToRgba(emoBg, 0.18);
        emoji.style.borderColor = hexToRgba(emoBg, 0.40);

        const nm = document.createElement("div");
        nm.className = "gridRosterName";
        nm.textContent = (p.name || "익명");

        left.appendChild(emoji);
        left.appendChild(nm);

        const st = document.createElement("div");
        st.className = "gridRosterStatus";
        const s = (p.status || "idle");
        st.textContent = (s==="work") ? "✍️ 작업중" : (s==="break") ? "☕ 휴식중" : (s==="idle") ? "🌙 자리비움" : "—";

        item.appendChild(left);
        item.appendChild(st);

        // 우클릭(강퇴 메뉴)
        item.addEventListener("contextmenu", (ev)=>{
          ev.preventDefault();
          ev.stopPropagation();
          openCtxMenu(ev.clientX, ev.clientY, p);
        });

        list.appendChild(item);
      }

      wrap.appendChild(title);
      wrap.appendChild(list);
      els.grid.appendChild(wrap);
    }

    function renderGridTilesOrRoster(onlineArr){
      if(!els.grid) return;
      const compact = applyCompactMode();
      if(compact){
        // ✅ compact에서는 메인(타일/접속자 목록) 렌더로 레이아웃이 무너지는 걸 방지하고,
        //    채팅(사이드바)만 남기는 모드로 전환합니다.
        els.grid.innerHTML = "";
        return;
      }

      // normal tiles
      els.grid.innerHTML = "";
      for(const p of onlineArr){
        try{
          const t = renderTile(p);
          if(t) els.grid.appendChild(t);
        }catch(err){
          console.warn("[tile] renderTile failed, fallback tile used:", err);
          // ✅ 렌더 실패해도 전체가 비지 않도록 안전 타일
          const fallback = document.createElement("div");
          fallback.className = "tile";
          const bg = document.createElement("div");
          bg.className = "bg";
          bg.style.background = "linear-gradient(135deg, rgba(255,182,214,.35), rgba(255,119,184,.25))";
          const inner = document.createElement("div");
          inner.className = "inner";
          const top = document.createElement("div");
          top.className = "top";
          const status = document.createElement("div");
          status.className = "status";
          status.textContent = "⚠️";
          const name = document.createElement("div");
          name.className = "name";
          name.textContent = (p?.name || p?.id || "unknown");
          top.appendChild(status);
          top.appendChild(name);
          inner.appendChild(top);
          fallback.appendChild(bg);
          fallback.appendChild(inner);
          els.grid.appendChild(fallback);
        }
      }
    }

    // Join / Leave
    async function subscribeParticipants(){
      if(state.unsubParticipants) state.unsubParticipants();
      state.unsubParticipants = safeOnSnapshot(participantsCol(state.roomId), (qs)=>{
        const arr = [];
        const map = new Map();
        qs.forEach(d=>{
          const data = d.data();
          const p = { id:d.id, ...data };
          arr.push(p);
          map.set(p.id, p);
        });
        state.currentParticipants = map;
        syncMyStatusUI();

        // ✅ 오프라인은 "접속 종료"처럼 처리: 리스트/타일에서 제외
        const onlineArr = arr.filter(p=>isOnline(p.lastSeenAtMs));
        const dk = seoulDateKey();
        const successCount = arr.filter(p=>{
          const m = p.mission;
          return !!m && (m.dayKey===dk) && !!m.done;
        }).length;
        try{
          const el = document.getElementById("missionSuccessCount");
          if(el) el.textContent = String(successCount);
        }catch(e){}

        onlineArr.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));

        els.countOnline.textContent = String(onlineArr.length);
        els.lastSync.textContent = new Date().toLocaleTimeString("ko-KR");

        renderStatusRoster(onlineArr);
        renderGridTilesOrRoster(onlineArr);
        try{ setMissionButtonState(); }catch(e){}

      });
    }


    // Join / Leave
    
async function joinRoom(){
      try{
        const name = els.name.value.trim();
        state.nickname = name;
        setMyNickUI(name);
        try{ const lp = loadLocalProfile() || {}; lp.nickname = name; saveLocalProfile(lp); }catch(e){}
        if(!name){ showToast("닉네임 입력!"); return; }
        if(!requirePassOK()) return;

        const miss = validateFirebaseConfig();
        if(miss.length){
          showToast("Firebase 설정 미완성: " + miss.join(", "), 4500);
          console.error("Firebase config missing/placeholder:", miss, firebaseConfig);
          return;
        }

        state.roomId = FIXED_ROOM_ID;
        await signInAnonymously(auth);
      if(!state.uid){
        await new Promise((resolve)=>{
          const off = onAuthStateChanged(auth, (user)=>{
            if(user){
              state.uid = user.uid;
              off();
              resolve();
            }
          });
        });
      }

      
      // 강퇴 상태(시간 제한)면 입장 막기
      try{
        const ks = await getDoc(kickRef(state.roomId, state.uid));
        if(ks.exists()){
          const k = ks.data() || {};
          const exp = Number(k.expiresAtMs || 0);
          if(exp && exp > Date.now()){
            showToast("🚫 강퇴 상태라 잠시 입장할 수 없어");
            setControlsEnabled(false);
            return;
          }
        }
      }catch(e){}

      setControlsEnabled(true);
      await ensureRoom(state.roomId);
      await ensureMeDoc();

      const meSnap = await getDoc(meRef(state.roomId, state.uid));
      if(meSnap.exists()){
        const me = meSnap.data();
        els.emoji.value = me.theme?.emoji || "✍️";
        els.bgColor.value = me.theme?.bgColor || "#ffd0e2";
        if(els.emojiBgColor) els.emojiBgColor.value = me.theme?.emojiBg || "#2b2b2b";
        if(els.bubbleColor) els.bubbleColor.value = me.theme?.bubbleColor || me.theme?.bgColor || "#ffd0e2";
        if(els.timeColor) els.timeColor.value = me.theme?.timeColor || "#ffffff";
        if(els.timePicker && els.timeColor) els.timePicker.value = els.timeColor.value;
        if(els.emojiSize){ els.emojiSize.value = String(me.theme?.emojiSize || 40); if(els.emojiSizeNum) els.emojiSizeNum.value = els.emojiSize.value; }
        if(els.photoSize){ els.photoSize.value = String(me.theme?.photoSize || 68); if(els.photoSizeNum) els.photoSizeNum.value = els.photoSize.value; }
        if(els.bgPattern) els.bgPattern.value = me.theme?.pattern || "none";
        if(els.patternColor) els.patternColor.value = me.theme?.patternColor || "#ffffff";
        if(els.patternPicker && els.patternColor) els.patternPicker.value = els.patternColor.value;
        els.bubbleText.value = me.bubbleText || "";
        state.myPhotoUrl = me.theme?.photoUrl || "";
      } else {
        // 신규/테마없음: 브라우저 프리셋을 UI에 반영
        try{
          const lp = loadLocalProfile();
          if(lp && lp.theme){
            els.emoji.value = lp.theme.emoji || els.emoji.value;
            els.bgColor.value = lp.theme.bgColor || els.bgColor.value;
            if(els.emojiBgColor) els.emojiBgColor.value = lp.theme.emojiBg || "#2b2b2b";
            if(els.bubbleColor) els.bubbleColor.value = lp.theme.bubbleColor || lp.theme.bgColor || "#ffd0e2";
            if(els.timeColor) els.timeColor.value = lp.theme.timeColor || "#ffffff";
            if(els.timePicker && els.timeColor) els.timePicker.value = els.timeColor.value;
            if(els.emojiSize){ els.emojiSize.value = String(lp.theme.emojiSize || 40); if(els.emojiSizeNum) els.emojiSizeNum.value = els.emojiSize.value; }
            if(els.photoSize){ els.photoSize.value = String(lp.theme.photoSize || 68); if(els.photoSizeNum) els.photoSizeNum.value = els.photoSize.value; }
            if(els.bgPattern) els.bgPattern.value = lp.theme.pattern || (els.bgPattern.value||"none");
            if(els.patternColor) els.patternColor.value = lp.theme.patternColor || "#ffffff";
            if(els.patternPicker && els.patternColor) els.patternPicker.value = els.patternColor.value;
            els.bubbleText.value = lp.bubbleText || (els.bubbleText.value||"");
            state.myPhotoUrl = lp.theme.photoUrl || state.myPhotoUrl;
          }
        }catch(e){}
      }

      // 🔁 브라우저 프리셋도 동기화(다음 접속 편의)
      try{
        const lp = loadLocalProfile() || {};
        lp.theme = { emoji: els.emoji.value, bgColor: els.bgColor.value, pattern: (els.bgPattern?els.bgPattern.value:"none"), patternColor: (els.patternColor?els.patternColor.value:"#ffffff"), photoUrl: state.myPhotoUrl||"", emojiBg: (els.emojiBgColor?els.emojiBgColor.value:"#2b2b2b"), bubbleColor: (els.bubbleColor?els.bubbleColor.value:els.bgColor.value), timeColor: (els.timeColor?els.timeColor.value:"#ffffff"), emojiSize: (els.emojiSize?Number(els.emojiSize.value):40), photoSize: (els.photoSize?Number(els.photoSize.value):68) };
        lp.bubbleText = (els.bubbleText.value||"");
        saveLocalProfile(lp);
      }catch(e){}

      subscribeRoom();
      await subscribeParticipants();
      subscribeChat();
      subscribeKicks();

      await heartbeat();
      if(state.tickTimer) clearInterval(state.tickTimer);
      state.tickTimer = setInterval(()=>{ updateTimersLive(); updateClocks(); }, 1000);
      updateClocks();

      if(state.hbTimer) clearInterval(state.hbTimer);
      state.hbTimer = setInterval(heartbeat, 30_000);

      try{ localStorage.setItem("mk_last_name", name); }catch(e){}
      els.meHint.textContent = name;
      showToast("입장!");
      }catch(e){
        console.error(e);
        const code = e?.code || "";
        const msg = e?.message || "";
        showToast("입장 실패: " + (code || "오류"), 3500);
        if(msg) console.warn("joinRoom error message:", msg);
        // 개발자도구 없이도 바로 감 잡게 짧게 한 번 더
        if(!code && msg) showToast("입장 실패: " + msg.slice(0, 60), 3500);
        const hint = friendlyAuthHint(code);
        if(hint) console.warn(hint);
        // 화면에서도 힌트를 보여주고 싶으면 아래 한 줄 주석 해제
        if(hint) showToast(hint, 4500);
      }
    }

    async function leaveRoom(){
      // ✅ 퇴장 직전 집중시간 로컬 저장
      persistMyFocusToLocal();
      if(!state.roomId || !state.uid) return;

      try{ await transitionTo("idle"); }catch(e){}

      if(state.unsubParticipants) state.unsubParticipants();
      if(state.unsubRoom) state.unsubRoom();
      if(state.unsubChat) state.unsubChat();
      if(state.unsubKick) state.unsubKick();
      state.unsubParticipants = null;
      state.unsubRoom = null;
      state.unsubChat = null;
      state.unsubKick = null;

      try{ await deleteDoc(meRef(state.roomId, state.uid)); }catch(e){}

      els.grid.innerHTML = "";
      els.chatList.innerHTML = "";
      state.currentParticipants = new Map();
      state.lastRendered.clear();

      setControlsEnabled(false);
    updateClocks();

      if(state.tickTimer) clearInterval(state.tickTimer);
      if(state.hbTimer) clearInterval(state.hbTimer);
      state.tickTimer = null;
      state.hbTimer = null;

      els.meHint.textContent = "—";
      showToast("퇴장!");
    }

    // UI bindings
    initPalette();

    // keep dashboard docked
    
window.addEventListener("resize", ()=>{
      try{ ensureChatUI(); }catch(e){}
  dockRightRail();
  // ✅ 창 폭 변화 시: compact 모드/타일↔접속자목록 즉시 갱신
  try{
    const arr = [...state.currentParticipants.values()];
    const onlineArr = arr.filter(p=>isOnline(p.lastSeenAtMs));
    onlineArr.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));
    renderGridTilesOrRoster(onlineArr);
  }catch(e){
    applyCompactMode();
  }
});
window.addEventListener("scroll", dockRightRail, {passive:true});
    setTimeout(dockRightRail, 80);
    // ✅ 초기 로딩 때 compact 오판 방지(레이아웃 확정 후 판단)
    requestAnimationFrame(()=>applyCompactMode());
    setTimeout(()=>applyCompactMode(), 180);

    if(els.onlineBtn){
      els.onlineBtn.addEventListener("click", ()=>{
        const n = (els.countOnline && els.countOnline.textContent) ? els.countOnline.textContent : "0";
        showToast(`👥 지금 ${n}명 접속중`);
      });
    }

    els.joinBtn.addEventListener("click", joinRoom);
    els.leaveBtn.addEventListener("click", leaveRoom);

    els.btnWork.addEventListener("click", ()=>{ transitionTo("work"); els.statusMenu.classList.add("hidden"); });
    els.btnBreak.addEventListener("click", ()=>{ transitionTo("break"); els.statusMenu.classList.add("hidden"); });
    els.btnIdle.addEventListener("click", ()=>{ transitionTo("idle"); els.statusMenu.classList.add("hidden"); });

    // 상태 메뉴 토글
    els.statusBtn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      els.statusMenu.classList.toggle("hidden");
    });
    // 메뉴 바깥 클릭하면 닫기
    document.addEventListener("click", ()=>{
      if(!els.statusMenu.classList.contains("hidden")) els.statusMenu.classList.add("hidden");
    });
    // 메뉴 클릭은 버블링 막기
    els.statusMenu.addEventListener("click", (ev)=>ev.stopPropagation());
    els.profileBtn.addEventListener("click", ()=>{
      // ✅ 모달 열 때 현재 저장된 값들을 다시 채워넣기
      try{
        const lp = loadLocalProfile() || {};
        const theme = lp.theme || {};
        if(els.profileNick){
          const nn = (lp.nickname || state.nickname || "").toString().trim().slice(0,20);
          if(nn) els.profileNick.value = nn;
        }
        if(els.emoji) els.emoji.value = (typeof firstEmojiGrapheme==="function" ? firstEmojiGrapheme : (s=> (Array.from(((s||"").toString().trim()))[0]||"")))((theme.emoji || els.emoji.value || "✍️").toString().trim()) || "✍️";
        if(els.emojiSize){ els.emojiSize.value = "82"; els.emojiSize.disabled = true; }
        if(els.emojiSizeNum){ els.emojiSizeNum.value = "82"; }

        if(els.photoSize){ els.photoSize.value = "82"; els.photoSize.disabled = true; }
        if(els.photoSizeNum){ els.photoSizeNum.value = "82"; }


        if(els.emojiBgColor) els.emojiBgColor.value = clampHexColor(theme.emojiBg || els.emojiBgColor.value || "#2b2b2b");
        if(els.emojiBgPicker) els.emojiBgPicker.value = els.emojiBgColor.value;

        if(els.bgColor) els.bgColor.value = clampHexColor(theme.bgColor || els.bgColor.value || "#ffd0e2");
        if(els.bgPicker) els.bgPicker.value = els.bgColor.value;

        if(els.bgPattern) els.bgPattern.value = (theme.pattern || els.bgPattern.value || "none");
        if(els.patternColor) els.patternColor.value = clampHexColor(theme.patternColor || els.patternColor.value || "#ffffff");
        if(els.patternPicker) els.patternPicker.value = els.patternColor.value;

        if(els.bubbleText) els.bubbleText.value = (lp.bubbleText || "").toString().slice(0,140);
        if(els.bubbleColor) els.bubbleColor.value = clampHexColor(theme.bubbleColor || els.bubbleColor.value || "#ffd0e2");
        if(els.bubblePicker) els.bubblePicker.value = els.bubbleColor.value;

        if(els.timeColor) els.timeColor.value = clampHexColor(theme.timeColor || els.timeColor.value || "#ffffff");
        if(els.timePicker) els.timePicker.value = els.timeColor.value;

        // ✅ 자동전환(분)
        const ab = Number(lp.autoBreakMin ?? 10);
        const ai = Number(lp.autoIdleMin ?? 15);
        if(els.autoBreakMin) els.autoBreakMin.value = String(Math.min(180, Math.max(1, isFinite(ab)?ab:10)));
        if(els.autoIdleMin) els.autoIdleMin.value = String(Math.min(180, Math.max(1, isFinite(ai)?ai:15)));
      }catch(e){}
      showModal(els.profileModal);
    });
    els.closeProfile.addEventListener("click", ()=>hideModal(els.profileModal));
    els.applyProfile.addEventListener("click", applyProfile);

    // ✅ 오늘의 미션 모달 바인딩
    try{
      const mm = document.getElementById("missionModal");
      const close = document.getElementById("closeMission");
      const save = document.getElementById("saveMission");
      if(close) close.addEventListener("click", closeMissionModal);
      if(mm) mm.addEventListener("click", (e)=>{ if(e.target===mm) closeMissionModal(); });

      // 버튼 클릭(이벤트 위임) - 타일이 리렌더되어도 안 죽게
      document.addEventListener("click", (e)=>{
        const btn = e.target && e.target.closest ? e.target.closest(".missionBtn") : null;
        if(btn){
          e.preventDefault();
          openMissionModal();
        }
      });

      if(save) save.addEventListener("click", async ()=>{
        try{
          const text = (document.getElementById("missionText")?.value || "").trim();
          const done = !!document.getElementById("missionDone")?.checked;
          const dayKey = seoulDateKey();
          const prev = state.myMission || loadMissionLocal();
          const becameDone = (!prev.done && done);

          const m = { dayKey, text, done, doneAt: done ? (prev.doneAt || new Date().toISOString()) : "" };
          state.myMission = m;
          saveMissionLocal(m);
          setMissionButtonState();
          closeMissionModal();

          // 성공 폭죽
          if(becameDone){
            const btn = document.querySelector(".missionBtn");
            if(btn) fxFireworksAt(btn);
          }

          // Firestore에 내 미션 저장(가능할 때만)
          try{
            if(state.roomId && state.uid){
              const ref = meRef(state.roomId, state.uid);
              await updateDoc(ref, { mission: m, lastSeenAtMs: Date.now() });
            }
          }catch(e){}
        }catch(e){}
      });
    }catch(e){}

    // ✅ 대시보드 접기/펼치기
    try{
      const foldBtn = document.getElementById("dashFoldBtn");
      const btnIcon = document.getElementById("dashFoldIcon");
      const btnTxt  = document.querySelector("#dashFoldBtn .dashFoldTxt");
      const body = document.getElementById("dashFoldBody");
      function applyFoldUI(){
        const folded = loadDashFold();
        const card = document.getElementById("dashboardCard");
        if(card) card.classList.toggle("folded", folded);
        if(body) body.classList.toggle("isHidden", folded);
        if(btnIcon) btnIcon.textContent = folded ? "▾" : "▴";
        if(btnTxt) btnTxt.textContent = folded ? "펼치기" : "접기";
      }
      applyFoldUI();
      if(foldBtn) foldBtn.addEventListener("click", ()=>{
        const next = !loadDashFold();
        saveDashFold(next);
        applyFoldUI();

        // ✅ 접기/펼치기 둘 다: 도킹 레이아웃 재계산 (겹침/잔상 방지)
        try{ if(typeof dockRightRail==="function") dockRightRail(); }catch(e){}
        setTimeout(()=>{ try{ if(typeof dockRightRail==="function") dockRightRail(); }catch(e){}; try{ ensureChatUI(); }catch(e){} }, 50);
      });
    }catch(e){}


    // ✅ 크기 조절 바는 고정(82px)이라 모달에서 숨김
    function hideRowByControl(el){
      try{
        if(!el) return;
        const row = el.closest ? el.closest(".row") : null;
        if(row) row.style.display = "none";
      }catch(e){}
    }
    hideRowByControl(els.emojiSize);
    hideRowByControl(els.photoSize);
    hideRowByControl(els.emojiSizeNum);
    hideRowByControl(els.photoSizeNum);


    // ✅ 이모지 1개만 허용
    if(els.emoji){
      els.emoji.addEventListener("input", ()=>{
        const v = (typeof firstEmojiGrapheme==="function" ? firstEmojiGrapheme : (s=> (Array.from(((s||"").toString().trim()))[0]||"")))(els.emoji.value);
        if(v && els.emoji.value !== v) els.emoji.value = v;
      });
      els.emoji.addEventListener("blur", ()=>{
        const v = (typeof firstEmojiGrapheme==="function" ? firstEmojiGrapheme : (s=> (Array.from(((s||"").toString().trim()))[0]||"")))(els.emoji.value);
        els.emoji.value = v || "✍️";
      });
    }

    if(els.uploadPhotoBtn) els.uploadPhotoBtn.addEventListener("click", uploadPhoto);

    els.menuBtn.addEventListener("click", ()=>{
      els.adminPass.value = "";
      els.adminArea.style.display = "none";
      state.adminOk = false;
      showModal(els.settingsModal);
    });
    els.closeSettings.addEventListener("click", ()=>hideModal(els.settingsModal));
    els.adminUnlock.addEventListener("click", unlockAdmin);
    if(els.adminPass){
      els.adminPass.addEventListener("keydown",(e)=>{
        if(e.key==="Enter"){ e.preventDefault(); unlockAdmin(); }
      });
    }

    // 모달에서 Enter → 첫 번째 primary 버튼
    document.addEventListener("keydown",(e)=>{
      if(e.key!=="Enter") return;
      const openModal = [els.profileModal, els.settingsModal].find(m=>m && m.style.display==="flex");
      if(!openModal) return;
      const ae = document.activeElement;
      if(ae && (ae.tagName==="TEXTAREA")) return;
      // 이미 특정 input에서 Enter 처리하는 경우는 건드리지 않기
      if(ae && ae.id==="adminPass") return;
      const btn = openModal.querySelector("button.primary");
      if(btn){ e.preventDefault(); btn.click(); }
    });
    els.saveDash.addEventListener("click", saveDashboard);

    els.sendBtn.addEventListener("click", sendChat);

    // --- 컨텍스트 메뉴(프로필 우클릭) 닫기/동작 ---
    if(els.ctxClose){
      els.ctxClose.addEventListener("click", (e)=>{
        e.preventDefault();
        hideCtxMenu();
      });
    }
    if(els.ctxKick){
      els.ctxKick.addEventListener("click", async (e)=>{
        e.preventDefault();
        const t = state.ctxTarget || {};
        hideCtxMenu();
        if(t.uid) await requestKick(t.uid, t.name);
      });
    }
    // 메뉴 안에서 클릭은 바깥 클릭 닫기 트리거를 막기
    if(els.ctxMenu){
      els.ctxMenu.addEventListener("click", (e)=>e.stopPropagation());
      els.ctxMenu.addEventListener("contextmenu", (e)=>e.preventDefault());
    }
    // 바깥 클릭/우클릭/ESC 로 닫기
    document.addEventListener("click", (e)=>{
      if(!els.ctxMenu || els.ctxMenu.classList.contains("hidden")) return;
      if(!els.ctxMenu.contains(e.target)) hideCtxMenu();
    }, true);
    document.addEventListener("contextmenu", (e)=>{
      if(!els.ctxMenu || els.ctxMenu.classList.contains("hidden")) return;
      if(!els.ctxMenu.contains(e.target)) hideCtxMenu();
    }, true);
    document.addEventListener("keydown", (e)=>{
      if(e.key==="Escape") hideCtxMenu();
    });


    // embed controls (현재는 내부 임베드 사용 안 함. 요소가 없을 수도 있어 가드)
    if(els.embedClose) els.embedClose.addEventListener("click", closeInlineEmbed);
    if(els.embedOpen)  els.embedOpen.addEventListener("click", ()=>{ /* set on openInlineEmbed */ });
    if(els.closeEmbedModal) els.closeEmbedModal.addEventListener("click", closeEmbedModal);
    if(els.embedModal) els.embedModal.addEventListener("click", (e)=>{ if(e.target===els.embedModal) closeEmbedModal(); });
    // ✅ IME(한글 등) 조합 입력에서 Enter가 2번 처리되며 '마지막 글자만 따로 전송'되는 현상 방지
    let __chatIsComposing = false;
    let __chatSendAfterCompose = false;

    els.chatInput.addEventListener("compositionstart", ()=>{
      __chatIsComposing = true;
      __chatSendAfterCompose = false;
    });
    els.chatInput.addEventListener("compositionend", ()=>{
      __chatIsComposing = false;
      if(__chatSendAfterCompose){
        __chatSendAfterCompose = false;
        // 조합 확정 후 다음 틱에 전송 (한 번만)
        setTimeout(()=>sendChat(), 0);
      }
    });

    els.chatInput.addEventListener("keydown", (e)=>{
      if(e.key !== "Enter") return;

      // 조합 중 Enter: 조합 확정만 하고(기본 동작), 전송은 compositionend에서 한 번만 처리
      if(e.isComposing || __chatIsComposing || e.keyCode === 229){
        __chatSendAfterCompose = true;
        return;
      }

      e.preventDefault();
      sendChat();
    });

    els.profileModal.addEventListener("click", (e)=>{ if(e.target === els.profileModal) hideModal(els.profileModal); });
    els.settingsModal.addEventListener("click", (e)=>{ if(e.target === els.settingsModal) hideModal(els.settingsModal); });

    
    // ✅ 입장키(24h) 기억
    loadPassOK();
    if(els.roomPass){
      els.roomPass.addEventListener("input", ()=>{
        if(!(els.roomPass.value||"").trim()) clearPass();
      });
    }

    // ✅ 프로필 설정(브라우저) 프리셋 불러오기
    try{
      const lp = loadLocalProfile();
      if(lp){
        if(els.emoji) els.emoji.value = lp.theme?.emoji || els.emoji.value;
        if(els.bgColor) els.bgColor.value = lp.theme?.bgColor || els.bgColor.value;
        if(els.bgPattern && lp.theme?.pattern) els.bgPattern.value = lp.theme.pattern;
        if(els.bubbleText) els.bubbleText.value = lp.bubbleText || "";
        if(lp.theme?.photoUrl) state.myPhotoUrl = lp.theme.photoUrl;
      }
    }catch(e){}


    // 닉네임 기억 (입퇴장 편의)
    try{
      const lp = loadLocalProfile() || {};
      const fromProfile = (lp.nickname || "").toString().trim().slice(0,20);
      const saved = localStorage.getItem("mk_last_name") || "";
      if(els.name){
        if(fromProfile) els.name.value = fromProfile;
        else if(saved) els.name.value = saved;
      }
    }catch(e){}
    if(els.name){
      els.name.addEventListener("input", ()=>{
        try{ localStorage.setItem("mk_last_name", els.name.value.trim()); }catch(e){}
      });
      els.name.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          if(!els.joinBtn.disabled) joinRoom();
        }
      });
    }

    if(els.roomPass){
      els.roomPass.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          if(!els.joinBtn.disabled) joinRoom();
        }
      });
    }

    setControlsEnabled(false);
    updateClocks();

    window.addEventListener("beforeunload", ()=>{
      if(state.roomId && state.uid){
        try{ updateDoc(meRef(state.roomId, state.uid), { lastSeenAtMs: Date.now(), updatedAt: Date.now() }); }catch(e){}
      }
    });
  
  // READY FLAG (bindings complete)
  window.__MK_READY__ = true;
})();
</script>
  <script>
    // Fallback: if ES module didn't execute (common when opening via file://), show a clear hint
    (function(){
      function show(msg){
        try{
          var t = document.getElementById('toast');
          if(t){ t.textContent = msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 4500); }
          else { alert(msg); }
        }catch(e){ alert(msg); }
      }
      window.addEventListener('load', function(){
        setTimeout(function(){
                    if(window.__MK_BOOT_OK__ && !window.__MK_READY__){
            show("⚠️ 스크립트는 로드됐는데 초기화가 중간에 멈췄어(에러 가능). 개발자도구(F12)→Console 에러를 캡처해서 보내주면 바로 잡아줄게!\n(또는 배포 파일 교체 후 Ctrl+F5)");
            var jb2 = document.getElementById('joinBtn');
            if(jb2){ jb2.addEventListener('click', function(){ show("⚠️ 초기화 에러로 입장이 막혔어. F12→Console 에러 캡처를 보내줘!"); }); }
            return;
          }
if(!window.__MK_BOOT_OK__){
            show("⚠️ 지금 파일이 '로컬 파일(file://)'로 열려서 스크립트가 막힌 것 같아! Netlify/GitHub 같은 웹주소(https://)로 열거나, 로컬 서버로 열어줘. (예: 폴더에서 터미널 → python -m http.server)");
            var jb = document.getElementById('joinBtn');
            if(jb){
              jb.addEventListener('click', function(){
                show("⚠️ 로컬 파일(file://)로 열면 입장이 안 돼. Netlify/GitHub 배포 주소(https://)로 열어줘!");
              });
            }
          }
        }, 400);
      });
    })();
  </script>

</body>
</html>