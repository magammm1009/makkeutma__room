<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <link rel="preconnect" href="https://script.google.com">
  <link rel="dns-prefetch" href="https://script.google.com">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MagamMagam</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%92%97%3C/text%3E%3C/svg%3E">
  <style>
    :root{
      --panel:rgba(255,255,255,.06);
      --line:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --pink2:#ffb6d6;
      --pink3:#ff77b8;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:16px;
      --tileMin:170px;
      --tileMax:230px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
      color:var(--text);
      background:#000;
      min-height:100vh;
    }

    /* Topbar */
    .topbar{
      position:sticky; top:0; z-index: 10060;
      display:grid; align-items:center; justify-content:stretch;
      grid-template-columns: minmax(160px, 1fr) auto minmax(320px, 1fr);
      gap:12px;
      padding:12px 14px;
      background: rgba(11,11,16,.84);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .brand{
      display:flex; align-items:center; justify-content:flex-start; text-align:left; gap:10px;
      font-weight:1000; letter-spacing:-.5px;
      min-width:0;
      font-size:18px;
      white-space:nowrap;
    }
    .brand .dot{width:12px;height:12px;border-radius:999px;background:rgba(255,255,255,.22);border:1px solid rgba(255,182,214,.22);box-shadow:0 0 0 rgba(0,0,0,0)}
    body.joined .brand .dot{background:var(--pink3);border-color: rgba(255,182,214,.45);box-shadow:0 0 18px rgba(255,119,184,.65);animation: lampTwinkle 1.2s ease-in-out infinite;}
    @keyframes lampTwinkle{0%,100%{transform:scale(1);filter:brightness(1);}50%{transform:scale(1.18);filter:brightness(1.25);}}
    .brandTitle{font-weight:1100; font-size:18px; letter-spacing:-.4px;}
    .actions{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; justify-self:end}
    body.joined #meHint{display:none !important;}

    input, button, textarea{
      font:inherit;
      border-radius:12px;
      border:1px solid var(--line);
      color:var(--text);
      background: rgba(255,255,255,.06);
      padding:10px 12px;
      outline:none;
    }
    input::placeholder, textarea::placeholder{color:rgba(255,255,255,.4)}
    button{cursor:pointer}
    button.primary{
      background: linear-gradient(135deg, rgba(255,119,184,.92), rgba(255,182,214,.88));
      border: none;
      color:#1b1020;
      font-weight:1000;
      box-shadow: 0 14px 30px rgba(255,119,184,.18);
    }
    button.ghost{display:flex;align-items:center;justify-content:center;gap:6px;background: rgba(255,255,255,.05)}
    a.ghost{text-decoration:none;}

    /* ✅ 출근 버튼: 오늘 미출근이면 살짝 반짝(독촉), 출근 완료면 체크 표시 */
    @keyframes checkInPulse{
      0%,100%{ transform: translateY(0); filter: brightness(1); box-shadow: 0 0 0 rgba(255,119,184,0); }
      50%{ transform: translateY(-1px); filter: brightness(1.15); box-shadow: 0 0 18px rgba(255,119,184,.20); }
    }
    #checkInBtn.checkinPulse{
      animation: none !important;
      border-color: rgba(255,182,214,.55);
      box-shadow: 0 0 12px rgba(255,119,184,.14), inset 0 0 0 1px rgba(0,0,0,.15);
    }
    #checkInBtn.checkinDone{
      opacity: .92;
      border-color: rgba(255,255,255,.18);
      filter: saturate(.95);
    }

    /* ✅ Topbar 버튼 크기 통일 (기본 모드 Work 버튼 기준) */
.topCenter button,
.actions button{
  min-height:40px;
  padding:10px 12px;
  font-size:13px;
  line-height:1;
  border-radius:12px;
}
#statusMenu .statusBtns button{
  min-height:40px;
  padding:10px 12px;
  font-size:13px;
  line-height:1;
  border-radius:12px;
}

#statusMenu .modeBtns{display:none;  gap:8px; flex-wrap:wrap; justify-content:center; margin-bottom:10px;}
#statusMenu .modeBtns button{min-height:38px; padding:9px 12px; font-size:13px; line-height:1; border-radius:12px;}
#statusMenu .autoOpts{
  display:flex; flex-direction:column; gap:8px;
  padding:10px 10px 8px;
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  background: rgba(255,255,255,.04);
  margin-bottom:10px;
}
#statusMenu .autoOpts .rowMini{display:flex; align-items:center; justify-content:space-between; gap:10px;}
#statusMenu .autoOpts input{
  background: rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.14);
  color:#fff;
  border-radius:12px;
  padding:10px 10px;
}

/* ✅ 레이아웃 토글 버튼도 동일 규격 */
.gridHead .layoutToggle{
  min-height:40px;
  padding:10px 12px;
  font-size:13px;
  line-height:1;
  border-radius:12px;
}

    button:disabled, input:disabled, textarea:disabled{opacity:.45; cursor:not-allowed;}

    /* Main layout */
    .wrap{
      display:grid;
      grid-template-columns: minmax(0, 1fr) 340px; /* fixed sidebar width to prevent sudden stretch */
      gap: 10px;
      padding:14px;
      width:100%;
      max-width:none;
      margin:0;
      height: calc(100vh - 92px);
      max-height: calc(100vh - 92px);
      overflow: hidden;
    }

    /* ✅ Main(타일) 영역 오른쪽 여백: 대시보드와 딱 붙는 느낌 완화 */
    .wrap > main{ padding-right:10px; }

    /* ✅ 타일 그리드가 길어져도 페이지 전체 높이가 늘지 않도록: 메인은 고정 높이 + 내부 스크롤 */
    .wrap > main{ display:flex; flex-direction:column; min-height:0; overflow:hidden; }
    .gridScroll{ flex:1; min-height:0; overflow-y:auto; overflow-x:hidden; padding-right:2px; }
    .gridScroll{ scrollbar-width: thin; }
    .gridScroll::-webkit-scrollbar{width:10px;}
    .gridScroll::-webkit-scrollbar-thumb{background: rgba(255,255,255,.16); border-radius:999px; border:3px solid rgba(0,0,0,.20);}
    .gridScroll::-webkit-scrollbar-track{background: rgba(0,0,0,.12); border-radius:999px;}

    @media (max-width: 920px){
      /* ✅ 브라우저가 좁아져 3타일 유지가 어려우면: 타일(메인) 접고, 채팅/대시보드 폭 고정 */
      .wrap{grid-template-columns: 1fr !important;}
      main{display:none !important;}
      .sidebar{
        order:0;
        position:relative;
        top:auto;
        height: calc(100svh - 92px);
        max-height: calc(100svh - 92px);
        width: min(340px, 100%);
        max-width: 340px;
        margin: 0 auto;
      }
    }

    /* Sidebar */
    .sidebar{
      position:sticky;
      top:72px;
      align-self:start;
      justify-self:end;
      display:flex;
      flex-direction:column;
      gap:12px;
      height: calc(100vh - 92px);
      min-height: 520px;
    }
    .card{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h3{
      margin:0;
      padding:12px 14px;
      font-size:14px;
      color:rgba(255,255,255,.9);
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:center; text-align:center; justify-content:space-between;
      gap:10px;
    }

    /* Dashboard head (title + mission count + fold) */
    .dashHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid var(--line);
    }
    .dashHead h3{
      margin:0;
      padding:0;
      border:0;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
      white-space:nowrap;
    }
    .dashHeadRight{
      display:flex;
      align-items:center;
      gap:8px;
      flex-shrink:0;
    }
    .dashSuccess{
      font-weight:1000;
      font-size:13px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,182,214,.35);
      background: rgba(255,182,214,.10);
      cursor:pointer;
    }
    .dashFoldBtnSmall{
      padding:6px 10px;
      border-radius:999px;
      min-height:auto;
      line-height:1;
    }
    .dashFoldBtnSmall .dashFoldTxt{font-size:12px; opacity:.85; margin-left:6px;}
    @media (max-width: 520px){
      .dashFoldBtnSmall .dashFoldTxt{display:none;}
      .dashSuccess{padding:6px 8px;}
    }
    .card h3 span{color:var(--muted); font-weight:800; font-size:12px}
    .card .body{padding:12px 14px; display:flex; flex-direction:column; gap:10px;}

    /* Dashboard: two boxes side-by-side */
    .dashRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .dashBox{
      background: rgba(255,214,233,.10);
      border:1px solid rgba(255,182,214,.20);
      border-radius:14px;
      padding:8px 8px 6px;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:84px;
    }
    .dashTitle{font-weight:1000; display:flex; align-items:center; justify-content:center; text-align:center; gap:8px;}
    .dashBig{font-size:28px; font-weight:1100; letter-spacing:-1px; line-height:1}
    .dashFoot{display:flex; justify-content:space-between; align-items:center; gap:8px; color:var(--muted); font-size:12px}
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.85);
      font-size:12px;
      font-weight:900;
    }
    .btnRow{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:6px;
    }
    .btnRow button,
    .btnRow a.ghost{
      min-height:38px;
      padding:8px 4px;
      font-size:10px;
      line-height:1;
      letter-spacing:-.4px;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:2px;
      white-space:nowrap;
    }
    .btnRow .btnLabel{
      font-size:10px;
      letter-spacing:-.6px;
    }


    /* ✅ v42: 현황 카드 내부 '바로가기' 버튼은 v38처럼 길게(전체폭) */
    .dashBox > .btnRow{
      display:flex;
      grid-template-columns:none;
      gap:0;
    }
    .dashBox > .btnRow > button{
      width:100%;
      min-width:0;
    }
    .dashBox > .btnRow > button.dashGo{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px 12px;
      font-size:13px;
      letter-spacing:-.2px;
    }

    body:not(.joined) #dashShortcuts button{
      opacity:.45;
      filter:saturate(.8);
    }

    .btnRow button{flex:1; min-width: 0}
    .dashGo{padding:8px 10px; font-size:12px; font-weight:1100}
    .dashFoot{font-size:11px;}
    .tiny{font-size:11px;}
    .tiny{font-size:12px; color:var(--muted); line-height:1.35}

    /* Chat */
    .chatCard{flex:1; min-height:0; display:flex; flex-direction:column;}
    .chatBody{display:flex; flex-direction:column; gap:10px; flex:1; min-height:0;}
    .chatList{
      flex:1;
      min-height:220px;
      overflow-y:auto;
      overflow-x:hidden;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      padding:10px;
    }
    .chatList{scrollbar-width: thin;}
    .chatList::-webkit-scrollbar{width:10px;}
    .chatList::-webkit-scrollbar-thumb{background: rgba(255,255,255,.16); border-radius:999px; border:3px solid rgba(0,0,0,.20);}
    .chatList::-webkit-scrollbar-track{background: rgba(0,0,0,.12); border-radius:999px;}

    .chatNewBar{
      margin-top:8px;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    
    /* ✅ 더보기(과거 20개) 바: 스크롤 컨테이너 상단에 붙어서 잘 보이게 */
    .chatMoreBar{
      position: sticky;
      top: 0;
      z-index: 3;
      margin-bottom: 8px;
    }
.chatJumpBtn{
      width:100%;
      border-radius:12px;
      padding:10px 12px;
      border:1px solid rgba(255,182,214,.30) !important;
      background: rgba(255,182,214,.14) !important;
      font-weight:900;
    }
    .chatJumpBtn:hover{ filter:brightness(1.05); }
    .msg{
      display:flex; flex-direction:column; gap:2px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      margin-bottom:8px;
    }
    .msg .meta{display:flex; gap:8px; align-items:center; color:rgba(255,255,255,.72); font-size:12px; font-weight:800}

.msg .meta .chatEmoji{
  display:inline-flex;
  width:22px;               /* ✅ 반응 정렬 기준 */
  justify-content:center;
  margin-right:6px;
  flex:0 0 auto;
}
.msg .meta .chatName{display:inline-flex; align-items:center;}
/* ✅ 반응(칩/피커) 시작점을 닉네임 첫 글자 아래로 */
.msg.other .reactRow{ margin-left:28px; }      /* 22 + 6 */
	.msg.me .reactRow{ margin-left:28px; }      /* align under name */
.msg.other .reactPicker{ margin-left:28px; } /* padding-left(10) + 28 */
.msg.me .reactPicker{ margin-left:28px; }  /* align under name */
    .msg .text{white-space:pre-wrap; word-break:break-word; font-size:13px; line-height:1.35}
    .chatInputRow{display:flex; gap:8px}
    .chatInputRow input{flex:1}
    .chatInputRow button{flex:0 0 auto; min-width:88px}

    /* Chat: system + reactions */
    .msg.system{
      align-self:center;
      max-width: 92%;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.88);
      text-align:center;
      font-weight:900;
    }
    .msg.system .meta{display:none;}
    .msg.system .text{padding:10px 12px;}
    .reactRow{
      max-width:100%;
      display:flex;
      gap:6px;
      margin-top:8px;
      flex-wrap:nowrap;              /* ✅ 항상 한 줄 */
      justify-content:flex-start;
      align-items:center;
      overflow-x:auto;               /* ✅ 길면 가로 스크롤 */
      white-space:nowrap;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    .reactRow::-webkit-scrollbar{ display:none; }
    .reactBtn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      border-radius: 999px;
      padding:4px 8px;
      font-size:12px;
      cursor:pointer;
      font-weight:1000;
      line-height:1;
      user-select:none;
    }
    .reactBtn:hover{filter:brightness(1.08);}
    .reactBtn.on{
      border-color: rgba(255,120,190,.55);
      background: rgba(255,120,190,.18);
    }
    .reactCount{opacity:.88; margin-left:4px; font-variant-numeric: tabular-nums;}


    
    /* ✅ reactions UI (hover toggle + picker) */
    .msg{ position: relative; }
    .reactToggle{
      position:absolute;
      top:6px;
      right:6px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding:4px 7px;
      font-size:12px;
      cursor:pointer;
      line-height:1;
      opacity:0;
      pointer-events:none;
      transform: translateY(-1px);
      user-select:none;
    }
    .msg.other:hover .reactToggle{ opacity:1; pointer-events:auto; }
    .reactPicker{
      /* ✅ chatList가 overflow:auto라 absolute popup이 잘리는 문제 → inline(본문 아래)로 표시 */
      position:static;
      display:none;
      gap:6px;
      padding:8px;
      margin-top:8px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(18,18,26,.96);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      z-index:12;
      flex-wrap:nowrap;
      max-width: 100%;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      white-space:nowrap;
    }
    .reactPicker.open{ display:flex; }
    .reactPick{ padding:6px 9px; font-size:14px; }

    /* ✅ photo off: keep slot so emoji doesn't shift */
    .idPhoto.photoOff{ visibility:hidden; }
/* Chat alignment (상대=왼쪽, 나=오른쪽 / 글자수에 맞춰 폭 자동) */
    .chatList{display:flex; flex-direction:column;}
    .msg{width: fit-content; max-width: 78%;}
    .msg.other{align-self:flex-start; margin-right:auto;}
    .msg.me{align-self:flex-end; margin-left:auto; border-color: rgba(255,182,214,.28); background: rgba(255,214,233,.10);}
    .msg.other .meta{justify-content:flex-start;}
    .msg.me .meta{justify-content:flex-end;}
/* Main */
    .gridHead{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:12px; padding:2px 2px 8px;
    }
    .gridHead .title{font-size:18px; font-weight:1100; letter-spacing:-.6px; display:flex; align-items:baseline; gap:10px;}
    .titleSub{font-size:12px; color:var(--muted); font-weight:900;}
    .gridHead .right{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-right:10px;}

    /* ✅ 입장 알림: 시간과 가이드 버튼 사이에서 한 줄 공지처럼 스르륵 */
    .joinTicker{
      flex:1;
      min-width:0;
      align-self:center;
      height:40px;
      display:flex;
      align-items:center;
      overflow:hidden;
      border:1px solid rgba(255,182,214,.22);
      background: rgba(255,182,214,.08);
      border-radius:999px;
      padding:0 12px;
      box-shadow: 0 10px 22px rgba(255,119,184,.08);
    }
    .joinTicker.hidden{display:none !important;}
    .joinTickerTrack{
      display:inline-block;
      white-space:nowrap;
      padding-left:100%;
      will-change: transform;
    }
    .joinTickerText{
      font-weight:1000;
      font-size:13px;
      color:rgba(255,255,255,.92);
      letter-spacing:-.2px;
    }
    @keyframes joinMarquee{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(-100%); }
    }
    .pill{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color:rgba(255,255,255,.86);
      font-size:12px; font-weight:1000;
      display:inline-flex; align-items:center; gap:8px;
    }
    .grid{
      display:grid;
      gap:8px;
      grid-template-columns: repeat(auto-fill, minmax(var(--tileMin), var(--tileMax)));
      justify-content: center;
      padding:4px 0 12px;
      align-items:stretch;
          align-content:start;
    }

    
    /* Layout mode toggle */
    .layoutToggle{
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      color:rgba(255,255,255,.9);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }

    /* ✅ Mini 보기(자동 정렬) */
    .grid.compact5{
      /* 기존 '5열 고정' 대신, 브라우저 폭에 맞춰 자동 배치 */
      --tileMin: 150px;
      --tileMax: 210px;
      grid-template-columns: repeat(auto-fill, minmax(var(--tileMin), 1fr));
      justify-content: center;
      padding:6px 2px 14px;
    }

    .grid.compact5 .tile{
      aspect-ratio: auto;         /* prevent clipping */
      min-height: 168px;
    }
    .grid.compact5 .content{
      padding:10px;
      --tileGap: 8px;
      align-items:center;
      text-align:center;
    }
    .grid.compact5 .statusBar{
      justify-content:center;
    }
    .grid.compact5 .statusLeft{
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    .grid.compact5 .namePill{flex:1; min-width:0; min-height:40px; padding:0 12px; font-size:13px; line-height:1; border-radius:12px; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .grid.compact5 .bigTimer{
      font-size: clamp(16px, 2.6vw, 22px);
      justify-content:center;
      align-items:center;
      flex-direction:column;
      gap:8px;
    
      font-weight: 1100;
    }
    .grid.compact5 .missionBtn{display:none !important;}
    .grid.compact5 .bottomStack{
      display:none; /* hide bubble + avatar/photo in mini mode */
    }

    /* ✅ Mini 보기(5열) 추가 간소화 패치 */
    .grid.compact5 .tile{
      aspect-ratio: auto;
      min-height: 92px;
    }
    .grid.compact5 .content{
      padding:8px 8px 10px;
      gap:6px;
      align-items:center;
    }
    .grid.compact5 .statusBar{
      padding:0;
      justify-content:center;
    }
    .grid.compact5 .statusRight{display:none;}
    .grid.compact5 .statusLeft{
      flex-direction:row !important; /* 상태 이펙트 옆으로 닉네임 */
      align-items:center !important;
      justify-content:center;
      gap:6px;
      min-width:0;
    }
    /* 상태 배지: 이펙트만(텍스트 숨김) */
    .grid.compact5 .badge span:not(:first-child){display:none !important;}
    /* 미니 모드: 배지/닉네임 pill 크기 다듬기 */
    .grid.compact5 .badge{min-height:40px; padding:0 12px; font-size:13px; line-height:1; border-radius:12px;}
    .grid.compact5 .namePill{flex:1; min-width:0; min-height:40px; padding:0 12px; font-size:13px; line-height:1; border-radius:12px; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}


    /* ✅ 미션 성공 메달(타일에서 모두가 실시간 확인) */
    .missionMedal{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:40px;
      padding:0 12px;
      border-radius:12px;
      border:1px solid rgba(255,182,214,.45);
      background: rgba(255,182,214,.12);
      font-size:18px;
      font-weight:1000;
      line-height:1;
      box-shadow: 0 10px 22px rgba(255,119,184,.10);
      user-select:none;
    }
    .missionMedal.hidden{display:none !important;}
    .grid.compact5 .missionMedal{padding:0 10px; font-size:16px;}

    /* 미니 모드에서는 미션 버튼 숨김 */
    .grid.compact5 .missionBtn,
    .grid.compact5 .missionSpacer{display:none !important;}
    /* 작업 시간: 더 크게 */
    .grid.compact5 .bigTimer .time{
      font-size: clamp(18px, 3.2vw, 26px);
      letter-spacing: .5px;
    }

    /* Tile */
    .tile{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: 0 16px 38px rgba(0,0,0,.28);
      aspect-ratio: 1 / 1;
      min-height: unset;
      background: rgba(255,255,255,.04);
      max-width:none;
      width:100%;
      justify-self:stretch;
      }
    .tile .bg{position:absolute; inset:0; opacity:1;}
    .tile .shade{
      position:absolute; inset:0;
      /* 패턴이 더 잘 보이도록 살짝만 어둡게 */
      background: rgba(0,0,0,.32);
      }
    .tile .content{
      position:relative;
      padding:7px;
      padding-bottom: 10px;
      display:flex;
      flex-direction:column;
      --tileGap: 10px;
      gap: var(--tileGap, 10px);
      height:100%;
      min-height:unset;
    }

    .statusBar{display:flex; justify-content:center; align-items:center; gap:8px;}
    .statusLeft{display:flex; align-items:center; justify-content:center; text-align:center; gap:8px; min-width:0;}
    .statusRight{display:none;}
    
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      min-height:40px;
      padding:0 12px;
      border-radius:12px;
      font-size:13px;
      line-height:1;
      font-weight:1100;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.34);
    }
    .bWork{background: rgba(85, 255, 170, .12); border-color: rgba(85, 255, 170, .22)}
    .bBreak{background: rgba(255, 214, 80, .12); border-color: rgba(255, 214, 80, .22)}
    .bIdle{background: rgba(160, 160, 255, .12); border-color: rgba(160, 160, 255, .22)}
    .bOff{background: rgba(255, 255, 255, .08); border-color: rgba(255, 255, 255, .14)}

    .rowTop{display:flex; align-items:center; justify-content:center; text-align:center; justify-content:center; gap:6px; padding-top:0;}
    .who{display:flex; flex-direction:column; align-items:center; gap:8px; min-width:0;}
    .avatar{
      width: var(--emoSize, 60px);
      height: var(--emoSize, 60px);
      border-radius: 16px;
      background: var(--emoBg, #2b2b2b);
      border:1px solid rgba(255,255,255,.18);
      overflow:hidden;
      flex:0 0 auto;
      display:flex; align-items:center; justify-content:center; text-align:center; justify-content:center;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      font-size: calc(var(--emoSize, 60px) * 0.55);
      line-height:1;
    }
    .whoText{min-width:0; display:flex; flex-direction:column; gap:2px;}
    .name{font-weight:1100; letter-spacing:-.4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .namePill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:40px;
      padding:0 12px;
      border-radius:12px;
      font-size:13px;
      line-height:1;
      font-weight:1100;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.34);
    }
    /* ✅ Nickname display: full in 기본 보기, 3글자+… in 미니 보기 */
    .namePill .nameMini{display:none;}
    .grid.compact5 .namePill .nameFull{display:none;}
    .grid.compact5 .namePill .nameMini{display:inline;}

    .bubble{
      margin:0;
      background: var(--bubbleBg, rgba(255,255,255,.10));
      border-color: var(--bubbleBorder, rgba(255,255,255,.16));
    }

    body.compact .grid{ grid-template-columns: 1fr; }

    .gridRosterWrap{
      width: 100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 18px 50px rgba(0,0,0,.25);
    }
    .gridRosterTitle{
      font-weight: 1100;
      letter-spacing: -.2px;
      margin: 2px 0 10px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 6px 16px rgba(0,0,0,.25);
    }
    .gridRosterList{ display:flex; flex-direction:column; gap:10px; }
    .gridRosterItem{
      display:flex; align-items:center; justify-content:center; text-align:center; justify-content:space-between; gap:10px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.14);
    }
    .gridRosterLeft{ display:flex; align-items:center; justify-content:center; text-align:center; gap:10px; min-width:0; }
    .gridRosterEmoji{
      width: 40px; height: 40px;
      display:flex; align-items:center; justify-content:center; text-align:center; justify-content:center;
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      font-size: 20px;
    }
    .gridRosterName{
      font-weight: 850;
      max-width: 64vw;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .gridRosterStatus{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.86);
      flex: none;
    }

    #settingsModal .modalBody{ gap: 14px; }
    #settingsModal .row{ gap: 12px; }

    .motto{font-size:12px; color:rgba(255,255,255,.72); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    .idPhoto{
      width: var(--photoSize, 108px);
      height: var(--photoSize, 108px);
      border-radius:16px;
      border:none;
      background: rgba(0,0,0,.34);
      overflow:hidden;
      flex:0 0 auto;
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
      display:flex; align-items:center; justify-content:center; text-align:center; justify-content:center;
      color: rgba(255,255,255,.78);
      font-weight: 1100;
      font-size: 12px;
    }
    .idPhoto img{width:100%; height:100%; object-fit:cover; display:block;}

    .bigTimer{
      font-size: clamp(20px, 4.8vw, 30px);
      font-weight:1100;
      letter-spacing:-1px;
      line-height:1;
      display:flex; align-items:baseline; justify-content:space-between; gap:10px;
      min-width:0;
    }
    .bigTimer small{font-size:11px; font-weight:900; color:rgba(255,255,255,.70);}
    .bigTimer .time{white-space:nowrap; font-variant-numeric: tabular-nums;}

    .bubble{
  position:relative;
  margin:0;
  z-index:3;
  padding:7px 9px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.10);
  font-size:12.5px;
  line-height:1.25;
  min-height:32px;
  display:flex; align-items:center; justify-content:center; text-align:center;
  word-break:break-word;
  overflow:hidden;
}
.bottomStack{
  margin-top: 0;
  display:flex;
  flex: 0 0 auto;
  flex-direction:column;
  gap: var(--tileGap, 10px);
}
.mediaRow{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  padding-top:0;
}
    .bubble.muted{opacity:.72}


    /* ✅ v27-tile-only patch: vivid colors + remove avatar/photo shadow + darker bubble */
    .tile .shade{ background: rgba(0,0,0,0) !important; } /* keep vivid */
    .avatar{
      background: var(--emoBg, #2b2b2b) !important;   /* no dark overlay */
      box-shadow: none !important;
    
      border: none !important;
    }
    .idPhoto{ box-shadow: none !important; }
    

    /* Bottom bar */
    .bottomBar{
      position:sticky; bottom:0; z-index:15;
      background: rgba(11,11,16,.86);
      backdrop-filter: blur(10px);
      border-top:1px solid var(--line);
      padding:10px 14px;
    }
    .bottomInner{
      max-width:1400px; margin:0 auto;
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; flex-wrap:wrap;
    }
    .leftBar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .rightBar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .miniHelp{font-size:12px; color:var(--muted); font-weight:800}

    /* Modal */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10150; /* ✅ topbar/statusMenu 위로 */
      padding: 16px;
      overflow: auto;
    }
    .modalOverlay.show{display:flex}
    .modal{
      background: rgba(26,26,30,.92);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
      border-radius: 18px;
      width: min(920px, 100%);
      max-height: calc(100svh - 32px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* ✅ 출근 팝업: 닉네임 선택 감지 시 한 번 반짝 */
    @keyframes attNickPop{
      0%{ transform: scale(.985); filter: brightness(1); }
      45%{ transform: scale(1.01); filter: brightness(1.12); }
      100%{ transform: scale(1); filter: brightness(1); }
    }
    .modalOverlay.attSelectPulse .modal{
      border-color: rgba(255,182,214,.55);
      box-shadow: 0 0 0 1px rgba(255,182,214,.25), 0 0 24px rgba(255,119,184,.26), 0 24px 70px rgba(0,0,0,.55);
      animation: attNickPop .65s ease-out 1;
    }
    .modalHeader{
      padding:12px 14px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.34);
    }
    .modalHeader{ position: sticky; top: 0; z-index: 2; }
    .modalHeader .t{font-weight:1100}
    .modalBody{padding:12px 14px; display:flex; flex-direction:column; gap:10px; overflow:auto; min-height:0;}
    .row{display:flex; gap:8px; flex-wrap:wrap}
    .row > *{flex:1; min-width: 220px}
    .row .tight{flex:0 0 auto; min-width:auto}
/* Profile modal layout tidy */
    #profileModal .modalBody .row{display:flex; align-items:center; justify-content:center; text-align:center; gap:12px; flex-wrap:wrap}
    #profileModal .modalBody .row > *{flex:0 0 auto; min-width:0}
    #profileModal .modalBody .row label{flex:0 0 140px; max-width:140px; min-width:140px; font-weight:950; color:rgba(255,255,255,.86)}
    #profileModal .modalBody .row textarea{flex:1 1 420px; min-width:260px; height:46px; padding:10px 12px; line-height:1.35; resize:vertical}
    #profileModal .modalBody .row input[type="text"]{flex:1 1 260px; min-width:180px}
    #profileModal .modalBody .row input[type="file"]{flex:1 1 320px; min-width:220px}
    #profileModal .modalBody .row input[type="range"]{flex:1 1 340px; min-width:220px}
    #profileModal .modalBody .row select{flex:1 1 340px; min-width:220px}
    #profileModal .modalBody .row input[type="number"]{flex:0 0 86px; min-width:86px}
    #profileModal .modalBody .row .colorControls{flex:1 1 320px; min-width:220px}
    #profileModal .modalBody .row .tiny{flex:1 1 100%; margin-left:140px; min-width:0; font-size:12px; color:rgba(255,255,255,.62)}
    #profileModal .modalBody .row:last-child{justify-content:flex-end}

    .hint{font-size:12px; color:var(--muted); line-height:1.35}
    .hr{height:1px;background:rgba(255,255,255,.10); margin:4px 0}

    .toast{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:70px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px;
      border-radius:999px;
      font-size:13px;
      color:rgba(255,255,255,.9);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      z-index:999;
    }
    .toast.show{opacity:1}

    /* Color palette controls */
    .paletteWrap{display:flex; flex-direction:column; gap:8px;}
    .swatches{display:flex; flex-wrap:wrap; gap:8px;}
    #bgSwatches{display:none;}

    .swatch{
      width:22px; height:22px; border-radius:8px; cursor:pointer;
      border:1px solid rgba(255,255,255,.22);
      box-shadow: 0 8px 18px rgba(0,0,0,.20);
    }
    .swatch.active{outline:2px solid rgba(255,119,184,.9);}
    .colorControls{display:flex; gap:8px; align-items:center;}
    input[type="color"]{width:44px; height:44px; padding:0; border-radius:12px; overflow:hidden;}
    /* Embeds */
    .embedBar{display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:8px;}
    .embedBar .left{display:flex; gap:8px; align-items:center;}
    .embedFrame{
      width:100%;
      height:100%;
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background: rgba(0,0,0,.22);
    }

    
    .topCenter{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      flex:1;
      min-width: 240px;
      flex-wrap:wrap;
      position:relative;
    }

    .statusMenu{
      position:absolute;
      top:42px;
      left:50%;
      transform: translateX(-50%);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(16,16,18,.92);
      box-shadow: 0 16px 34px rgba(0,0,0,.42);
      backdrop-filter: blur(10px);
      z-index: 10080;
      width: min(520px, 92vw);
    }
    .statusMenu.hidden{display:none;}
    /* ✅ click safety for status menu */
    #statusBtn, #statusMenu{ pointer-events:auto; }

    .statusBtns{display:flex; gap:8px; flex-wrap:wrap; justify-content:center;}
    /* Helper toggle button (under Work) */
    #btnHelperToggle{
      margin-top:8px;
      width:100%;
      min-height:40px;
      border-radius: 14px;
      font-weight: 900;
    }

    .statusMenu button{min-width:106px;}
    .statusMenu button.tight{min-width:52px; padding:10px 10px; border-radius:12px;}
    .topCenter button{
      padding:10px 12px;
      border-radius:12px;
      font-weight:1000;
      white-space:nowrap;
    }
    .miniPill{padding:7px 10px; font-size:12px;}
    .topPills{display:none;}

    .meMini{
      font-size:12px;
      color: rgba(255,255,255,.68);
      font-weight:900;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
    }
    @media (max-width: 760px){
      .topCenter{order:3; width:100%; justify-content:flex-start;}
      .actions{order:2;}
      .brand{order:1;}
      .topbar{display:flex; flex-wrap:wrap;}
    }


    .tile .rowTop{min-height: 132px;}
    .tile .bigTimer{font-size:32px;}
    @media (max-width: 420px){
      .idPhoto{width:96px; height:96px;}
      .tile .bigTimer{font-size:28px;}
    }


    /* Status animations */
    .stIcon{display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:10px; background: rgba(0,0,0,.34); border:1px solid rgba(255,255,255,.14); margin-right:6px;}
    .stWork{animation: wiggle 1.25s ease-in-out infinite;}
    .stBreak{animation: none !important;}
    .stIdle{animation: floaty 1.8s ease-in-out infinite;}
    @keyframes wiggle{0%,100%{transform:rotate(0deg) translateY(0);}50%{transform:rotate(-10deg) translateY(-1px);}}
    @keyframes puff{0%,100%{transform:translateY(0);opacity:1;}50%{transform:translateY(-2px);opacity:.85;}}
    @keyframes floaty{0%,100%{transform:translateY(0);}50%{transform:translateY(-3px);}}
    .chatEmoji{margin-right:6px;}

@media (max-width: 460px){
  /* ✅ 아주 작은 화면에서도 사이드바 폭은 늘리지 않기 */
  main{display:none !important;}
  .sidebar{width: min(340px, 100%); max-width: 340px; margin: 0 auto;}
}
@media (max-width: 820px){
  .tile{max-width:none; justify-self:stretch;}
  .rowTop{min-height: 156px;}
}

    /* Mini online button next to profile */
    .miniOnline{
      padding:10px 12px;
      border-radius:999px;
      font-weight:1000;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background: rgba(255,255,255,.05);
    }

    /* Chat responsive fixes (avoid input bar getting cut) */
    .chatCard{min-height: 320px;}
    .chatBody{min-height:0;}
    .chatList{min-height:0;}
    .chatInputRow{flex-wrap:wrap;}
    .chatInputRow input{min-width:0;}
    @media (max-width: 520px){
      .chatInputRow button{min-width:72px;}
    }
    @media (max-width: 380px){
      .chatInputRow button{width:100%; min-width:0;}
      .chatInputRow input{width:100%;}
    }

    
    @media (max-height: 720px){
      .sidebar{height:auto; min-height:0;}
      .chatCard{min-height:260px;}
    }

    /* Dashboard docking under settings button */
    #dashboardCard.docked{
      position: fixed;
      z-index: 60;
      width: clamp(260px, 28vw, 340px);
    }

    #chatCard.dockedChat{
      z-index: 55;
      width: clamp(260px, 28vw, 340px);
    }


    /* --- Context menu (프로필 우클릭 강퇴) --- */
    .ctxMenu{
      position: fixed;
      z-index: 9999;
      min-width: 190px;
      max-width: 260px;
      background: rgba(18,18,20,.94);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      padding: 8px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
    }
    .ctxMenu.hidden{ display:none; }
    .ctxMenu .title{
      font-size: 13px;
      color: rgba(255,255,255,.88);
      padding: 6px 10px 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      margin-bottom: 6px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .ctxMenu button{
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      font-weight: 700;
      cursor: pointer;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      margin-top: 6px;
    }
    .ctxMenu button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    .ctxMenu button:active{ transform: translateY(1px); }
    .ctxMenu button.danger{
      background: rgba(255, 90, 140, .20);
      border-color: rgba(255, 90, 140, .40);
    }
    .ctxMenu button.danger:hover{
      background: rgba(255, 90, 140, .28);
      border-color: rgba(255, 90, 140, .55);
    }
    .ctxMenu button:disabled{
      opacity: .45;
      cursor: not-allowed;
      transform: none;
    }
    /* ✅ ultra-small window: use roster layout in main (tiles hidden by JS) */
    body.compact .wrap{grid-template-columns: 1fr;}

  
    body.passok #roomPass{display:none;}
    .actions{flex-wrap:wrap}
    #roomPass{min-width:92px}

  

    /* ✅ 초소형 화면: 채팅만 남기고 메인(타일/시간/접속자목록-컴팩트)을 숨김 */
    body.compact main{ display:none !important; }
    body.compact .wrap{ grid-template-columns: 1fr !important; }
    body.compact .sidebar{
      grid-column: 1 / -1;
      height: calc(100vh - 92px);
      max-height: calc(100vh - 92px);
      overflow: auto;
    }
    body.compact .sidebar .chatCard{ height: calc(100vh - 150px); }

    .btnLabel{font-size:12px;font-weight:900;letter-spacing:-0.2px;margin-left:8px;opacity:.92;}


    /* ✅ REC(작업중) 표시 */
    .recBadge{ background: rgba(255,0,0,.14) !important; border-color: rgba(255,0,0,.35) !important; }
    .recBadge .recDot{
      width:8px;height:8px;border-radius:999px;
      background: rgb(255,60,60);
      box-shadow: 0 0 0 0 rgba(255,60,60,.55);
      animation: recPulse 1.1s infinite;
      display:inline-block;
      margin-right:6px;
      vertical-align:middle;
    }
    @keyframes recPulse{
      0%{ box-shadow:0 0 0 0 rgba(255,60,60,.50); transform:scale(1); }
      70%{ box-shadow:0 0 0 10px rgba(255,60,60,0); transform:scale(1.05); }
      100%{ box-shadow:0 0 0 0 rgba(255,60,60,0); transform:scale(1); }
    }

    /* ✅ 오늘의 미션 버튼(집중시간 라벨 자리) */
    .missionBtn{
      width: 34px; height: 18px;
      flex:0 0 auto;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.25);
      position: relative;
      padding: 0;
      cursor: pointer;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
      color: rgba(255,255,255,.95);
      font-size: 13px;
      font-weight: 1100;
      letter-spacing: -0.2px;
    
      display:flex; align-items:center; justify-content:center;
}
    .missionBtn[data-me="0"]{display:none !important;}

    .missionBtn::after{
      content:"";
      position:absolute; inset: 2px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      pointer-events:none;
    }
    .missionSpacer{width:34px;height:18px; display:inline-block; flex:0 0 auto; opacity:0;}
    .missionBtn.isHot{
      border-color: rgba(255,140,0,.65);
      box-shadow:
        0 0 10px rgba(255,120,0,.25),
        0 0 22px rgba(255,80,0,.14),
        inset 0 0 0 1px rgba(0,0,0,.18);
      animation: fireFlicker 1.1s infinite;
    }
    @keyframes fireFlicker{
      0%{ filter: drop-shadow(0 0 0 rgba(255,120,0,.0)); transform: translateY(0); }
      35%{ filter: drop-shadow(0 0 4px rgba(255,120,0,.35)); transform: translateY(-.3px); }
      70%{ filter: drop-shadow(0 0 6px rgba(255,80,0,.25)); transform: translateY(.2px); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,120,0,.0)); transform: translateY(0); }
    }
    .missionBtn.isDone{
      border-color: rgba(255,255,255,.75);
      box-shadow:
        0 0 12px rgba(255,255,255,.22),
        0 0 26px rgba(255,255,255,.12),
        inset 0 0 0 1px rgba(0,0,0,.18);
      animation: sparkle 1.25s infinite;
    }
    @keyframes sparkle{
      0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
      50%{ filter: drop-shadow(0 0 6px rgba(255,255,255,.55)); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
    }

    /* ✅ 폭죽 FX 레이어 */
    #fxLayer{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
    }
    .fxPop{
      position: absolute;
      width: 6px; height: 6px;
      border-radius: 999px;
      opacity: .95;
      transform: translate(-50%,-50%);
      animation: fxFly 700ms ease-out forwards;
      background: rgba(255,255,255,.95);
    }
    @keyframes fxFly{
      to{
        transform: translate(var(--dx), var(--dy));
        opacity: 0;
      }
    }

    /* ✅ 대시보드 미션 라인 + 접기 */
    .dashMissionLine{display:flex; align-items:center; justify-content:center; text-align:center; gap:10px; margin:2px 0 8px;}
    .dashFoldBtn{
      margin-left:auto;
      height: 26px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.85);
      font-weight: 1100;
      cursor: pointer;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .dashFoldBtn:hover{ background: rgba(0,0,0,.22); }
    /* Dashboard fold body: add breathing room between '현황' and '바로가기' rows */
    .dashFoldBody{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .dashFoldBody.isHidden{ display:none !important; }

/* ✅ v62b: 대시보드 접기/도킹에서도 채팅(리스트+입력)이 절대 사라지지 않도록 레이아웃 고정 */
.sidebar{
  display:flex !important;
  flex-direction:column !important;
  gap:12px !important;
  min-height:0 !important;
}
#dashboardCard{ flex:0 0 auto !important; }
#chatCard{
  flex:1 1 auto !important;
  min-height:0 !important;
  display:flex !important;
  flex-direction:column !important;
}
#chatCard > h3{ flex:0 0 auto !important; }
#chatCard .body.chatBody{
  flex:1 1 auto !important;
  min-height:0 !important;
  display:flex !important;
  flex-direction:column !important;
  overflow:hidden !important;
}
#chatList{
  flex:1 1 auto !important;
  min-height:0 !important;
  overflow:auto !important;
}
#chatCard .chatInputRow{ flex:0 0 auto !important; }

/* 접기 시: 대시보드 카드의 '현황/바로가기'만 숨김 */
.dashFoldBody.isHidden{ display:none !important; }

/* ✅ 오른쪽 사이드(대시보드+채팅) 통째로 접기 */
body.railFolded .wrap{ grid-template-columns: 1fr !important; }
body.railFolded .sidebar{ display:none !important; }
body.railFolded main{ grid-column:1 / -1; }
.railEdgeBtn{
  position:fixed;
  right:14px;
  top: 140px;
  z-index: 10050;
  width:44px;
  height:44px;
  border-radius:999px;
  display:none;
  align-items:center;
  justify-content:center;
  padding:0;
  box-shadow: 0 18px 40px rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.16);
  background: rgba(20,12,18,.78);
  backdrop-filter: blur(8px);
}
body.railFolded .railEdgeBtn{ display:flex !important; opacity:1; pointer-events:auto; }


/* ===== 출근(출석) 팝업 모달 ===== */
.attModal{position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center;}
.attModal.hidden{display:none !important;}
.attModal .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.62); backdrop-filter: blur(6px);}
.attModal .panel{
  position:relative; z-index:1;
  width:min(860px, 94vw); height:min(720px, 86vh);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(20, 12, 18, .82);
  box-shadow: 0 22px 60px rgba(0,0,0,.55);
  overflow:hidden;
  display:flex; flex-direction:column;
}
.attModal .head{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding:12px 12px;
  border-bottom:1px solid rgba(255,255,255,.12);
}
.attModal .head .ttl{font-weight:1100; letter-spacing:-.3px;}
.attModal .head .xBtn{
  min-height:40px; border-radius:12px;
  padding:10px 12px;
  background: rgba(255,255,255,.06);
}
.attModal .attHeadBtns{display:flex; align-items:center; gap:8px; flex-wrap:nowrap;}
.attModal iframe{flex:1; width:100%; border:0; background:#fff;}


    /* ✅ 프로필 모달: 좌측 정렬로 (이모지 삐죽 방지) */
    #profileModal .modalBody .row{justify-content:flex-start; text-align:left;}
    #profileModal .modalBody .row textarea{width:100%;}

  
/* ✅ 로컬 헬퍼 상태 표시 */
.helperDot{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  display: inline-block;
  box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 0 12px rgba(255,105,180,.18);
}
.helperDot.on{ background: #43d17a; }
.helperDot.wait{ background: #ffd166; }
.helperDot.off{ background: rgba(255,255,255,.22); }

/* ✅ 프로필에서 헬퍼 설정 숨김 */
.profileHelperHidden{ display:none !important; }


    .guidePre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-size:13px;
      line-height:1.5;
      color: rgba(255,255,255,.92);
    }


    /* ✅ 출근 버튼(미션처럼 은은한 반짝 테두리) */
    #checkInBtn{ position:relative; overflow:hidden; }
    #checkInBtn::after{
      content:"";
      position:absolute; inset:-2px;
      border-radius:12px;
      pointer-events:none;
      border:1px solid rgba(255,182,214,.55);
      box-shadow: 0 0 0 1px rgba(255,182,214,.25), 0 0 18px rgba(255,119,184,.22);
      opacity:.75;
      animation: checkInBorderPulse 1.6s ease-in-out infinite;
    }
    #checkInBtn::before{
      content:"";
      position:absolute; top:-45%; left:-60%;
      width:60%; height:190%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.34), transparent);
      transform: rotate(20deg) translateX(-140%);
      animation: checkInShine 2.6s ease-in-out infinite;
      pointer-events:none;
      opacity:.55;
    }
    @keyframes checkInBorderPulse{
      0%,100%{opacity:.55; filter:brightness(1);}
      50%{opacity:1; filter:brightness(1.25);}
    }
    @keyframes checkInShine{
      0%{transform: rotate(20deg) translateX(-140%);}
      55%{transform: rotate(20deg) translateX(240%);}
      100%{transform: rotate(20deg) translateX(240%);}
    }

    /* ✅ 휴식중 커피 연기 애니메이션 */
    .coffeeSteam{ position:relative; display:inline-block; margin-right:4px; }
    .coffeeSteam::before,
    .coffeeSteam::after{
      content:"";
      position:absolute;
      left:50%;
      top:-6px;
      width:12px;
      height:16px;
      border-radius:999px;
      border:2px solid rgba(255,255,255,.55);
      border-color: rgba(255,255,255,.42) transparent transparent transparent;
      transform: translateX(-50%) translateY(6px) scale(.8);
      opacity:0;
      animation: coffeeSteamRise 1.6s ease-in-out infinite;
      pointer-events:none;
    }
    .coffeeSteam::after{
      top:-9px;
      width:14px;
      height:18px;
      animation-delay:.8s;
    }
    @keyframes coffeeSteamRise{
      0%{opacity:0; transform: translateX(-50%) translateY(7px) scale(.78);}
      25%{opacity:.7;}
      100%{opacity:0; transform: translateX(-50%) translateY(-12px) scale(1.08);}
    }


    .onlineList{ display:flex; flex-direction:column; gap:10px; }
    .onlineItem{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius:14px;
    }
    .onlineLeft{ display:flex; align-items:center; gap:10px; min-width:0; }
    .onlineEmoji{ width:34px; height:34px; border-radius:12px; display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.12);
      flex:0 0 auto;
    }
    .onlineName{ font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .onlineMeta{ font-size:12px; opacity:.72; margin-left:6px; white-space:nowrap; }
    .onlineBadge{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      font-size:12px; font-weight:900;
      background: rgba(0,0,0,.22);
      flex:0 0 auto;
    }


/* ✅ 전체 배경 패턴(가볍게) */
body{ position: relative; }
body::before{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: .10;
  background-image: url("data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22160%22%20height=%22160%22%20viewBox=%220%200%20160%20160%22%3E%0A%20%20%3Cdefs%3E%0A%20%20%20%20%3Cpattern%20id=%22p%22%20width=%2240%22%20height=%2240%22%20patternUnits=%22userSpaceOnUse%22%3E%0A%20%20%20%20%20%20%3Ccircle%20cx=%226%22%20cy=%226%22%20r=%222%22%20fill=%22#ffffff%22%20fill-opacity=%220.55%22/%3E%0A%20%20%20%20%20%20%3Ccircle%20cx=%2226%22%20cy=%2218%22%20r=%221.6%22%20fill=%22#ffffff%22%20fill-opacity=%220.35%22/%3E%0A%20%20%20%20%20%20%3Ccircle%20cx=%2214%22%20cy=%2230%22%20r=%221.8%22%20fill=%22#ffffff%22%20fill-opacity=%220.4%22/%3E%0A%20%20%20%20%3C/pattern%3E%0A%20%20%3C/defs%3E%0A%20%20%3Crect%20width=%22160%22%20height=%22160%22%20fill=%22url%28#p%29%22/%3E%0A%3C/svg%3E");
  background-repeat: repeat;
  background-size: 220px 220px;
}
.topbar{ position: relative; z-index: 3000; }
.wrap{ position: relative; z-index: 1; }


/* ✅ hide photo size slider (requested) */
#photoSizeRow{display:none !important;}

/* ✅ PRE-JOIN LOCK: 입장 전에는 어떤 정보도 보이지 않게 */
#preJoinCard{ display:none; max-width: 720px; margin: 22px auto 0; padding: 18px 18px; }
#preJoinCard h3{ margin:0; font-size:16px; }
#preJoinCard .hint{ margin-top:8px; opacity:.86; font-size:13px; line-height:1.35; }
#preJoinCard .prePills{ margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

body:not(.joined) main,
body:not(.joined) aside.sidebar{ display:none !important; }

/* 입장 전에는 오른쪽 사이드/타일 관련 토글도 숨김 */
body:not(.joined) #guideBtn,
body:not(.joined) #layoutToggleBtn{ display:none !important; }

/* 입장 전 안내 카드만 표시 */
body:not(.joined) #preJoinCard{ display:block; }
body.joined #preJoinCard{ display:none; }


    /* ✅ Daily Notice (입장 공지/출근 유도) */
    .dailyNoticeModal{
      position:fixed; inset:0; z-index:10090;
      display:block;
    }
    .dailyNoticeModal.hidden{ display:none; }
    .dailyNoticeModal .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(6px);
    }
    .dailyNoticeModal .panel{
      position:relative;
      width:min(560px, 92vw);
      margin: min(12vh, 90px) auto 0;
      background: rgba(18,18,26,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .dailyNoticeModal .head{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(90deg, rgba(255,119,184,.16), rgba(255,182,214,.06));
    }
    .dailyNoticeModal .ttl{
      font-weight:1000; letter-spacing:-.3px;
      display:flex; align-items:center; gap:8px;
    }
    .dailyNoticeModal .body{
      padding:14px;
      color: rgba(255,255,255,.88);
      line-height:1.55;
      font-size: 14px;
    }
    .dailyNoticeModal .body .small{
      margin-top:10px;
      color: rgba(255,255,255,.62);
      font-size: 12px;
    }
    .dailyNoticeModal .btnRow{
      display:flex; gap:10px; justify-content:flex-end;
      padding: 0 14px 14px;
    }
    .dailyNoticeModal .btnRow button{
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      cursor:pointer;
      font-weight:800;
    }
    .dailyNoticeModal .btnRow button.primary{
      border-color: rgba(255,119,184,.35);
      background: linear-gradient(90deg, rgba(255,119,184,.40), rgba(255,182,214,.18));
      box-shadow: 0 10px 24px rgba(255,119,184,.12);
    }
    .dailyNoticeModal .btnRow button:disabled{ opacity:.55; cursor:not-allowed; }
    .dailyNoticeModal .xBtn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      font-weight:900;
    }
</style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <span class="dot" title="방 불"></span>
      <div class="brandTitle">💗마끝마💗</div>
    </div>

    <!-- 가운데: 상태표시 + 내프로필 -->
    <div class="topCenter" aria-label="작업 상태">
      <button id="checkInBtn" class="ghost" disabled>💌출근💌</button>
      <button id="statusBtn" class="primary" disabled>☕ 휴식중 ▾</button>

      <div id="statusMenu" class="statusMenu hidden" role="menu" aria-label="상태 선택">
                <div class="modeBtns">
          <button id="modeAutoBtn" class="primary tight" type="button" title="헬퍼(자동)">🤖 헬퍼</button>
          <button id="modeManualBtn" class="ghost tight" type="button" title="수동">✋ 수동</button>
        </div>

        <div id="autoOpts" class="autoOpts">
          <div class="rowMini" style="align-items:center; gap:10px;">
            <span id="helperTopDot" class="helperDot off" aria-hidden="true"></span>
            <span id="helperTopText" class="tiny" style="font-weight:900; letter-spacing:.2px;">미연결</span>
          </div>

          <div class="rowMini">
            <span class="tiny">자동 휴식(분)</span>
            <input id="autoBreakMinTop" type="number" min="1" max="180" value="10" style="width:76px">
          </div>
          <div class="rowMini">
            <span class="tiny">자동 자리비움(분)</span>
            <input id="autoIdleMinTop" type="number" min="1" max="180" value="15" style="width:76px">
          </div>
          <div class="tiny" style="opacity:.82; margin-top:6px;">작업중일 때만 적용 · 헬퍼 움직임 재감지 시 자동 복귀</div>
        </div>

        <div id="manualOpts" class="statusBtns">
          <button id="btnWork" class="primary" disabled>✍️ 작업중</button>
          <button id="btnHelperToggle" class="ghost" disabled>🤖 헬퍼 켜기</button>
          <button id="btnBreak" class="ghost" disabled>☕ 휴식중</button>
          <button id="btnIdle" class="ghost" disabled>🌙 자리비움</button>
          <button id="btnTimerReset" class="ghost" disabled title="오늘 작업 타이머 초기화">⏱️ 초기화</button>
        </div>

        

      </div>


      <div class="topPills">
        <div class="pill miniPill">🕒 <span id="lastSync">-</span></div>
      </div>

      <button id="onlineBtn" class="ghost miniOnline" disabled title="접속 인원">👥 <span id="countOnline">0</span>명</button>
      <button id="profileBtn" class="ghost">🪪 내 프로필</button>
    </div>

    <div class="actions">
      <input id="name" placeholder="닉네임" maxlength="7" style="width:180px">
      <input id="roomPass" placeholder="입장키" type="password" style="width:120px">
      <button id="joinBtn" class="primary">입장</button>
      <button id="leaveBtn" class="primary" disabled>퇴장</button>
      <span class="meMini" id="meHint">—</span>
      <button id="dataSaverBtn" class="ghost" disabled title="데이터 절약 모드(채팅만 실시간)">🔋 절약</button>
      <button id="menuBtn" class="ghost" disabled title="작업방 설정">⚙️</button>
    </div>
  </div>

  <div class="wrap">

    <div id="preJoinCard" class="card preJoinCard" aria-live="polite">
      <h3>🔒 입장 전에는 내용이 표시되지 않아요</h3>
      <div class="hint">상단에서 <b>닉네임</b>과 <b>입장키</b>를 입력하고 <b>입장</b>을 눌러줘!<br><span class="tiny">※ 접속 인원은 대략치로만 보여요.</span></div>
      <div class="prePills">
        <div class="pill">👥 현재 접속 <b id="approxOnlineText">—</b></div>
      </div>
    </div>

    <main>
      <div class="gridHead">
        <div class="title">✒️지금 시간 <span id="nowClockMain">--:--:--</span></div>
        <div id="joinTicker" class="joinTicker hidden" aria-live="polite" aria-atomic="true">
        <div id="joinTickerTrack" class="joinTickerTrack"><span id="joinTickerText" class="joinTickerText"></span></div>
      </div>

      <div class="right"><button id="guideBtn" class="ghost layoutToggle" type="button" title="가이드 보기" aria-label="가이드 보기">👩‍❤️‍👩 가이드</button>
        <button id="layoutToggleBtn" class="ghost layoutToggle" type="button" title="타일 정렬 모드 변경" aria-label="타일 정렬 모드 변경">미니 보기</button></div>
      </div>

      <div id="gridScroll" class="gridScroll">
      <div id="grid" class="grid"></div>
    </div>
    </main>

    <aside class="sidebar">
      <div class="card" id="dashboardCard">
        <div class="dashHead">
          <h3>💗 대시보드</h3>
          <div class="dashHeadRight">
            <div class="dashSuccess" title="오늘 미션 성공 인원">👑 <span id="missionSuccessCount">0</span></div>
            <button id="dashFoldBtn" class="dashFoldBtn dashFoldBtnSmall" type="button" title="현황/바로가기 접기/펼치기">
              <span id="dashFoldIcon">▴</span>
              <span class="dashFoldTxt">접기</span>
            </button>
          </div>
        </div>
        <div class="body">
          <div id="dashFoldBody" class="dashFoldBody">
          <div class="dashRow">
            <div class="dashBox">
              <div class="dashTitle">⏰ 공용 뽀모</div>
              <div class="dashBig"><span id="pomoCount">—</span><span style="font-size:16px;font-weight:900;margin-left:6px">명</span></div>
              <div class="btnRow">
                <button id="goPomo" class="primary dashGo" title="바로가기">👉💗</button>
              </div>
              <div class="dashFoot">
                <span>연결: <b id="pomoOk">연결됨</b></span>
                <span class="chip">LIVE</span>
              </div>
            </div>

            <div class="dashBox">
              <div class="dashTitle">💣 폭파 수다</div>
              <div class="dashBig"><span id="sudaCount">—</span><span style="font-size:16px;font-weight:900;margin-left:6px">명</span></div>
              <div class="btnRow">
                <button id="goSuda" class="primary dashGo" title="바로가기">👉💗</button>
              </div>
              <div class="dashFoot">
                <span>연결: <b id="sudaOk">연결됨</b></span>
                <span class="chip">LIVE</span>
              </div>
            </div>
          </div>

          <div class="btnRow" id="dashShortcuts">
            <button id="goMacHelper" class="ghost" title="Mac 헬퍼"><span class="btnLabel">🍎Mac</span></button>
            <button id="goWinHelper" class="ghost" title="Win 헬퍼"><span class="btnLabel">🪟Win</span></button>
            <button id="goChool" class="ghost" title="출근부"><span class="btnLabel">🔥출근부</span></button>
            <button id="goSheet" class="ghost" title="뽀모 시트"><span class="btnLabel">📎뽀모시트</span></button>
          </div>
        </div>
      </div>

      <div class="card chatCard" id="chatCard">
        <h3>💬 채팅 <span class="tiny">(채팅창&대시보드 접기)</span> <button id="railFoldToggle" class="ghost railFoldBtn" type="button" title="오른쪽 사이드 접기/펴기" aria-label="오른쪽 사이드 접기/펴기">⟫</button></h3>
        <div class="body chatBody">
          
          <div id="embedBar" class="embedBar" style="display:none">
            <div class="left">
              <span class="pill">🫧 임베드</span>
              <span id="embedTitle" class="tiny">열린 창</span>
            </div>
            <div class="right" style="display:flex; gap:8px; align-items:center">
              <button id="embedOpen" class="ghost tight">새 창</button>
              <button id="embedClose" class="ghost tight">닫기</button>
            </div>
          </div>
          <iframe id="embedFrame" class="embedFrame" style="display:none" loading="lazy" referrerpolicy="no-referrer"></iframe>

          <div id="chatList" class="chatList"></div>
          <div id="chatNewBar" class="chatNewBar" style="display:none">
            <button id="chatJumpBtn" class="ghost chatJumpBtn" type="button">
              ⬇️ 새 메시지 <span id="chatUnseenCount">1</span> · 바로가기
            </button>
          </div>
          <div class="chatInputRow">

            <input id="chatInput" placeholder="메시지…" disabled />
            <button id="sendBtn" class="primary" disabled>전송</button>
          </div>
        </div>
      </div>
    </aside>
  </div>
  </div>

  <!-- Profile Modal -->
  
  <div id="missionListModal" class="modalOverlay" aria-hidden="true">
    <div class="modal">
      <div class="modalHeader">
        <h4>👑 오늘 미션 완료자</h4>
        <button class="ghost" data-close="missionListModal" type="button">닫기</button>
      </div>
      <div class="modalBody" style="max-height:60vh; overflow:auto;">
        <div id="missionListBody" class="tiny" style="line-height:1.7; white-space:pre-wrap;"></div>
      </div>
    </div>
  </div>

<div id="profileModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">🪪 내 프로필</div>
        <button id="closeProfile" class="ghost">닫기</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <label>🎇이모지</label>
          <input id="emoji" placeholder="예: 😍, ✍️, 💓, 💝, 💗," maxlength="4" style="width:120px">
          <span class="tiny">프로필 타일에 표시돼요.</span>
        </div>

        <div class="row">
          <label>🎇이모지 크기</label>
          <input id="emojiSize" type="range" min="26" max="100" value="40" style="flex:1">
          <input id="emojiSizeNum" type="number" min="26" max="100" value="40" style="width:76px">
        </div>

        <div class="row">
          <label>🎇사진 사용</label>
          <input id="photoEnabled" type="checkbox" checked style="transform:scale(1.15); margin-right:8px;">
          <span class="tiny">끄면 타일에서 사진 칸이 사라져요.</span>
        </div>

        <div id="photoUploadRow" class="row">
          <label>🎇사진 업로드</label>
          <input id="photoFile" type="file" accept="image/*,.gif" />
          <button id="uploadPhotoBtn" class="primary tight">업로드</button>
        </div>

        <div id="photoSizeRow" class="row">
          <label>사진 크기</label>
          <input id="photoSize" type="range" min="52" max="100" value="68" style="flex:1">
          <input id="photoSizeNum" type="number" min="52" max="100" value="68" style="width:76px">
        </div>

        <div class="row">
          <label>🎇이모지 배경</label>
          <div class="colorControls">
            <input id="emojiBgPicker" type="color" value="#2b2b2b" />
            <input id="emojiBgColor" value="#2b2b2b" style="width:110px" />
          </div>
          <span class="tiny"></span>
        </div>

        <div class="row">
          <label>🎇이모지 배경 투명</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input id="emojiBgTransparent" type="checkbox" style="transform:scale(1.15);" />
              <span class="tiny"></span>
            </label>
          </div>
          <span class="tiny"></span>
        </div>

        <div class="row" style="align-items:flex-start;">
          <label>🎇배경색</label>
          <div id="swatches" class="swatches" style="display:none"></div>
          <div class="colorControls">
            <input id="bgPicker" type="color" value="#ffd0e2" />
            <input id="bgColor" value="#ffd0e2" style="width:110px" />
          </div>
        </div>

        <div class="row">
          <label>🎇닉네임</label>
          <input id="profileNick" type="text" maxlength="20" placeholder="닉네임 (최대 20자)">
          <span class="tiny">저장하면 상단/채팅/접속자 목록에 즉시 반영돼요.</span>
        </div>


        <div class="row">
          <label>🎇배경 패턴</label>
          <select id="bgPattern" class="ghost" style="flex:1; background:#111; color:#fff; border:1px solid rgba(255,255,255,.18);">
            <option value="none">없음</option>
            <option value="dots">도트</option>
            <option value="hearts">하트</option>
            <option value="stars">별</option>
            <option value="moon">달</option>
            <option value="flowers">꽃</option>
            <option value="clouds">구름</option>
            <option value="catpaws">고양이 발바닥</option>
            <option value="dogpaws">강아지 발바닥</option>
            <option value="stripes">스트라이프</option>
            <option value="grid">그리드</option>
            <option value="papergrid">종이 그리드</option>
            <option value="waves">웨이브</option>
          </select>
          <span class="tiny"></span>
        </div>


<div class="row">
  <label>🎇패턴 색</label>
  <div class="colorControls">
    <input id="patternPicker" type="color" value="#ffffff" />
    <input id="patternColor" value="#ffffff" style="width:110px" />
  </div>
  <span class="tiny">패턴(도트/하트/줄무늬 등) 색만 바꿔요.</span>
</div>

<div class="row">
          <label>🎇말풍선(최대 15자)</label>
          <textarea id="bubbleText" placeholder="지금 상태 한 마디!" maxlength="15"></textarea>
        </div>

        <div class="row">
          <label>🎇말풍선 배경</label>
          <div class="colorControls">
            <input id="bubblePicker" type="color" value="#ffd0e2" />
            <input id="bubbleColor" value="#ffd0e2" style="width:110px" />
          </div>
        </div>

        <div class="row">
          <label>🎇타이머 색</label>
          <div class="colorControls">
            <input id="timePicker" type="color" value="#ffffff" />
            <input id="timeColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny">집중=선택색, 휴식/자리비움=회색 고정</span>
        </div>

        

        <div class="row">
          <label>🎇타일 닉네임</label>
          <div class="colorControls">
            <input id="nameColorPicker" type="color" value="#ffffff" />
            <input id="nameColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny">🎇프로필 타일</span>
        </div>

        <div class="row">
          <label>🎇채팅 닉네임</label>
          <div class="colorControls">
            <input id="chatNameColorPicker" type="color" value="#ffffff" />
            <input id="chatNameColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny"></span>
        </div>

        <div class="row">
          <label>🎇현재상태</label>
          <div class="colorControls">
            <input id="statusTextColorPicker" type="color" value="#ffffff" />
            <input id="statusTextColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny">작업중/휴식중/자리비움 배지 글씨</span>
        </div>

        <div class="row">
          <label>🎇말풍선 글씨</label>
          <div class="colorControls">
            <input id="bubbleTextColorPicker" type="color" value="#ffffff" />
            <input id="bubbleTextColor" value="#ffffff" style="width:110px" />
          </div>
          <span class="tiny"></span>
        </div>
        <div class="row profileHelperHidden">
          <label>헬퍼 상태</label>
          <div class="helperStatusLine" style="width:100%; display:flex; align-items:center; gap:10px;">
            <span id="helperStatusDot" class="helperDot off" aria-hidden="true"></span>
            <span id="helperStatusText" class="tiny" style="font-weight:900; letter-spacing:.2px;">미연결</span>
          </div>
          <span class="tiny">PC 활동 감지용 로컬 헬퍼가 켜져 있으면 ‘연결됨’으로 표시돼요.</span>
        </div>


        <div class="row profileHelperHidden">
          <label>헬퍼 모드</label>
          <div style="display:flex; gap:10px; width:100%; flex-wrap:wrap; align-items:center;">
            <select id="helperMode" style="width:170px; font-weight:1000;">
              <option value="manual">수동(안전)</option>
              <option value="auto">자동(연동)</option>
            </select>
            <span id="helperDebugText" class="tiny" style="font-weight:900; opacity:.9;"></span>
          </div>
          <span class="tiny">자동=무반응 시 휴식/자리비움 전환. 수동=버튼으로만 상태 변경(헬퍼는 표시/복귀만).</span>
        </div>

<div class="row autoSwitchRow profileHelperHidden" style="display:flex" aria-hidden="false">
          <label>자동 전환</label>
          <div style="display:flex; gap:10px; width:100%; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; justify-content:center; text-align:center; gap:8px;">
              <span class="tiny" style="min-width:86px; opacity:.9;">휴식(분)</span>
              <input id="autoBreakMin" type="number" min="1" max="180" value="10" style="width:76px" disabled>
            </div>
            <div style="display:flex; align-items:center; justify-content:center; text-align:center; gap:8px;">
              <span class="tiny" style="min-width:86px; opacity:.9;">자리비움(분)</span>
              <input id="autoIdleMin" type="number" min="1" max="180" value="15" style="width:76px" disabled>
            </div>
          </div>
          <span class="tiny">작업중일 때만 적용돼요. (기본: 10/15분)</span>
        </div>

<div class="row">
          <button id="applyProfile" class="ghost">저장</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Room Settings Modal (Admin) -->
  <div id="settingsModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">⚙️ 작업방 설정</div>
        <button id="closeSettings" class="ghost">닫기</button>
      </div>
      <div class="modalBody">
        <div class="hint">
          처음 설정하는 사람은 “관리자 비번”을 등록하고, 이후부터는 비번이 있어야 변경할 수 있어요.
        </div>

        <div class="row">
          <label>🔈 입장 소리</label>
          <div style="display:flex; align-items:center; gap:10px; width:100%;">
            <input id="sfxToggle" type="checkbox" />
            <span class="tiny">입장/재입장 시 소리 재생 (내 브라우저에서만 적용)</span>
          </div>
        </div>
        <div class="row">
          <input id="adminPass" type="password" placeholder="관리자 비번" />
          <button id="adminUnlock" class="primary tight">확인</button>
        </div>

        <div id="adminArea" style="display:none">
          <div class="hr"></div>
          <div class="hint">대시보드 링크(룸 공용)</div>
          <div class="row">
            <input id="pomoUrl" placeholder="⏰ 공용 뽀모 링크" />
            <input id="sudaUrl" placeholder="💣 폭파 수다 링크" />
          </div>
          <div class="row">
            <input id="choolUrl" placeholder="🔥 출근부 링크" />
            <input id="sheetUrl" placeholder="🔗 뽀모 시트 링크" />
          </div>
          <div class="row">
            <input id="dashApiUrl" placeholder="📡 대시보드 인원 API (Apps Script .../exec?api=counts&callback=cb)" />
          </div>
          <div class="row">
            <button id="saveDash" class="primary">저장</button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <div id="ctxMenu" class="ctxMenu hidden" role="menu" aria-hidden="true">
    <div class="title" id="ctxTitle">프로필</div>
    <button id="ctxKick" class="danger" type="button">🚫 강퇴</button>
    <button id="ctxClose" type="button">닫기</button>
  </div>

  <div id="toast" class="toast">저장했어!</div>

  
  <!-- Mission Modal -->
  <div id="missionModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="t">🎯 오늘의 미션</div>
        <button id="closeMission" class="ghost" type="button">닫기</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <label>미션</label>
          <input id="missionText" placeholder="예: 2000자 쓰기 / 25분 2세트" maxlength="60" style="flex:1">
        </div>
        <div class="row">
          <label>성공</label>
          <label style="display:flex;align-items:center;gap:10px; font-weight:900;">
            <input id="missionDone" type="checkbox" />
            오늘 미션 완료했어요 👑
          </label>
        </div>
        <div class="tiny" style="opacity:.8; line-height:1.4;">
          - 자정(KST)에 자동 초기화돼요.<br>
          - 성공 체크하면 버튼이 반짝 + 훈장 + 작은 폭죽!
        </div>
      </div>
      <div class="modalFooter">
        <button id="saveMission" class="primary" type="button">저장</button>
      </div>
    </div>
  </div>

  <!-- FX layer for fireworks -->
  <div id="fxLayer" aria-hidden="true"></div>

<script type="module">
    // BOOT FLAG (module ok)
    window.__MK_BOOT_OK__ = true;

    // -----------------------------
    // 고정 룸 아이디 (통일)
    // -----------------------------
    const FIXED_ROOM_ID = "magamm";
    // -----------------------------
    // ✅ 클라이언트 입장키(간이 게이트)
    // - 보안 "강화"용(완전 차단은 Firestore Rules/인증이 필요)
    // -----------------------------
    
    // ✅ 클라이언트 입장키(간이 게이트)
    // - GitHub에 '비밀번호(평문)'가 박히지 않게: 평문 대신 SHA-256 해시를 비교합니다.
    // - ⚠️ 정적 웹은 코드가 공개되므로 '완전 보안'은 불가. 진짜 차단은 Firebase Rules/인증이 필요합니다.
    const ROOM_PASS_HASH = "0a34102dc560b97344f99ed8369092fc9921804a4a6101118485ac946f0739e8"; // sha256("mkm1919")

    async function sha256Hex(str){
      const enc = new TextEncoder();
      const buf = await crypto.subtle.digest("SHA-256", enc.encode(str));
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
    }
    async function isRoomPassValid(pass){
      const p = (pass ?? "").toString().trim();
      if(!p) return false;
      try{
        const h = await sha256Hex(p);
        return h === ROOM_PASS_HASH;
      }catch(e){
        return false;
      }
    }

    

    // ✅ Root helpers (module 최상단) — 스코프 꼬임/중복 선언 방지
    function showToast(msg, ms=1600){
      try{
        const el = document.getElementById("toast");
        if(!el){ console.log("toast:", msg); return; }
        el.textContent = msg;
        el.classList.add("show");
        if(window.__toastTimer) clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(()=>el.classList.remove("show"), ms);
      }catch(e){
        console.log("toast:", msg);
      }
    }

    // ✅ 집중시간(24시간 누적, 자정 리셋) — 최상단 전역 유틸
    const __LS_FOCUS_DAY = "mk_focus_day";
    const __LS_FOCUS_SEC = "mk_focus_sec";
    function __seoulDateKey(){
      try{
        const now = new Date();
        const utc = now.getTime() + now.getTimezoneOffset()*60000;
        const kst = new Date(utc + 9*3600000);
        const y = kst.getFullYear();
        const m = String(kst.getMonth()+1).padStart(2,"0");
        const d = String(kst.getDate()).padStart(2,"0");
        return `${y}-${m}-${d}`;
      }catch(e){
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
      }
    }


    // ✅ (v4.2+) 매일 1회 '입장 공지' 팝업 (출근 유도)
    const __LS_DAILY_NOTICE_DAY = "mk_daily_notice_day_v1";
    function __dailyNoticeDayKey(){ try{ return __seoulDateKey(); }catch(e){ return ""; } }
    function __hasSeenDailyNoticeToday(){
      try{ return localStorage.getItem(__LS_DAILY_NOTICE_DAY) === __dailyNoticeDayKey(); }catch(e){ return false; }
    }
    function __markDailyNoticeSeen(){
      try{ localStorage.setItem(__LS_DAILY_NOTICE_DAY, __dailyNoticeDayKey()); }catch(e){}
    }
    function __isAnyModalOpen(){
      try{
        const open1 = document.querySelector('#attModal:not(.hidden)');
        const open2 = document.querySelector('#guideModal[aria-hidden="false"]');
        const open3 = document.querySelector('#profileModal[aria-hidden="false"]');
        const open4 = document.querySelector('#onlineModal[aria-hidden="false"]');
        const open5 = document.querySelector('#dailyNoticeModal:not(.hidden)');
        return !!(open1||open2||open3||open4||open5);
      }catch(e){ return false; }
    }
    function showDailyNotice(){
      const modal = document.getElementById("dailyNoticeModal");
      if(!modal) return;
      modal.classList.remove("hidden");
      modal.setAttribute("aria-hidden","false");
      try{ modal.inert = false; }catch(e){}
      // 포커스는 주요 버튼으로
      setTimeout(()=>{ try{ document.getElementById("dailyNoticeGoBtn")?.focus?.(); }catch(e){} },0);
    }
    function hideDailyNotice(markSeen=true){
      const modal = document.getElementById("dailyNoticeModal");
      if(!modal) return;
      if(markSeen) __markDailyNoticeSeen();
      try{ document.activeElement?.blur?.(); }catch(e){}
      modal.classList.add("hidden");
      modal.setAttribute("aria-hidden","true");
      try{ modal.inert = true; }catch(e){}
      // 포커스 복귀(출근 버튼 쪽)
      setTimeout(()=>{ try{ document.getElementById("checkInBtn")?.focus?.(); }catch(e){} },0);
    }
    function scheduleDailyNotice(){
      // 입장 후 UI/리스너 안정화 뒤에, 모달 충돌 없을 때만 띄운다(재시도)
      if(__hasSeenDailyNoticeToday()) return;
      let tries = 0;
      const tick = ()=>{
        tries++;
        if(__hasSeenDailyNoticeToday()) return;
        const st = (typeof state!=='undefined') ? state : (window.__mk_state||null);
        if(!st || !st.joined) return;
        if(__isAnyModalOpen()){
          if(tries < 8) return setTimeout(tick, 450);
          return;
        }
        showDailyNotice();
      };
      setTimeout(tick, 900);
    }


    // ✅ 출근(출석) 버튼 상태(로컬): 오늘 출근했는지 표시용
    const __LS_CHECKIN_DAY = "mk_checkin_day";
    let __lastCheckinUIKey = ""; // 날짜 바뀔 때 UI 갱신

    function __isCheckedInToday(){
      try{
        const today = __seoulDateKey();
        return (localStorage.getItem(__LS_CHECKIN_DAY) || "") === today;
      }catch(e){ return false; }
    }
    function __markCheckedInToday(){
      try{ localStorage.setItem(__LS_CHECKIN_DAY, __seoulDateKey()); }catch(e){}
    }
    function __applyCheckInBtnUI(btn){
      if(!btn) return;
      const done = __isCheckedInToday();
      if(done){
        btn.textContent = "✅출근완료";
        btn.classList.add("checkinDone");
        btn.classList.remove("checkinPulse");
        btn.setAttribute("data-checkin","done");
      }else{
        btn.textContent = "💌출근💌";
        btn.classList.remove("checkinDone");
        btn.classList.add("checkinPulse");
        btn.setAttribute("data-checkin","need");
      }
    }

    function focusLoadSeconds(){
      const today = __seoulDateKey();
      try{
        const day = localStorage.getItem(__LS_FOCUS_DAY) || "";
        const sec = Number(localStorage.getItem(__LS_FOCUS_SEC) || 0);
        if(day !== today){
          localStorage.setItem(__LS_FOCUS_DAY, today);
          localStorage.setItem(__LS_FOCUS_SEC, "0");
          return 0;
        }
        return isFinite(sec) ? Math.max(0, sec) : 0;
      }catch(e){
        return 0;
      }
    }
    function focusSaveSeconds(sec){
      const today = __seoulDateKey();
      try{
        localStorage.setItem(__LS_FOCUS_DAY, today);
        localStorage.setItem(__LS_FOCUS_SEC, String(Math.max(0, Math.floor(Number(sec)||0))));
      }catch(e){}
    }

    function getRemoteMissionInfoByName(name){
      try{
        const n = String(name||"").trim();
        if(!n) return null;
        const mp = state.missionLastByName;
        if(!mp || !(mp instanceof Map)) return null;
        return mp.get(n) || null;
      }catch(e){ return null; }
    }
    function updateMissionBtnForTile(btn, p){
      try{
        if(!btn) return;
        const isMe = (btn.dataset.me==="1") || ((btn.dataset.owner||"") && state.uid && (btn.dataset.owner===state.uid));
        btn.classList.remove("isHot","isDone");
        btn.textContent = "";

        // ✅ 미션 버튼: 내 것만 노출 (상대방 버튼은 숨김)
        if(!isMe){
          btn.style.display = "none";
        }else{
          btn.style.display = "flex";
        }

        const today = seoulDateKey();

        // --- 내 타일 ---
        if(isMe){
          const m = state.myMission || loadMissionLocal();
          if(m && m.done){
            btn.classList.add("isDone");
            btn.textContent = "👑";
            btn.title = `미션 성공! ${m.text||""}`.trim();
            btn.setAttribute("aria-label", `미션 성공: ${m.text||"오늘의 미션"}`);
          }else{
            btn.classList.add("isHot");
            const text = (m && m.text) ? String(m.text) : "";
            btn.title = text ? `오늘의 미션: ${text}` : "오늘의 미션 설정하기";
            btn.setAttribute("aria-label", text ? `오늘의 미션: ${text}` : "오늘의 미션 설정하기");
          }
          return;
        }

        // --- 다른 사람 타일 ---
        // 상대방 미션 버튼은 숨김 (이펙트/메달 표시는 별도 로직 유지)
        return;


        // fallback: mission 이벤트 기반
        const info = getRemoteMissionInfoByName(fullName);
        if(info && info.action==="done"){
          btn.classList.add("isDone");
          /* ❣ 상시 표시(상대방) */
          btn.title = info.text ? `${fullName} 미션 성공! ${info.text}` : `${fullName} 미션 성공!`;
          btn.setAttribute("aria-label", info.text ? `${fullName} 미션 성공: ${info.text}` : `${fullName} 미션 성공`);
        }else if(info && info.text){
          btn.classList.add("isHot");
          btn.title = `${fullName} 오늘의 미션: ${info.text}`;
          btn.setAttribute("aria-label", `${fullName} 오늘의 미션: ${info.text}`);
        }else{
          btn.title = `${fullName} 아직 미션 없음`;
          btn.setAttribute("aria-label", `${fullName} 아직 미션 없음`);
        }
      }catch(e){}
    }

    function refreshAllMissionButtons(){
      try{
        document.querySelectorAll(".missionBtn").forEach(btn=>{
          const owner = btn.dataset.owner || "";
          const p = (owner && state.currentParticipants && state.currentParticipants.get)
            ? (state.currentParticipants.get(owner) || null)
            : null;
          updateMissionBtnForTile(btn, p || { id: owner, name: btn.dataset.name || "" });
        });
      }catch(e){}
    }

    // ✅ 이름으로 타일 엘리먼트 찾기(폭죽/메달 표시용)

    function findTileElByName(name){
      try{
        const n = String(name||"").trim();
        if(!n) return null;
        const esc = (window.CSS && CSS.escape) ? CSS.escape(n) : n.replace(/["\\]/g, "\\$&");
        return document.querySelector(`.tile[data-name="${esc}"]`);
      }catch(e){ return null; }
    }
    // ✅ 타일 메달(👑) 표시 업데이트 — 미니모드에서도 보이게
    function updateMissionMedalForTile(medalEl, p){
      try{
        if(!medalEl) return;

        const fullName = normalizeNick(p?.name || p?.id || "");
        const isMe = (p && p.id && state.uid) ? (p.id === state.uid) : false;

        const today = seoulDateKey();
        let done = false;
        let text = "";

        if(isMe){
          const m = state.myMission || loadMissionLocal();
          done = !!(m && m.done);
          text = String(m?.text||"").trim();
        }else if(p && p.mission && String(p.mission.dayKey||"") === String(today)){
          done = !!p.mission.done;
          text = String(p.mission.text||"").trim();
        }else{
          // fallback: mission 이벤트 기반
          const info = getRemoteMissionInfoByName(fullName);
          done = !!(info && info.action==="done");
          text = String(info?.text||"").trim();
        }

        medalEl.textContent = "👑";
        medalEl.title = done
          ? (text ? `${fullName} 미션 성공! ${text}` : `${fullName} 미션 성공!`)
          : (text ? `${fullName} 오늘의 미션: ${text}` : `${fullName} 미션 미완료`);
        medalEl.classList.toggle("hidden", !done);
      }catch(e){}
    }

    function refreshAllMissionMedals(){

      try{
        for(const [uid, rec] of state.lastRendered.entries()){
          if(!rec?.el) continue;
          const p = state.currentParticipants.get(uid);
          if(!p) continue;
          const medal = rec.el.querySelector(".missionMedal");
          updateMissionMedalForTile(medal, p);
        }
      }catch(e){}
    }

    function persistMyFocusToLocal(){
      try{ focusSaveSeconds((state && state.focusSecondsTotal) || 0); }catch(e){}
    }

const PASS_TTL_MS = 24 * 60 * 60 * 1000; // 24h
    const LS_PASS = "mk_room_pass";
    const LS_PASS_EXP = "mk_room_pass_exp";
    const LS_PASS_OK = "mk_room_pass_ok";
    const LS_PROFILE = "mk_profile_pref_v1";

    // ✅ 집중시간(24시간 누적, 자정 리셋)
    const LS_FOCUS_DAY = "mk_focus_day";
    const LS_FOCUS_SEC = "mk_focus_sec";

    // ✅ 대시보드 실시간 API 기본값
    // - 설정에서 비워도 이 값으로 자동 사용
    const DEFAULT_DASH_API_URL = ""; // (기본값 비움) 통합 counts API를 쓰려면 설정에서 입력

    // ✅ 로컬 헬퍼(PC 전역 활동)용 Realtime Database
    const RTDB_BASE_URL = "https://magamm00-5baee-default-rtdb.asia-southeast1.firebasedatabase.app";


    let els = {};
    // -----------------------------
    // ✅ Tile layout modes (default / compact5)
    // -----------------------------
    const LS_LAYOUT_MODE = "mk_layout_mode_v1";
    function getLayoutMode(){
      try{ return localStorage.getItem(LS_LAYOUT_MODE) || "default"; }catch(e){ return "default"; }
    }
    function setLayoutMode(mode){
      try{ localStorage.setItem(LS_LAYOUT_MODE, mode); }catch(e){}
    }
    function applyLayoutMode(mode){
      const g = els.grid;
      if(!g) return;
      if(mode === "compact5"){
        g.classList.add("compact5");
      }else{
        g.classList.remove("compact5");
        mode = "default";
      }
      // Button label
      if(els.layoutToggleBtn){
        els.layoutToggleBtn.textContent = (mode === "compact5") ? "기본 보기" : "미니 보기";
      }
    }
    function toggleLayoutMode(){
      const cur = getLayoutMode();
      const next = (cur === "compact5") ? "default" : "compact5";
      setLayoutMode(next);
      applyLayoutMode(next);
    }
    

    function loadPassOK(){
      try{
        const ok = (localStorage.getItem(LS_PASS_OK) === "1");
        const exp = Number(localStorage.getItem(LS_PASS_EXP) || 0);
        if(ok && exp && Date.now() <= exp){
          document.body.classList.add("passok");
          return true;
        }
        // 만료/깨짐이면 정리
        if(exp && Date.now() > exp){
          localStorage.removeItem(LS_PASS_OK);
          localStorage.removeItem(LS_PASS_EXP);
        }
      }catch(e){}
      return false;
    }

function savePassOK(pass){
      try{
        // 🔒 평문은 '내 컴퓨터 로컬'에만 저장(재입력 귀찮음 방지)
        localStorage.setItem(LS_PASS, String(pass || ""));
        localStorage.setItem(LS_PASS_OK, "1");
        localStorage.setItem(LS_PASS_EXP, String(Date.now() + PASS_TTL_MS));
      }catch(e){}
      document.body.classList.add("passok");
      try{ if(els.roomPass) els.roomPass.value = ""; }catch(e){}
    }

    function clearPassOK(){
      try{
        localStorage.removeItem(LS_PASS);
        localStorage.removeItem(LS_PASS_OK);
        localStorage.removeItem(LS_PASS_EXP);
      }catch(e){}
      document.body.classList.remove("passok");
    }

async function requirePassOK(){
      if(loadPassOK()) return true;
      const typed = (els.roomPass?.value || "").trim();
      let stored = "";
      try{ stored = (localStorage.getItem(LS_PASS) || "").trim(); }catch(e){}

      if(typed){
        const ok = await isRoomPassValid(typed);
        if(!ok){
          showToast("입장키를 다시 확인해줘!", 2500);
          try{ els.roomPass?.focus(); }catch(e){}
          return false;
        }
        savePassOK(typed);
        return true;
      }

      if(stored){
        const ok = await isRoomPassValid(stored);
        if(ok){
          savePassOK(stored);
          return true;
        }
      }

      showToast("입장키를 입력해줘!", 2500);
      try{ els.roomPass?.focus(); }catch(e){}
      return false;
    }

function loadLocalProfile(){
      try{
        const raw = localStorage.getItem(LS_PROFILE);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || typeof obj !== "object") return null;
        return obj;
      }catch(e){ return null; }
    }
    function saveLocalProfile(obj){
      try{
        localStorage.setItem(LS_PROFILE, JSON.stringify(obj || {}));
      }catch(e){}
    }


    // -----------------------------
    // Firebase 설정 (여기만 본인 값으로 교체)
    // -----------------------------
   const firebaseConfig = {
    apiKey: "AIzaSyAmhsxF7syCPNfgIVb2ZIQBxgGV_rZ2nDI",
    authDomain: "magamm00-5baee.firebaseapp.com",
    projectId: "magamm00-5baee",
    storageBucket: "magamm00-5baee.firebasestorage.app",
    messagingSenderId: "829544685832",
    appId: "1:829544685832:web:7ae0a5a2cd48cb62a6ccbd",
    measurementId: "G-CFQ6KZ7R7B",
    databaseURL: "https://magamm00-5baee-default-rtdb.asia-southeast1.firebasedatabase.app"
  };

    // Firebase imports (CDN)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc,
      collection, onSnapshot, serverTimestamp, addDoc, query, orderBy, limit, runTransaction
    , enableIndexedDbPersistence, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";
    import {
      getDatabase, ref as rRef, child as rChild, set as rSet, update as rUpdate, get as rGet, remove as rRemove,
      push as rPush, onValue as rOnValue, onChildAdded as rOnChildAdded, onChildChanged as rOnChildChanged, off as rOff, onDisconnect as rOnDisconnect,
      query as rQuery, orderByChild as rOrderByChild, startAt as rStartAt, endAt as rEndAt, limitToLast as rLimitToLast, runTransaction as rRunTransaction,
      serverTimestamp as rServerTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

; (async ()=>{


    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    
    // ✅ Offline cache (reduces repeated network reads; may be blocked in multi-tab)
    /* Firestore persistence disabled (not needed). */
const auth = getAuth(app);
    const storage = getStorage(app);
    const rtdb = getDatabase(app, firebaseConfig.databaseURL);

    // DOM
    const $ = (id) => document.getElementById(id);
    els = {
      name: $("name"),
      roomPass: $("roomPass"),
      joinBtn: $("joinBtn"),
      leaveBtn: $("leaveBtn"),
      menuBtn: $("menuBtn"),
      grid: $("grid"),
      countOnline: $("countOnline"),
      approxOnlineText: $("approxOnlineText"),
      lastSync: $("lastSync"),
      nowClockMain: $("nowClockMain"),
      layoutToggleBtn: $("layoutToggleBtn"),
      guideBtn: $("guideBtn"),
      dataSaverBtn: $("dataSaverBtn"),

      ctxMenu: $("ctxMenu"),
      ctxTitle: $("ctxTitle"),
      ctxKick: $("ctxKick"),
      ctxClose: $("ctxClose"),

      dashUpdated: $("dashUpdated"),
      pomoCount: $("pomoCount"),
      sudaCount: $("sudaCount"),
      pomoOk: $("pomoOk"),
      sudaOk: $("sudaOk"),
      goPomo: $("goPomo"),
      goPomoMini: $("goPomoMini"),
      goSudaMini: $("goSudaMini"),
      statusRosterList: $("statusRosterList"),
      goSuda: $("goSuda"),
      goChool: $("goChool"),
      goSheet: $("goSheet"),
      goMacHelper: $("goMacHelper"),
      goWinHelper: $("goWinHelper"),

      chatList: $("chatList"),
      chatNewBar: $("chatNewBar"),
      chatJumpBtn: $("chatJumpBtn"),
      chatUnseenCount: $("chatUnseenCount"),
      chatInput: $("chatInput"),
      sendBtn: $("sendBtn"),
      embedBar: $("embedBar"),
      embedTitle: $("embedTitle"),
      embedOpen: $("embedOpen"),
      embedClose: $("embedClose"),
      embedFrame: $("embedFrame"),
      embedModal: $("embedModal"),
      closeEmbedModal: $("closeEmbedModal"),
      embedModalTitle: $("embedModalTitle"),
      embedModalOpen: $("embedModalOpen"),
      embedModalFrame: $("embedModalFrame"),

      guideModal: $("guideModal"),
      closeGuide: $("closeGuide"),

      onlineModal: $("onlineModal"),
      closeOnline: $("closeOnline"),
      onlineList: $("onlineList"),

      btnWork: $("btnWork"),
      btnBreak: $("btnBreak"),
      btnIdle: $("btnIdle"),
      btnTimerReset: $("btnTimerReset"),
      checkInBtn: $("checkInBtn"),
      statusBtn: $("statusBtn"),
      statusMenu: $("statusMenu"),
      btnHelperToggle: $("btnHelperToggle"),
      modeAutoBtn: $("modeAutoBtn"),
      modeManualBtn: $("modeManualBtn"),
      autoOpts: $("autoOpts"),
      manualOpts: $("manualOpts"),
      autoBreakMinTop: $("autoBreakMinTop"),
      autoIdleMinTop: $("autoIdleMinTop"),
      profileBtn: $("profileBtn"),
      guideBtn: $("guideBtn"),
      
      railFoldToggle: $("railFoldToggle"),
      railEdgeBtn: $("railEdgeBtn"),
onlineBtn: $("onlineBtn"),
      meHint: $("meHint"),

      profileModal: $("profileModal"),
      closeProfile: $("closeProfile"),
      emoji: $("emoji"),
      emojiBgPicker: $("emojiBgPicker"),
      emojiBgColor: $("emojiBgColor"),
      emojiBgTransparent: $("emojiBgTransparent"),
      emojiSize: $("emojiSize"),
      emojiSizeNum: $("emojiSizeNum"),
      photoSize: $("photoSize"),
      photoSizeNum: $("photoSizeNum"),
      swatches: $("swatches"),
      bgPicker: $("bgPicker"),
      bgColor: $("bgColor"),
      bgPattern: $("bgPattern"),
      patternPicker: $("patternPicker"),
      patternColor: $("patternColor"),
      bubbleText: $("bubbleText"),
      bubblePicker: $("bubblePicker"),
      bubbleColor: $("bubbleColor"),
      timePicker: $("timePicker"),
      timeColor: $("timeColor"),
      nameColorPicker: $("nameColorPicker"),
      nameColor: $("nameColor"),
      chatNameColorPicker: $("chatNameColorPicker"),
      chatNameColor: $("chatNameColor"),
      statusTextColorPicker: $("statusTextColorPicker"),
      statusTextColor: $("statusTextColor"),
      bubbleTextColorPicker: $("bubbleTextColorPicker"),
      bubbleTextColor: $("bubbleTextColor"),
      helperStatusDot: $("helperStatusDot"),
      helperStatusText: $("helperStatusText"),
      helperTopDot: $("helperTopDot"),
      helperTopText: $("helperTopText"),
      helperMode: $("helperMode"),
      helperDebugText: $("helperDebugText"),
      photoEnabled: $("photoEnabled"),
      photoUploadRow: $("photoUploadRow"),
      photoSizeRow: $("photoSizeRow"),
      photoFile: $("photoFile"),
      uploadPhotoBtn: $("uploadPhotoBtn"),
      profileNick: $("profileNick"),
      autoBreakMin: $("autoBreakMin"),
      autoIdleMin: $("autoIdleMin"),
      applyProfile: $("applyProfile"),

      dashboardCard: $("dashboardCard"),
      chatCard: $("chatCard"),

      settingsModal: $("settingsModal"),
      closeSettings: $("closeSettings"),
      sfxToggle: $("sfxToggle"),
      adminPass: $("adminPass"),
      adminUnlock: $("adminUnlock"),
      adminArea: $("adminArea"),
      pomoUrl: $("pomoUrl"),
      sudaUrl: $("sudaUrl"),
      choolUrl: $("choolUrl"),
      sheetUrl: $("sheetUrl"),
      saveDash: $("saveDash"),

      toast: $("toast"),
    };
    // ✅ 휴식중 버튼: 기본 아이콘(상단바에는 연기 없음, 타일에서만 연기)
    try{
      if(els.btnBreak) els.btnBreak.textContent = "☕ 휴식중";
    }catch(e){}


    // ✅ 오른쪽 사이드 접기/펼치기 초기화
    try{ initRailFold(); }catch(e){}


    
    function isConfigPlaceholder(v){
      return typeof v === "string" && (v.startsWith("YOUR_") || v.includes("YOUR_PROJECT"));
    }
    function validateFirebaseConfig(){
      const missing = [];
      if(!firebaseConfig || typeof firebaseConfig !== "object"){ missing.push("firebaseConfig"); return missing; }
      const keys = ["apiKey","authDomain","projectId","storageBucket"];
      for(const k of keys){
        const v = firebaseConfig[k];
        if(!v || isConfigPlaceholder(v)) missing.push(k);
      }
      return missing;
    }
    function friendlyAuthHint(code){
      if(!code) return "";
      if(code.includes("auth/operation-not-allowed")) return "➡️ Firebase Authentication에서 '익명(Anonymous)' 로그인 활성화가 필요해.";
      if(code.includes("auth/invalid-api-key")) return "➡️ firebaseConfig의 apiKey가 잘못됐어.";
      if(code.includes("auth/invalid-credential")) return "➡️ firebaseConfig가 프로젝트와 맞는지 확인해줘.";
      if(code.includes("auth/network-request-failed")) return "➡️ 네트워크/방화벽 문제일 수 있어. 다른 네트워크로도 테스트해봐.";
      return "";
    }

    const state = {
      myMission: null,
      uid: null,
      roomId: FIXED_ROOM_ID,
      sfxEnabled: true,
      unsubParticipants: null,
      _lastDayKey: null,
      unsubRoom: null,
      unsubChat: null,
            focusPersistTimer: null,
      didFocusMerge: false,
      sfxInitDone: false,
      chatScrollLockUntil: 0,
      lastSfxTs: 0,
chatUnseen: 0,
      chatUserNearBottom: true,

      unsubKick: null,
      unsubMissions: null,
      missionDayKey: null,
      missionSuccessCount: 0,
      tickTimer: null,
      hbTimer: null,
      currentParticipants: new Map(),
      // 🔋 reads saver
      nonChatEnabled: true,
      nonChatPausedByHidden: false,
      nonChatPollTimer: null,

      myPhotoUrl: "",
      adminOk: false,
      adminHash: null,
      roomSettings: {
        dashboard: {pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL},
        dashCounts: {pomoCount:null, sudaCount:null, updatedAtMs:null},
        adminHash: null
      },
      localDashCounts: {pomoCount:null, sudaCount:null, updatedAtMs:null},
      dashPollTimer: null,
      dashPollUrl: "",
      lastRendered: new Map(),
      lastActivityMs: Date.now(),
      helperWatchTimer: null,
      helperActive: false,
      _prevHelperActive: false,
      helperLastTs: 0,
      helperLastSeenMs: 0,
      helperMode: 'manual',
      helperIdleSec: null,
      helperIdleSecPresent: false,
      helperIdleZeroStreak: 0,
      _helperInactiveSinceMs: 0,
      activityWatchTimer: null,
      activityThrottleMs: 0,
      joined: false,
      ctxTarget: { uid:null, name:null },

    };
    window.__mk_state = state;

    // Helpers

    // ✅ Nickname rules
    const NICK_MAX = 7;
    function normalizeNick(raw){
      const s = (raw ?? "").toString().trim().replace(/\s+/g, "");
      const arr = Array.from(s);
      return arr.slice(0, NICK_MAX).join("");
    }
    function miniNick(raw){
      const s = normalizeNick(raw);
      const arr = Array.from(s);
      if(arr.length <= 3) return s;
      return arr.slice(0, 3).join("") + "…";
    }

    function shortNick(raw, maxChars=4){
      const s = normalizeNick(raw);
      const arr = Array.from(s);
      if(arr.length <= maxChars) return s;
      return arr.slice(0, maxChars).join("") + "…";
    }


    

    function setMyNickUI(nick){
      try{
        const n = normalizeNick(nick);
        state.nickname = n;
        try{ if(els.name && els.name.value !== n) els.name.value = n; }catch(e){}
        if(!n) return;
        // 상단 닉네임 pill (있다면)
        if(els.nickPill) els.nickPill.textContent = n;
        // 참가자 목록/타일은 Firestore 업데이트로 자동 반영되지만,
        // 로컬 state에도 반영해두면 즉시 표시가 자연스러움
      }catch(e){}
    }
function toast(msg, ms=1600){
      try{
        els.toast.textContent = msg;
        els.toast.classList.add("show");
        if(window.__toastTimer) clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(()=>els.toast.classList.remove("show"), ms);
      }catch(e){
        console.log("toast:", msg);
      }
    }

    // onSnapshot 연결이 룰/권한 문제로 터져도 입장 자체가 죽지 않게 보호
    function safeOnSnapshot(refOrQuery, next){
      try{
        return onSnapshot(refOrQuery, next, (err)=>{
          console.warn('onSnapshot error', err);
        });
        // ✅ 내 전송 직후 바닥으로 이동(점프 최소화)
        try{ els.chatList.scrollTop = els.chatList.scrollHeight; }catch(e){}
      }catch(err){
        console.warn('onSnapshot attach failed', err);
        return ()=>{};
      }
    }


    // --- 우클릭 컨텍스트 메뉴 ---
    function hideCtxMenu(){
      if(!els.ctxMenu) return;
      els.ctxMenu.classList.add("hidden");
      els.ctxMenu.setAttribute("aria-hidden","true");
      state.ctxTarget = {uid:null, name:null};
    }
    function openCtxMenu(x, y, p){
      if(!els.ctxMenu) return;
      state.ctxTarget = { uid: p.id, name: p.name || p.id };
      els.ctxTitle.textContent = `${state.ctxTarget.name}`;
      const canKick = !!(state.joined && state.uid && p.id && p.id !== state.uid);
      els.ctxKick.disabled = !canKick;

      const m = els.ctxMenu;
      m.classList.remove("hidden");
      m.setAttribute("aria-hidden","false");

      // 위치: 화면 밖으로 튀지 않게 보정
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      m.style.left = "0px"; m.style.top = "0px";
      const rect = m.getBoundingClientRect();
      let left = x, top = y;
      if(left + rect.width + 10 > vw) left = Math.max(10, vw - rect.width - 10);
      if(top + rect.height + 10 > vh) top = Math.max(10, vh - rect.height - 10);
      left = Math.max(10, left);
      top = Math.max(10, top);
      m.style.left = `${left}px`;
      m.style.top = `${top}px`;
    }

    const KICK_BLOCK_MS = 2 * 60 * 60 * 1000; // 2시간 재입장 차단(원하면 조절 가능)

    async function requestKick(targetUid, targetName){
      if(!state.roomId || !state.uid || !targetUid) return;
      try{
        const now = Date.now();

        await setDoc(kickRef(state.roomId, targetUid), {
          kickedAtMs: now,
          expiresAtMs: now + KICK_BLOCK_MS,
          byUid: state.uid,
          byName: (els.meHint?.textContent || "익명"),
          targetName: targetName || ""
        }, {merge:true});
        showToast("🚫 강퇴 처리했어");
      }catch(e){
        // ✅ (v3.3) 이미 joined=true까지 갔다가 중간 초기화(채팅/리스너 등)에서 터진 경우에도 출석 자동팝업은 살린다
        try{ if(state && state.joined){ setTimeout(()=>{ try{ autoOpenAttendanceIfNeeded(); }catch(_e){} }, 0); } }catch(_e){}
        console.error(e);
        showToast("강퇴 실패(권한/룰 확인)");
      }
    }

    function subscribeKicks(){
      // 🔕 Firestore kick-listener disabled (prevents onSnapshot permission errors).
      // If you need kick/ban later, we can migrate kicks to RTDB or add Firestore rules safely.
      return;
      if(state.unsubKick) state.unsubKick();
      state.unsubKick = null;
      if(!state.roomId || !state.uid) return;

      // 룰에 /kicks 매치가 없으면 여기서 권한 에러가 날 수 있어.
      // 그 경우에도 입장/채팅 등 나머지는 정상 동작하도록 '안전'하게 붙인다.
      state.unsubKick = safeOnSnapshot(kickRef(state.roomId, state.uid), (snap)=>{
        if(!snap.exists()) return;
        const k = snap.data() || {};
        const exp = Number(k.expiresAtMs || 0);
        const now = Date.now();
        if(exp && exp < now) return; // 만료
        const by = k.byName || "누군가";
        if(state.joined){
          showToast(`🚫 ${by}님이 강퇴했어`);
          setTimeout(()=>{ if(state.joined) leaveRoom(); }, 350);
        }
      });
    }

    function pad2(n){ return String(n).padStart(2,"0"); }
    function fmtHMS(sec){
      sec = Math.max(0, Math.floor(sec || 0));
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec%60;
      return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
    }
    function nowTimeStr(withSeconds=true){
      const opt = withSeconds ? { timeZone: "Asia/Seoul", hour:"2-digit", minute:"2-digit", second:"2-digit", hour12:false }
                              : { timeZone: "Asia/Seoul", hour:"2-digit", minute:"2-digit", hour12:false };
      return new Intl.DateTimeFormat("ko-KR", opt).format(new Date());
    }
    function updateClocks(){
      const tFull = nowTimeStr(true);
      const tShort = nowTimeStr(true);
      if(els.lastSync) els.lastSync.textContent = tFull;
      if(els.nowClockMain) els.nowClockMain.textContent = tShort;
      // ✅ 날짜가 바뀌면 출근 버튼 상태도 갱신
      try{
        const dk = __seoulDateKey();
        if(dk !== __lastCheckinUIKey){
          __lastCheckinUIKey = dk;
          if(els.checkInBtn) __applyCheckInBtnUI(els.checkInBtn);
        }
      }catch(e){}
    }

    
    // -----------------------------
    // ✅ 오늘의 미션(로컬 저장 + 자정 리셋)
    // -----------------------------
    const MK_MISSION_KEY = "mk_mission_v1";
    function loadMissionLocal(){
      try{
        const raw = localStorage.getItem(MK_MISSION_KEY);
        if(!raw) return { dayKey:"", text:"", done:false, doneAt:"" };
        const obj = JSON.parse(raw);
        return {
          dayKey: (obj.dayKey||"").toString(),
          text: (obj.text||"").toString(),
          done: !!obj.done,
          doneAt: (obj.doneAt||"").toString()
        };
      }catch(e){
        return { dayKey:"", text:"", done:false, doneAt:"" };
      }
    }
    function saveMissionLocal(m){
      try{ localStorage.setItem(MK_MISSION_KEY, JSON.stringify(m||{})); }catch(e){}
    }
    function openMissionModal(){
  try{
    const overlay = document.getElementById("missionModal");
    if(!overlay) return;

    // ✅ a11y: 모달 열기 전 포커스 기억
    state._missionReturnFocus = document.activeElement;

    const dayKey = seoulDateKey();
    const cur = state.myMission || loadMissionLocal();
    if(cur.dayKey !== dayKey){
      state.myMission = { dayKey, text:"", done:false, doneAt:"" };
      saveMissionLocal(state.myMission);
    }else{
      state.myMission = cur;
    }

    const txt = document.getElementById("missionText");
    const chk = document.getElementById("missionDone");
    if(txt) txt.value = (state.myMission?.text||"");
    if(chk) chk.checked = !!state.myMission?.done;

    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");
    try{ overlay.inert = false; }catch(e){}

    // ✅ 모달 내부로 포커스 이동
    setTimeout(()=>{ try{ (txt || chk || overlay).focus?.(); }catch(e){} }, 0);
  }catch(e){}
}
function closeMissionModal(){
  try{
    const overlay = document.getElementById("missionModal");
    if(!overlay) return;

    // ✅ a11y: aria-hidden 하기 전에 포커스가 모달 안에 남아있으면 먼저 빼기
    try{
      const active = document.activeElement;
      if(active && overlay.contains(active)){
        active.blur?.();
      }
    }catch(e){}

    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden","true");
    try{ overlay.inert = true; }catch(e){}

    // ✅ 열기 전 포커스로 복귀
    try{
      const ret = state._missionReturnFocus;
      if(ret && typeof ret.focus === "function") ret.focus();
    }catch(e){}
    state._missionReturnFocus = null;
  }catch(e){}
}

    function setMissionButtonState(){
      try{
        const btn = document.querySelector(".missionBtn[data-me=\"1\"]");
        if(!btn) return;
        const m = state.myMission || loadMissionLocal();
        btn.classList.remove("isHot","isDone");
        btn.textContent = "";
        if(m.done){
          btn.classList.add("isDone");
          btn.textContent = "👑";
          btn.title = `미션 성공! ${m.text||""}`.trim();
          btn.setAttribute("aria-label", `미션 성공: ${m.text||"오늘의 미션"}`);
        }else{
          btn.classList.add("isHot");
          btn.title = m.text ? `오늘의 미션: ${m.text}` : "오늘의 미션 설정하기";
          btn.setAttribute("aria-label", m.text ? `오늘의 미션: ${m.text}` : "오늘의 미션 설정하기");
        }
      }catch(e){}
    }
    
    // -----------------------------
// ✅ 오늘의 미션(원격 동기화) — Firestore Rules 건드리지 않고 동기화
//    ❗/missions 서브컬렉션은 룰에 막혀서(권한 오류) 채팅 컬렉션에 '미션 이벤트'를 남기는 방식으로 전환
//    - rooms/{roomId}/messages 에 type:"mission" 이벤트를 기록
//    - 성공 인원은 최근 N개의 메시지에서 오늘(dayKey) 미션 이벤트를 집계(닉네임 기준)
//    - 로그아웃/재입장해도 메시지는 남으니 카운트 유지
//    - 자정(KST) 지나면 dayKey가 바뀌어 자동 리셋
// -----------------------------
function renderMissionSuccessCount(n){
  try{
    const el = document.getElementById("missionSuccessCount");
    if(el) el.textContent = String(Number(n||0));
  }catch(e){}
}

function openMissionListModal(){
  try{
    const body = document.getElementById("missionListBody");
    const modal = document.getElementById("missionListModal");
    if(!body || !modal) return;

    const map = state.missionLastByName;
    const done = [];
    if(map && typeof map.entries === "function"){
      for(const [name, v] of map.entries()){
        if(v && v.action === "done"){
          done.push({ name, text: String(v.text||"").trim() });
        }
      }
    }
    done.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));

    body.textContent = done.length
      ? done.map((d,i)=> `${i+1}. ${d.name}${d.text ? " — " + d.text : ""}`).join("\n")
      : "아직 아무도 미션을 완료하지 않았어요 🥲";

    showModal(modal);
  }catch(e){}
}


function buildMissionEvent(action, m){
  const name = (state.nickname || els.name?.value || "").trim();
  const dayKey = (m?.dayKey) || seoulDateKey();
  return {
    type: "mission",
    action: action || "done",              // "set" | "done" | "undo"
    dayKey,
    name: name || "익명",
    text: (m?.text || "").trim().slice(0, 60),
    uid: state.uid || null,
    tsMs: Date.now()
  };
}

async function emitMissionEvent(action, m){
  // ✅ RTDB로 마이그레이션: /missions/{dayKey}/{uid} 에 성공만 저장(+내 presence.mission도 업데이트)
  try{
    if(!state.roomId || !state.uid) return;
    const name = (state.nickname || els.name?.value || "").trim();
    if(!name) return;

    const dayKey = (m?.dayKey) || seoulDateKey();
    const text = (m?.text || "").trim().slice(0,60);

    // 내 미션(로컬/프리즌스) 업데이트
    const cur = state.myMission || loadMissionLocal();
    const merged = {
      dayKey,
      text: text || (cur.text||""),
      done: (String(action||"done") === "done"),
      doneAt: (String(action||"done") === "done") ? (cur.doneAt || new Date().toISOString()) : ""
    };
    if(String(action||"set")==="set"){
      merged.done = !!cur.done;
      merged.doneAt = cur.doneAt || "";
    }
    state.myMission = merged;
    saveMissionLocal(merged);
    try{ setMissionButtonState(); }catch(e){}

    // presence에 반영(타일 크라운/버튼)
    try{
      await rUpdate(rMePresenceRef(state.roomId, state.uid), {
        mission: merged,
        updatedAt: Date.now(),
        lastSeenAtMs: Date.now()
      });
    }catch(e){}

    // 성공 명단은 missions에만 저장
    const node = rRef(rtdb, `${rRoomBase(state.roomId)}/missions/${dayKey}/${state.uid}`);
    if(String(action||"done")==="done"){
      await rSet(node, { uid: state.uid, name: normalizeNick(name), text, doneAtMs: Date.now() });
    }else if(String(action||"undo")==="undo"){
      await rRemove(node);
    }else{
      // set만 한 경우: 성공명단은 건드리지 않음
    }
  }catch(e){
    console.warn("[mission] write failed", e);
    // UX는 유지 (로컬은 이미 저장됨)
  }
}

function subscribeMissionFeed(){
  try{
    if(state.unsubMissionFeed) state.unsubMissionFeed();
    state.unsubMissionFeed = null;

    const dayKey = seoulDateKey();
    state.missionDayKey = dayKey;
    if(!state.roomId) return;
    if(!state.nonChatEnabled) return;

    const mref = rMissionsRootRef(state.roomId, dayKey);
    const onM = (snap)=>{
      const v = (snap && snap.val) ? (snap.val() || {}) : {};
      const prevLastByName = state.missionLastByName;

      const bestByName = new Map();
      for(const [uid, info] of Object.entries(v)){
        if(!info) continue;
        const name = (typeof normalizeNick==="function") ? normalizeNick(info.name||"") : String(info.name||"").trim();
        if(!name) continue;
        bestByName.set(name, { action:"done", text: String(info.text||"").trim(), tsMs: Number(info.doneAtMs||0) });
      }

      let doneCount = 0;
      for(const vv of bestByName.values()){
        if(vv && vv.action==="done") doneCount++;
      }

      state.missionLastByName = bestByName;
      state.missionSuccessCount = doneCount;
      renderMissionSuccessCount(doneCount);
      refreshAllMissionButtons();
      refreshAllMissionMedals();

      // 폭죽: 새로 done된 사람만 1회
      try{
        const prevMap = (prevLastByName && (prevLastByName instanceof Map)) ? prevLastByName : new Map();
        for(const [n, info] of bestByName.entries()){
          if(info && info.action==="done"){
            const prev = prevMap.get(n);
            if(!prev || prev.action!=="done"){
              const tileEl = findTileElByName(n);
              if(tileEl) fxFireworksAt(tileEl);
            }
          }
        }
      }catch(e){}

      // 내 미션 상태 보정(uid 기준)
      try{
        if(state.uid){
          const mine = v[state.uid];
          const cur = state.myMission || loadMissionLocal();
          if(mine){
            const merged = { dayKey, text: (cur.text || mine.text || "").slice(0,60), done:true, doneAt: cur.doneAt || (mine.doneAtMs ? new Date(mine.doneAtMs).toISOString() : "") };
            state.myMission = merged; saveMissionLocal(merged); setMissionButtonState();
          }
        }
      }catch(e){}
    };

    rOnValue(mref, onM);
    state.unsubMissionFeed = ()=>{ try{ rOff(mref, "value", onM); }catch(e){} };
  }catch(e){}
}


function scheduleMissionDayWatcher(){
  try{
    if(state._missionDayTimer) clearTimeout(state._missionDayTimer);

    // 서울 자정(+3초)까지 남은 시간 계산
    const now = new Date();
    const seoulNow = new Date(now.toLocaleString("en-US", { timeZone:"Asia/Seoul" }));
    const next = new Date(seoulNow);
    next.setHours(24, 0, 3, 0);
    const ms = next.getTime() - seoulNow.getTime();

    state._missionDayTimer = setTimeout(()=>{
      const dayKey = seoulDateKey();
      state.myMission = { dayKey, text:"", done:false, doneAt:"" };
      saveMissionLocal(state.myMission);
      try{ setMissionButtonState(); }catch(e){}
      // ✅ 새 dayKey로 재구독 → 카운트 자동 리셋
      subscribeMissionFeed();
      scheduleMissionDayWatcher();
    }, Math.max(2000, ms));
  }catch(e){}
}


function fxFireworksAt(el){
      try{
        const layer = document.getElementById("fxLayer");
        if(!layer || !el) return;
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width/2;
        const cy = r.top + r.height/2;
        const pops = 18;
        for(let i=0;i<pops;i++){
          const p = document.createElement("div");
          p.className = "fxPop";
          const ang = (Math.PI*2) * (i/pops);
          const dist = 24 + Math.random()*22;
          const dx = Math.cos(ang)*dist;
          const dy = Math.sin(ang)*dist;
          p.style.left = cx + "px";
          p.style.top = cy + "px";
          p.style.setProperty("--dx", dx + "px");
          p.style.setProperty("--dy", dy + "px");
          layer.appendChild(p);
          setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 900);
        }
      }catch(e){}
    }

    // -----------------------------
    // ✅ 대시보드 접기/펼치기
    // -----------------------------
    const MK_DASH_FOLD_KEY = "mk_dash_fold_v1";
    function loadDashFold(){ try{ return localStorage.getItem(MK_DASH_FOLD_KEY)==="1"; }catch(e){ return false; } }
    function saveDashFold(v){ try{ localStorage.setItem(MK_DASH_FOLD_KEY, v?"1":"0"); }catch(e){} }
function seoulDateKey(){
      const parts = new Intl.DateTimeFormat("sv-SE", {
        timeZone: "Asia/Seoul", year:"numeric", month:"2-digit", day:"2-digit"
      }).formatToParts(new Date()).reduce((a,p)=> (a[p.type]=p.value, a), {});
      return `${parts.year}-${parts.month}-${parts.day}`;
    }
    const ONLINE_TTL_MS = 30 * 60 * 1000; // (레거시) TTL 기반 온라인 판정은 사용하지 않음. 오프라인은 onDisconnect/status="off" 또는 퇴장 버튼에서만 처리.
// ✅ 온라인/오프라인 판정 규칙
// - 입장하면 온라인 유지(heartbeat 사용 여부와 무관)
// - '진짜 오프라인'만 타일에서 숨김: status가 'off'/'offline'일 때만
function isOfflinePresence(p){
  if(!p) return true;
  const s = String(p.status||"").toLowerCase();
  return (s === "off" || s === "offline");
}
function isOnlinePresence(p){
  return !isOfflinePresence(p);
}

function hasValidNick(n){
  const s = String(n||"").trim();
  return !!s && s !== "익명";
}
function isDisplayablePresence(p){
  return !!(p && isOnlinePresence(p) && hasValidNick(p.name));
}
    const MAC_HELPER_URL = "https://drive.google.com/file/d/1tvpH2bOoAhAthgMyCzWDMX4d4JbpdY83/view?usp=sharing";
    const WIN_HELPER_URL = "https://drive.google.com/file/d/1dvBW2Y5e6yg3IMPOpcULXee63sPkxr86/view?usp=sharing";

function openUrl(url){
      if(!url){ showToast("설정된 링크가 없어! (☰에서 저장)"); return; }
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function openUrlJoined(url){
      if(!state.joined){ showToast("입장하고 눌러줘! 💗"); return; }
      openUrl(url);
    }

    // -----------------------------
    // 대시보드 실시간 인원(앱스크립트) JSONP 폴링
    // - CORS 회피용: Apps Script doGet에서 callback 지원이 필요해요.
    // -----------------------------
    function loadJsonp(url, cb){
      try{
        const cbName = "__mk_cb_" + Math.random().toString(36).slice(2);
        window[cbName] = (data)=>{
          try{ cb(null, data); } finally {
            delete window[cbName];
          }
        };
        const hasQ = url.includes("?");
        const withCb = url + (hasQ ? "&" : "?") + "callback=" + cbName + "&_=" + Date.now();
        const sc = document.createElement("script");
        sc.src = withCb;
        sc.async = true;
        sc.onerror = ()=>{ try{ cb(new Error("jsonp error")); } finally { delete window[cbName]; } };
        document.head.appendChild(sc);
        // cleanup later
        setTimeout(()=>{ if(sc.parentNode) sc.parentNode.removeChild(sc); }, 15_000);
      }catch(err){ cb(err); }
    }

    
    async function loadJsonAny(url, cb){
      // 1) try CORS JSON fetch (works with script.googleusercontent.com/macros/echo... 형태도 가능)
      try{
        const u = new URL(url, location.href);
        u.searchParams.set("_", String(Date.now()));
        const res = await fetch(u.toString(), { cache:"no-store", credentials:"omit", mode:"cors" });
        if(res && res.ok){
          const ct = (res.headers.get("content-type") || "").toLowerCase();
          const txt = await res.text();
          // JSON only
          try{
            const data = JSON.parse(txt);
            cb(null, data);
            return;
          }catch(e){
            // not JSON → try to salvage (some endpoints return text/plain or key=value)
            try{
              // 1) JSON object embedded in text
              const m = txt.match(/\{[\s\S]*\}/);
              if(m){
                const data2 = JSON.parse(m[0]);
                cb(null, data2);
                return;
              }
            }catch(e2){}
            try{
              // 2) key=value or key: value lines
              const out = {};
              const lines = String(txt||"").split(/[\n&]+/);
              for(const line of lines){
                const s = line.trim();
                if(!s) continue;
                const kv = s.split(/[:=]/);
                if(kv.length < 2) continue;
                const k = kv[0].trim().toLowerCase();
                const v = kv.slice(1).join(":").trim();
                if(!k) continue;
                const num = Number(String(v).replace(/[^0-9.\-]/g,""));
                out[k] = isFinite(num) ? num : v;
              }
              // 흔한 키 매핑
              const pomo = out.pomo ?? out.pomocount ?? out.pomodoro ?? out.work ?? out.p;
              const suda = out.suda ?? out.sudacount ?? out.chat ?? out.c;
              if(typeof pomo !== "undefined" || typeof suda !== "undefined"){
                cb(null, { pomoCount: pomo, sudaCount: suda, raw: out });
                return;
              }
            }catch(e3){}
            // still not parseable → fallthrough to JSONP
          }
        }
      }catch(e){
        // fetch blocked → fallthrough to JSONP
      }
      // 2) fallback JSONP (requires callback 지원)
      loadJsonp(url, cb);
    }
function normalizeDashApiUrl(raw){
      const s = (raw||"").trim();
      if(!s) return "";
      // Apps Script exec root → default to ?api=counts
      try{
        const u = new URL(s);
        if(u.hostname.includes("script.google.com") && u.pathname.includes("/macros/s/") && u.pathname.endsWith("/exec")){
          if(!u.searchParams.has("api")) u.searchParams.set("api","counts");
        }
        return u.toString();
      }catch(e){
        if(s.includes("script.google.com/macros/s/") && s.includes("/exec") && !/\bapi=/.test(s)){
          return s + (s.includes("?") ? "&" : "?") + "api=counts";
        }
        return s;
      }
    }
    function __extractDashCounts(data){
      let pomo = null, suda = null;
      if(!data || typeof data !== "object") return {pomo:null, suda:null};
      // our standard
      if(data.pomoCount != null) pomo = data.pomoCount;
      if(data.sudaCount != null) suda = data.sudaCount;
      if(data.pomo != null && typeof data.pomo !== "object") pomo = data.pomo;
      if(data.suda != null && typeof data.suda !== "object") suda = data.suda;
      // Apps Script counts format: {pomo:{activeCount}, suda:{activeCount}}
      if(data.pomo && typeof data.pomo === "object"){
        if(data.pomo.activeCount != null) pomo = data.pomo.activeCount;
        else if(data.pomo.count != null) pomo = data.pomo.count;
      }
      if(data.suda && typeof data.suda === "object"){
        if(data.suda.activeCount != null) suda = data.suda.activeCount;
        else if(data.suda.count != null) suda = data.suda.count;
      }
      if(data.total && typeof data.total === "object"){
        if(pomo==null && data.total.pomo != null) pomo = data.total.pomo;
        if(suda==null && data.total.suda != null) suda = data.total.suda;
      }
      return {pomo, suda};
    }
function ensureDashPolling(){
      // ✅ 1) (기존) 통합 counts API(dashApiUrl) 우선 사용
      // ✅ 2) dashApiUrl이 비어 있으면, 각 채팅앱(pomoUrl/sudaUrl)의 ?api=active 를 직접 폴링해서 현황 표시
      const dashCfg = (state.roomSettings && state.roomSettings.dashboard) ? state.roomSettings.dashboard : {};
      const rawDashUrl = (dashCfg.dashApiUrl ? String(dashCfg.dashApiUrl).trim() : "");
      const dashUrl = normalizeDashApiUrl(rawDashUrl);

      const pomoBase = (dashCfg.pomoUrl ? String(dashCfg.pomoUrl).trim() : "");
      const sudaBase = (dashCfg.sudaUrl ? String(dashCfg.sudaUrl).trim() : "");

      function normalizeActiveApiUrl(raw){
        const s = (raw||"").trim();
        if(!s) return "";
        try{
          const u = new URL(s);
          // Apps Script exec root → default to ?api=active
          if(u.hostname.includes("script.google.com") && u.pathname.includes("/macros/s/") && u.pathname.endsWith("/exec")){
            u.searchParams.set("api","active");
            return u.toString();
          }
          if(!u.searchParams.has("api")) u.searchParams.set("api","active");
          return u.toString();
        }catch(e){
          if(/\bapi=/.test(s)) return s;
          return s + (s.includes("?") ? "&" : "?") + "api=active";
        }
      }
      function loadActiveCount(url){
        return new Promise((resolve)=>{
          if(!url){ resolve(null); return; }
          loadJsonAny(url, (err, data)=>{
            if(err || !data || typeof data!=="object"){ resolve(null); return; }
            const v = (data.activeCount!=null) ? data.activeCount : (data.count!=null ? data.count : (data.total!=null ? data.total : null));
            resolve(coerceCount(v));
          });
        });
      }

      // polling stop helper
      function stop(){
        if(state.dashPollTimer){ clearInterval(state.dashPollTimer); state.dashPollTimer=null; }
        state.dashPollUrl = "";
        state.localDashCounts = {pomoCount:null, sudaCount:null, updatedAtMs:null};
      }


// ✅ (옵션 A) 대시보드 현황을 RTDB로도 공유(읽기 절감/동기화)
let __dashWriteAt = 0;
let __dashWriteSig = "";
const writeCountsToRTDB = (counts)=>{
  try{
    if(!state.roomId) return;
    const now = Date.now();
    const sig = `${counts.pomoCount ?? ""}|${counts.sudaCount ?? ""}`;
    // 값 변화 없고 너무 자주면 스킵
    if(sig === __dashWriteSig && (now - __dashWriteAt) < 15000) return;
    if((now - __dashWriteAt) < 5000) return;
    __dashWriteAt = now;
    __dashWriteSig = sig;
    rUpdate(rDashboardCountsRef(state.roomId), {
      pomoCount: (counts.pomoCount==null? null : Number(counts.pomoCount)),
      sudaCount: (counts.sudaCount==null? null : Number(counts.sudaCount)),
      updatedAtMs: Number(counts.updatedAtMs||now),
      writerUid: state.uid || "",
      writerName: state.nickname || ""
    }).catch(()=>{});
  }catch(e){}
};

      // ---- case A: 통합 counts API ----
      if(dashUrl){
        if(state.dashPollUrl === dashUrl && state.dashPollTimer) return;
        if(state.dashPollTimer) clearInterval(state.dashPollTimer);
        state.dashPollUrl = dashUrl;

        const tick = ()=>{
          loadJsonAny(dashUrl, (err, data)=>{
            if(err) return;
            if(!data || typeof data !== "object") return;
            const c = __extractDashCounts(data);
            const upd  = (data.updatedAtMs != null) ? Number(data.updatedAtMs) : Date.now();
            state.localDashCounts = {pomoCount: coerceCount(c.pomo), sudaCount: coerceCount(c.suda), updatedAtMs: upd};
            renderDashboard();
            writeCountsToRTDB(state.localDashCounts);
          });
        };
        tick();
        state.dashPollTimer = setInterval(tick, 10_000);
        return;
      }

      // ---- case B: 각 채팅앱 직접 폴링(?api=active) ----
      const po = normalizeActiveApiUrl(pomoBase);
      const su = normalizeActiveApiUrl(sudaBase);
      const key = `direct|${po}|${su}`;
      if(!po && !su){ stop(); return; }

      if(state.dashPollUrl === key && state.dashPollTimer) return;
      if(state.dashPollTimer) clearInterval(state.dashPollTimer);
      state.dashPollUrl = key;

      const tickDirect = async ()=>{
        const [pc, sc] = await Promise.all([loadActiveCount(po), loadActiveCount(su)]);
        state.localDashCounts = {pomoCount: pc, sudaCount: sc, updatedAtMs: Date.now()};
        renderDashboard();
        writeCountsToRTDB(state.localDashCounts);
      };
      tickDirect();
      state.dashPollTimer = setInterval(tickDirect, 10_000);
    }

    
    // -----------------------------
    // 오른쪽 사이드(대시보드+채팅) 접기/펼치기
    // - 채팅 제목 옆 ⟫ 버튼: 접기/펼치기 토글
    // - 화면 오른쪽 끝 ⟪ 버튼: 펼치기
    // -----------------------------
    const LS_RAIL_FOLDED = "mk_rail_folded_v1";
    function isRailFolded(){
      return document.body.classList.contains("railFolded");
    }
    function setRailFolded(on){
      document.body.classList.toggle("railFolded", !!on);
      try{ localStorage.setItem(LS_RAIL_FOLDED, on ? "1" : "0"); }catch(e){}
      try{ updateRailFoldUi(); }catch(e){}
      try{ ensureChatLayout(); }catch(e){}
    }
    function toggleRailFolded(){
      setRailFolded(!isRailFolded());
    }
    function updateRailFoldUi(){
      const folded = isRailFolded();
      if(els.railFoldToggle){
        els.railFoldToggle.textContent = folded ? "⟪" : "⟫";
        els.railFoldToggle.title = folded ? "오른쪽 사이드 펼치기" : "오른쪽 사이드 접기";
        els.railFoldToggle.setAttribute("aria-label", folded ? "오른쪽 사이드 펼치기" : "오른쪽 사이드 접기");
      }
      // #railEdgeBtn 은 CSS로도 제어하지만, 혹시 모를 상황 대비
      if(els.railEdgeBtn){
        els.railEdgeBtn.style.display = folded ? "flex" : "none";
      }
      try{
        const sb = document.querySelector("aside.sidebar");
        if(sb) sb.style.display = folded ? "none" : "";
      }catch(e){}
    }
    function initRailFold(){
      try{
        const v = localStorage.getItem(LS_RAIL_FOLDED);
        if(v === "1") document.body.classList.add("railFolded");
      }catch(e){}
      updateRailFoldUi();
      if(els.railFoldToggle){
        els.railFoldToggle.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); toggleRailFolded(); });
      }
      if(els.railEdgeBtn){
        els.railEdgeBtn.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); setRailFolded(false); });
      }
      // 리사이즈/회전 시 레이아웃 안정화
      window.addEventListener("resize", ()=>{ try{ ensureChatLayout(); }catch(e){} });
    }

// ---------- Embeds (optional) ----------
    function openInlineEmbed(title, url){
      openUrl(url);
    }
    function closeInlineEmbed(){
      els.embedBar.style.display = "none";
      els.embedFrame.style.display = "none";
      els.embedFrame.src = "about:blank";
      els.chatList.style.display = "block";
      const row = els.chatInput.closest(".chatInputRow");
      if(row) row.style.display = "";
    }
    function openEmbedModal(title, url){
      openUrl(url);
    }
    function closeEmbedModal(){
      hideModal(els.embedModal);
      els.embedModalFrame.src = "about:blank";
    }

    
    // -----------------------------
    // Dashboard docking: stick dashboard card right under the settings (☰) button
    // - On wide screens: dashboard becomes fixed and follows the button's position
    // - On small screens: dashboard returns to normal flow (so it doesn't cover the UI)
    // -----------------------------
    
    function ensureChatLayout(){
      try{
        const card = document.getElementById("chatCard");
        if(!card) return;
        // 강제로 '채팅 리스트 + 입력' 레이아웃 유지 (접기/도킹에 의해 무너지는 것 방지)
        const body = card.querySelector(".body.chatBody");
        const list = document.getElementById("chatList");
        const row  = card.querySelector(".chatInputRow");
        if(body){
          body.style.display = "flex";
          body.style.flexDirection = "column";
          body.style.flex = "1 1 auto";
          body.style.minHeight = "0";
          body.style.overflow = "hidden";
        }
        if(list){
          list.style.flex = "1 1 auto";
          list.style.minHeight = "0";
          list.style.overflow = "auto";
        }
        if(row){
          row.style.display = "flex";
          row.style.flex = "0 0 auto";
        }
      }catch(e){}
    }

function dockRightRail(){
      const dash = els.dashboardCard || document.getElementById("dashboardCard");
      const chat = els.chatCard || document.getElementById("chatCard");
      const anchor = els.menuBtn;
      if(!dash || !anchor) return;

      if(document.body.classList.contains("railFolded")){
        const reset = (el, cls)=>{
          if(!el) return;
          el.classList.remove(cls);
          el.style.position = "";
          el.style.top = "";
          el.style.right = "";
          el.style.left = "";
          el.style.width = "";
          el.style.maxHeight = "";
          el.style.height = "";
          el.style.overflow = "";
        };
        reset(dash, "docked");
        reset(chat, "dockedChat");
        return;
      }

      const wide = window.innerWidth > 980;

      const reset = (el, cls)=>{
        if(!el) return;
        el.classList.remove(cls);
        el.style.position = "";
        el.style.top = "";
        el.style.right = "";
        el.style.left = "";
        el.style.width = "";
        el.style.maxHeight = "";
        el.style.height = "";
        el.style.overflow = "";
      };

      if(!wide){
        reset(dash, "docked");
        reset(chat, "dockedChat");
        return;
      }

      const r = anchor.getBoundingClientRect();
      const right = Math.max(10, window.innerWidth - r.right);
      const top = Math.max(12, r.bottom + 18);     // ✅ 상단바↔대시보드 여백
      const gap = 12;                               // ✅ 대시보드↔채팅 여백

      dash.classList.add("docked");
      dash.style.top = top + "px";
      dash.style.right = right + "px";
      dash.style.maxHeight = `calc(100vh - ${top + 18}px)`;
      dash.style.overflow = "auto";

      if(chat){
        // chat should sit right under dashboard, same width, and stretch down.
        const dr = dash.getBoundingClientRect();
        const chatTop = Math.max(dr.bottom + gap, top + 56);
        const bottomPad = 14;

        chat.classList.add("dockedChat");
        ensureChatLayout();
        chat.style.position = "fixed";
        chat.style.right = right + "px";
        chat.style.top = chatTop + "px";
        chat.style.width = dr.width + "px";
        chat.style.height = `calc(100vh - ${chatTop + bottomPad}px)`;
        chat.style.maxHeight = `calc(100vh - ${chatTop + bottomPad}px)`;
        chat.style.overflow = "hidden";
      }
    }



    
    // ✅ 입장 전 정보 최소화: 접속 인원은 "대략치"로만 표시
    function approxOnlineBucket(n){
      n = Number(n||0);
      if(!isFinite(n) || n<=0) return "0";
      if(n<=3) return "1~3";
      if(n<=7) return "4~7";
      if(n<=12) return "8~12";
      if(n<=20) return "13~20";
      return "20+";
    }
    function updateOnlineCountUI(n){
      const joined = !!state.joined;
      const bucket = approxOnlineBucket(n);
      // 상단 표시(입장 전: 대략치 / 입장 후: 정확치)
      if(els.countOnline){
        els.countOnline.textContent = joined ? String(n) : `약 ${bucket}`;
      }
      // 입장 전 안내 카드 표시
      if(els.approxOnlineText){
        els.approxOnlineText.textContent = joined ? `${n}명` : `약 ${bucket}명`;
      }
    }


    function setControlsEnabled(joined){
      els.leaveBtn.disabled = !joined;
      els.joinBtn.disabled = joined;
      els.name.disabled = joined;
      els.menuBtn.disabled = !joined;
      if(els.dataSaverBtn) els.dataSaverBtn.disabled = !joined;

      // hide/show nickname & pass area on join
      els.name.style.display = joined ? "none" : "";
      if(els.roomPass) els.roomPass.style.display = (joined || document.body.classList.contains("passok")) ? "none" : "";
      els.joinBtn.style.display = joined ? "none" : "";
      els.leaveBtn.style.display = joined ? "" : "";
      els.meHint.style.display = joined ? "" : "";

      els.btnWork.disabled = !joined;
      els.btnBreak.disabled = !joined;
      els.btnIdle.disabled = !joined;
      try{ if(els.btnTimerReset) els.btnTimerReset.disabled = !joined; }catch(e){}
      if(els.checkInBtn) els.checkInBtn.disabled = !joined;
      els.statusBtn.disabled = !joined;
      if(els.btnHelperToggle) els.btnHelperToggle.disabled = !joined;
      try{ if(els.guideBtn) els.guideBtn.style.display = joined ? "" : "none"; }catch(e){}
      // ✅ 입장 전에는 아무 것도 열지 못하게 잠금
      els.profileBtn.disabled = !joined;
      if(els.onlineBtn) els.onlineBtn.disabled = !joined;

      // ✅ 대시보드 외부 링크(공용뽀모/폭파수다): 입장 후에만
      if(els.goPomo) els.goPomo.disabled = !joined;
      if(els.goSuda) els.goSuda.disabled = !joined;
      if(els.goPomoMini) els.goPomoMini.disabled = !joined;
      if(els.goSudaMini) els.goSudaMini.disabled = !joined;

      els.chatInput.disabled = !joined;
      els.sendBtn.disabled = !joined;

      // ✅ 대시보드 바로가기(헬퍼/출근부/시트): 입장 후에만 클릭 가능
      if(els.goMacHelper) els.goMacHelper.disabled = !joined;
      if(els.goWinHelper) els.goWinHelper.disabled = !joined;
      if(els.goChool) els.goChool.disabled = !joined;
      if(els.goSheet) els.goSheet.disabled = !joined;

      // lamp
      document.body.classList.toggle("joined", joined);
      state.joined = joined;
      try{ if(joined){ scheduleDailyNotice && scheduleDailyNotice(); } }catch(e){}
      // keep dashboard positioned under ☰
      dockRightRail();
    }
    
    function syncMyStatusUI(){
      const me = (state.currentParticipants && state.currentParticipants.get) ? state.currentParticipants.get(state.uid) : null;
      const st = (me && me.status) ? me.status : (state.myStatus || "idle");
      const label = (st==="work") ? "✍️ 작업중" : (st==="break") ? "☕ 휴식중" : "🌙 자리비움";
      const hm = getHelperMode();
      const modeLabel = (hm==="manual") ? "✋ 수동" : "🤖 헬퍼";

      if(els.statusBtn){
        els.statusBtn.textContent = `${label} ▾`;
      }

      // (UI) 헬퍼 토글 버튼 상태
      try{
        if(els.btnHelperToggle){
          const joined = !!state.joined;
          const canUse = joined && (st==="work");
          els.btnHelperToggle.disabled = !canUse;
          els.btnHelperToggle.className = (hm==="auto" && canUse) ? "primary" : "ghost";
          els.btnHelperToggle.textContent = (hm==="auto") ? "🤖 헬퍼 사용중" : "🤖 헬퍼 켜기";
        }
      }catch(e){}

      // 모드 버튼(내부 유지) + 옵션 표시(헬퍼일 때만)
      try{
        if(els.modeAutoBtn) els.modeAutoBtn.className = (hm==="auto") ? "primary tight" : "ghost tight";
        if(els.modeManualBtn) els.modeManualBtn.className = (hm==="manual") ? "primary tight" : "ghost tight";
        if(els.autoOpts) els.autoOpts.style.display = (hm==="auto") ? "" : "none";
        if(els.manualOpts) els.manualOpts.style.display = "";
      }catch(e){}

      if(els.btnWork) els.btnWork.className = (st==="work") ? "primary" : "ghost";
      if(els.btnBreak) els.btnBreak.className = (st==="break") ? "primary" : "ghost";
      if(els.btnIdle) els.btnIdle.className = (st==="idle") ? "primary" : "ghost";

      // 상단 자동분 입력 동기화
      try{
        const lp = loadLocalProfile() || {};
        const ab = Number(lp.autoBreakMin || 10);
        const ai = Number(lp.autoIdleMin || 15);
        if(els.autoBreakMinTop) els.autoBreakMinTop.value = String(ab);
        if(els.autoIdleMinTop)  els.autoIdleMinTop.value  = String(ai);
      }catch(e){}
    }

function showModal(el){
      try{
        if(!el) return;
        el.classList.add("show");
        try{ el.setAttribute("aria-hidden","false"); }catch(e){}
        try{ el.inert = false; }catch(e){}
        // 가능한 첫 포커스 요소로 이동(접근성/키보드)
        setTimeout(()=>{
          try{
            const f = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            (f || el).focus?.();
          }catch(e){}
        },0);
      }catch(e){}
    }
    function hideModal(el){
      try{
        if(!el) return;
        // aria-hidden=true 전에 포커스를 빼서 Chrome 경고/차단 방지
        try{
          const active = document.activeElement;
          if(active && el.contains(active)) active.blur?.();
        }catch(e){}
        el.classList.remove("show");
        try{ el.setAttribute("aria-hidden","true"); }catch(e){}
        try{ el.inert = true; }catch(e){}
      }catch(e){}
    }

    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const hashBuf = await crypto.subtle.digest("SHA-256", enc);
      const arr = Array.from(new Uint8Array(hashBuf));
      return arr.map(b=>b.toString(16).padStart(2,"0")).join("");
    }
    function clampNum(v, min, max, def){
      const n = Number(v);
      if(!Number.isFinite(n)) return def;
      return Math.min(max, Math.max(min, n));
    }

    function clampHexColor(s){
      s = (s||"").trim();
      if(!s) return "#ffd0e2";
      if(/^#[0-9a-fA-F]{6}$/.test(s)) return s;
      if(/^#[0-9a-fA-F]{3}$/.test(s)){
        return "#" + s.slice(1).split("").map(c=>c+c).join("");
      }
      return "#ffd0e2";
    }

    function hexToRgba(hex, a){
      const c = clampHexColor(hex);
      const r = parseInt(c.slice(1,3),16);
      const g = parseInt(c.slice(3,5),16);
      const b = parseInt(c.slice(5,7),16);
      const alpha = (a===undefined || a===null) ? 1 : Math.max(0, Math.min(1, Number(a)));
      return `rgba(${r},${g},${b},${alpha})`;
    }

    const DEFAULT_SWATCHES = [
      "#ffffff",
      "#dedede",
      "#b3b3b3",
      "#666666",
      "#262626",
      "#000000",
      "#ffd0e2",
      "#fe9dc0",
      "#ff5b98",
      "#ff005e",
      "#ffcdfe",
      "#fd92fa",
      "#ff41f9",
      "#fe00f6",
      "#e2c6ff",
      "#c185ff",
      "#9e42ff",
      "#7b00ff",
      "#d2e3ff",
      "#96bdff",
      "#4a90ff",
      "#0060ff",
      "#c8f7ff",
      "#87ecff",
      "#46e1ff",
      "#01d6fe",
      "#c6fff8",
      "#8ffff1",
      "#4bfee8",
      "#00ffdf",
      "#ccffc6",
      "#9eff94",
      "#63ff54",
      "#15ff00",
      "#f5ffcb",
      "#ebff9e",
      "#ddff51",
      "#cbff00",
      "#feffd3",
      "#fbfa9d",
      "#feff75",
      "#ffff00",
      "#fff1dc",
      "#fddeaf",
      "#ffc162",
      "#ff9a00",
      "#ffe5d8",
      "#fdc19f",
      "#fa8649",
      "#ff5800",
      "#ffc9c9",
      "#fe9c9b",
      "#fb5352",
      "#fe0000",
      "#fff8e8",
      "#fff1d6",
      "#ffe5b4",
      "#e2c490",
      "#efc2ab",
      "#d49b7e",
      "#a46b4e",
      "#835136"
    ];

    function setBgColorAll(hex){
      const c = clampHexColor(hex);
      if(els.bgColor) els.bgColor.value = c;
      if(els.bgPicker) els.bgPicker.value = c;
      // active swatch highlight
      if(els.swatches){
        [...els.swatches.querySelectorAll(".swatch")].forEach(s=>{
          s.classList.toggle("active", s.dataset.hex.toLowerCase() === c.toLowerCase());
        });
      }
    }

    function initPalette(){
      if(!els.swatches || !els.bgPicker || !els.bgColor) return;

      // render swatches once
      if(!els.swatches.dataset.ready){
        els.swatches.innerHTML = "";
        for(const hex of DEFAULT_SWATCHES){
          const b = document.createElement("button");
          b.type = "button";
          b.className = "swatch";
          b.style.background = hex;
          b.dataset.hex = hex;
          b.title = hex;
          b.addEventListener("click", ()=>setBgColorAll(hex));
          els.swatches.appendChild(b);
        }
        els.swatches.dataset.ready = "1";
      }
      function setEmojiBgAll(hex){
        const c = clampHexColor(hex || "#2b2b2b");
        if(els.emojiBgColor) els.emojiBgColor.value = c;
        if(els.emojiBgPicker) els.emojiBgPicker.value = c;
      }
      function setBubbleColorAll(hex){
        const fallback = (els.bgColor && els.bgColor.value) ? els.bgColor.value : "#ffd0e2";
        const c = clampHexColor(hex || fallback);
        if(els.bubbleColor) els.bubbleColor.value = c;
        if(els.bubblePicker) els.bubblePicker.value = c;
      }


      function setTimeColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.timeColor) els.timeColor.value = c;
        if(els.timePicker) els.timePicker.value = c;
      }

      function setNameColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.nameColor) els.nameColor.value = c;
        if(els.nameColorPicker) els.nameColorPicker.value = c;
      }
      function setChatNameColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.chatNameColor) els.chatNameColor.value = c;
        if(els.chatNameColorPicker) els.chatNameColorPicker.value = c;
      }
      function setStatusTextColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.statusTextColor) els.statusTextColor.value = c;
        if(els.statusTextColorPicker) els.statusTextColorPicker.value = c;
      }
      function setBubbleTextColorAll(hex){
        const c = clampHexColor(hex || "#ffffff");
        if(els.bubbleTextColor) els.bubbleTextColor.value = c;
        if(els.bubbleTextColorPicker) els.bubbleTextColorPicker.value = c;
      }



      // sync: picker -> code
      els.bgPicker.addEventListener("input", ()=>setBgColorAll(els.bgPicker.value));
      // sync: code -> picker (on blur + enter)
      els.bgColor.addEventListener("change", ()=>setBgColorAll(els.bgColor.value));
      els.bgColor.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); setBgColorAll(els.bgColor.value); }
      });

      // initial
      setBgColorAll(els.bgColor.value || els.bgPicker.value || "#ffd0e2");
      // emoji bg color controls
      if(els.emojiBgPicker && els.emojiBgColor){
        els.emojiBgPicker.addEventListener("input", ()=>setEmojiBgAll(els.emojiBgPicker.value));
        els.emojiBgColor.addEventListener("change", ()=>setEmojiBgAll(els.emojiBgColor.value));
        els.emojiBgColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setEmojiBgAll(els.emojiBgColor.value); }
        });
        setEmojiBgAll(els.emojiBgColor.value || els.emojiBgPicker.value || "#2b2b2b");
      }

      // bubble color controls
      if(els.bubblePicker && els.bubbleColor){
        els.bubblePicker.addEventListener("input", ()=>setBubbleColorAll(els.bubblePicker.value));
        els.bubbleColor.addEventListener("change", ()=>setBubbleColorAll(els.bubbleColor.value));
        els.bubbleColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setBubbleColorAll(els.bubbleColor.value); }
        });
        setBubbleColorAll(els.bubbleColor.value || els.bubblePicker.value || (els.bgColor ? els.bgColor.value : "#ffd0e2"));
      }

      // time color controls (work time only)
      if(els.timePicker && els.timeColor){
        els.timePicker.addEventListener("input", ()=>setTimeColorAll(els.timePicker.value));
        els.timeColor.addEventListener("change", ()=>setTimeColorAll(els.timeColor.value));
        els.timeColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setTimeColorAll(els.timeColor.value); }
        });
        

      // name color controls (tile nickname)
      if(els.nameColorPicker && els.nameColor){
        els.nameColorPicker.addEventListener("input", ()=>setNameColorAll(els.nameColorPicker.value));
        els.nameColor.addEventListener("change", ()=>setNameColorAll(els.nameColor.value));
        els.nameColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setNameColorAll(els.nameColor.value); }
        });
        setNameColorAll(els.nameColor.value || els.nameColorPicker.value || "#ffffff");
      }

      // chat nickname color controls
      if(els.chatNameColorPicker && els.chatNameColor){
        els.chatNameColorPicker.addEventListener("input", ()=>setChatNameColorAll(els.chatNameColorPicker.value));
        els.chatNameColor.addEventListener("change", ()=>setChatNameColorAll(els.chatNameColor.value));
        els.chatNameColor.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setChatNameColorAll(els.chatNameColor.value); }
        });
        setChatNameColorAll(els.chatNameColor.value || els.chatNameColorPicker.value || (els.nameColor ? els.nameColor.value : "#ffffff") || "#ffffff");
      }


// pattern color controls
function setPatternColorAll(v){
  if(!els.patternPicker || !els.patternColor) return;
  const hex = clampHexColor(v || "#ffffff");
  els.patternPicker.value = hex;
  els.patternColor.value = hex;
}

    
    function normalizeHexInput(v){
      try{
        let s = (v || "").toString().trim();
        if(!s) return "";
        if(!s.startsWith("#")) s = "#" + s;
        // allow shorthand
        if(/^#([0-9a-fA-F]{3})$/.test(s)){
          const a = s[1], b = s[2], c = s[3];
          s = "#" + a+a + b+b + c+c;
        }
        if(/^#([0-9a-fA-F]{6})$/.test(s)) return s.toLowerCase();
        return "";
      }catch(e){ return ""; }
    }
    function attachColorSync(textEl, pickerEl){
      if(!textEl || !pickerEl) return;
      const sync = ()=>{
        const norm = normalizeHexInput(textEl.value) || clampHexColor(textEl.value);
        if(norm){
          textEl.value = norm;
          pickerEl.value = norm;
        }
      };
      textEl.addEventListener("change", sync);
      textEl.addEventListener("blur", sync);
      textEl.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ sync(); textEl.blur(); }});
      pickerEl.addEventListener("input", ()=>{
        textEl.value = pickerEl.value;
      });
    }
// ✅ 이모지 1개만 허용 (grapheme 기준)
    function firstEmojiGrapheme(str){
      try{
        const s = (str || "").toString().trim();
        if(!s) return "";
        if(typeof Intl !== "undefined" && Intl.Segmenter){
          const seg = new Intl.Segmenter("en", { granularity: "grapheme" });
          for(const it of seg.segment(s)){
            return it.segment;
          }
          return "";
        }
        // fallback: 첫 codepoint
        const cp = Array.from(s);
        return cp[0] || "";
      }catch(e){
        return "";
      }
    }
    try{ window.firstEmojiGrapheme = firstEmojiGrapheme; }catch(e){}


    // ✅ 집중시간(24시간 누적, 자정 리셋) — 전역 유틸
    function loadFocusSeconds(){
      const today = seoulDateKey();
      // ✅ 미션 로컬 로드 + 날짜 불일치면 초기화
      try{
        const m0 = loadMissionLocal();
        if(m0.dayKey !== today){
          state.myMission = { dayKey: today, text:"", done:false, doneAt:"" };
          saveMissionLocal(state.myMission);
        }else{
          state.myMission = m0;
        }
      }catch(e){ state.myMission = { dayKey: today, text:"", done:false, doneAt:"" }; }

      try{
        const day = localStorage.getItem(LS_FOCUS_DAY) || "";
        const sec = Number(localStorage.getItem(LS_FOCUS_SEC) || 0);
        if(day !== today){
          localStorage.setItem(LS_FOCUS_DAY, today);
          localStorage.setItem(LS_FOCUS_SEC, "0");
          return 0;
        }
        return isFinite(sec) ? Math.max(0, sec) : 0;
      }catch(e){
        return 0;
      }
    }
    function saveFocusSeconds(sec){
      const today = seoulDateKey();
      try{
        localStorage.setItem(LS_FOCUS_DAY, today);
        localStorage.setItem(LS_FOCUS_SEC, String(Math.max(0, Math.floor(Number(sec)||0))));
      }catch(e){}
    }
    function persistMyFocusToLocal(){
      try{
        const me = state.currentParticipants.get(state.uid);
        if(!me) return;
        const totalNow = computeDisplayedTotal(me); // seconds
        focusSaveSeconds(totalNow);
      }catch(e){}
    }


    // (dedup) focus helpers already declared above

if(els.patternPicker && els.patternColor){
  els.patternPicker.addEventListener("input", ()=>setPatternColorAll(els.patternPicker.value));
  els.patternColor.addEventListener("change", ()=>setPatternColorAll(els.patternColor.value));
  els.patternColor.addEventListener("keydown", (e)=>{
    if(e.key==="Enter"){ e.preventDefault(); setPatternColorAll(els.patternColor.value); }
  });
  setPatternColorAll(els.patternColor.value || els.patternPicker.value || "#ffffff");
}

setTimeColorAll(els.timeColor.value || els.timePicker.value || "#ffffff");
      }

      // size controls (emoji/photo)
      function setEmojiSizeAll(v){
        if(!els.emojiSize || !els.emojiSizeNum) return;
        const n = clampNum(v, 26, 100, 40);
        els.emojiSize.value = String(n);
        els.emojiSizeNum.value = String(n);
      }
      function setPhotoSizeAll(v){
        if(!els.photoSize || !els.photoSizeNum) return;
        const n = clampNum(v, 52, 100, 68);
        els.photoSize.value = String(n);
        els.photoSizeNum.value = String(n);
      }
      if(els.emojiSize && els.emojiSizeNum){
        els.emojiSize.addEventListener("input", ()=>setEmojiSizeAll(els.emojiSize.value));
        els.emojiSizeNum.addEventListener("change", ()=>setEmojiSizeAll(els.emojiSizeNum.value));
        els.emojiSizeNum.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setEmojiSizeAll(els.emojiSizeNum.value); }
        });
        setEmojiSizeAll(els.emojiSize.value || els.emojiSizeNum.value || 54);
      }
      if(els.photoSize && els.photoSizeNum){
        els.photoSize.addEventListener("input", ()=>setPhotoSizeAll(els.photoSize.value));
        els.photoSizeNum.addEventListener("change", ()=>setPhotoSizeAll(els.photoSizeNum.value));
        els.photoSizeNum.addEventListener("keydown", (e)=>{
          if(e.key==="Enter"){ e.preventDefault(); setPhotoSizeAll(els.photoSizeNum.value); }
        });
        setPhotoSizeAll(els.photoSize.value || els.photoSizeNum.value || 68);
      }


    }

    function bgStyle(color, pattern, patColor){
      const c = clampHexColor(color);
      const p = (pattern || "none").trim();

      const pc = clampHexColor(patColor || "#ffffff");
      const pc32 = hexToRgba(pc, 0.32);
      const pc30 = hexToRgba(pc, 0.30);
      const pc28 = hexToRgba(pc, 0.28);
      const pc26 = hexToRgba(pc, 0.26);
      const pc24 = hexToRgba(pc, 0.24);
      const pc22 = hexToRgba(pc, 0.22);
      const pc20 = hexToRgba(pc, 0.20);
      const pc18 = hexToRgba(pc, 0.18);
      const pc16 = hexToRgba(pc, 0.16);
      const pc14 = hexToRgba(pc, 0.14);
      const pc12 = hexToRgba(pc, 0.12);
      const pc10 = hexToRgba(pc, 0.10);
      const pc08 = hexToRgba(pc, 0.08);


      // pattern layers (top-most first)
      const layers = [];

      const base = `linear-gradient(0deg, ${c}, ${c})`;

      if(p === "dots"){
        layers.push(`radial-gradient(circle at 9px 9px, ${pc32} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 19px 19px, ${pc22} 2px, transparent 2.4px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "microdots"){
        layers.push(`radial-gradient(circle at 6px 6px, ${pc28} 1.2px, transparent 1.6px)`);
        layers.push(`radial-gradient(circle at 14px 14px, ${pc18} 1.2px, transparent 1.6px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "grid"){
        layers.push(`linear-gradient(${pc18} 1px, transparent 1px)`);
        layers.push(`linear-gradient(90deg, ${pc18} 1px, transparent 1px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "papergrid"){
        layers.push(`linear-gradient(${pc08} 1px, transparent 1px)`);
        layers.push(`linear-gradient(90deg, ${pc08} 1px, transparent 1px)`);
layers.push(base);
        return layers.join(", ");
      }
      if(p === "stripes"){
        layers.push(`repeating-linear-gradient(45deg, ${pc22} 0 10px, transparent 10px 20px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "diagonal"){
        layers.push(`repeating-linear-gradient(135deg, ${pc22} 0 8px, transparent 8px 18px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "checker"){
        layers.push(`linear-gradient(45deg, ${pc18} 25%, transparent 25% 75%, ${pc18} 75%)`);
        layers.push(`linear-gradient(45deg, ${pc10} 25%, transparent 25% 75%, ${pc10} 75%)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "waves"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="80" height="40" viewBox="0 0 80 40">
          <path d="M0 20c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="${pc22}" stroke-width="3" stroke-linecap="round"/>
          <path d="M0 32c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="${pc14}" stroke-width="2" stroke-linecap="round"/>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "sparkles"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60">
          <g fill="${pc26}">
            <path d="M30 10l2.3 6.7L39 19l-6.7 2.3L30 28l-2.3-6.7L21 19l6.7-2.3z"/>
            <circle cx="12" cy="14" r="1.6" fill="${pc22}"/>
            <circle cx="48" cy="40" r="1.9" fill="${pc18}"/>
            <circle cx="18" cy="46" r="1.3" fill="${pc18}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "confetti"){
        layers.push(`radial-gradient(circle at 12px 10px, ${pc30} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 26px 24px, ${pc20} 2px, transparent 2.4px)`);
        layers.push(`radial-gradient(circle at 44px 14px, ${pc08} 2px, transparent 2.4px)`);
        layers.push(`repeating-linear-gradient(0deg, ${pc10} 0 1px, transparent 1px 16px)`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "stars"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc24}">
            <path d="M12 14l1.7 4.8L18 20l-4.3 1.2L12 26l-1.7-4.8L6 20l4.3-1.2z"/>
            <path d="M44 10l2 5.6L51 17l-5 1.4L44 24l-2-5.6L37 17l5-1.4z" fill="${pc18}"/>
            <path d="M50 44l1.8 5.2L56 51l-4.2 1.2L50 58l-1.8-5.2L44 51l4.2-1.2z"/>
            <circle cx="26" cy="46" r="1.5" fill="${pc18}"/>
            <circle cx="18" cy="34" r="1.2" fill="${pc16}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "moon"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="72" height="72" viewBox="0 0 72 72">
          <g>
            <path d="M46 12c-6.5 2.6-11 9-11 16.5 0 10 8 18 18 18 2.4 0 4.7-.5 6.8-1.3C57.8 54.3 49 60.5 38.8 60.5 24.8 60.5 13.5 49.2 13.5 35.2 13.5 22.7 22.3 12.1 33.9 9.4c4.1-1 8.3-.7 12.1 2.6z"
              fill="${pc22}"/>
            <circle cx="18" cy="18" r="1.3" fill="${pc16}"/>
            <circle cx="24" cy="12" r="1.0" fill="${pc12}"/>
            <circle cx="14" cy="30" r="1.1" fill="${pc14}"/>
            <circle cx="56" cy="18" r="1.2" fill="${pc12}"/>
            <circle cx="60" cy="30" r="1.0" fill="${pc10}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "flowers"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="72" height="72" viewBox="0 0 72 72">
          <g fill="none" stroke="none">
            <g transform="translate(10 10)">
              <g>
                <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc18}"/>
                <circle cx="14" cy="18" r="3" fill="${pc30}"/>
              </g>
            </g>
            <g transform="translate(38 30) scale(0.9)">
              <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc14}"/>
              <circle cx="14" cy="18" r="3" fill="${pc26}"/>
            </g>
            <g transform="translate(30 6) scale(0.7)">
              <path d="M10 12c2-3 6-3 8 0 3-2 7 0 6 4 3 2 2 6-2 7 0 4-4 6-7 4-3 2-7 0-7-4-4-1-5-5-2-7-1-4 3-6 6-4z" fill="${pc12}"/>
              <circle cx="14" cy="18" r="3" fill="${pc22}"/>
            </g>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "clouds"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="96" height="64" viewBox="0 0 96 64">
          <g fill="${pc18}">
            <path d="M30 42c-7 0-12-5-12-11 0-5 3-9 8-10 2-8 9-14 18-14 9 0 17 6 19 15 6 1 11 6 11 12 0 7-6 13-13 13H30z" opacity="0.9"/>
            <path d="M10 54c-5 0-9-4-9-8 0-4 2-7 6-8 1-6 7-10 13-10 7 0 13 5 14 12 5 1 8 4 8 9 0 5-4 9-9 9H10z" opacity="0.65"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "catpaws"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc22}">
            <circle cx="18" cy="20" r="4"/>
            <circle cx="28" cy="16" r="4"/>
            <circle cx="38" cy="16" r="4"/>
            <circle cx="48" cy="20" r="4"/>
            <path d="M32 30c-7 0-12 6-12 12 0 6 5 10 12 10s12-4 12-10c0-6-5-12-12-12z" fill="${pc18}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      if(p === "dogpaws"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g fill="${pc22}">
            <ellipse cx="18" cy="18" rx="4.2" ry="5.0"/>
            <ellipse cx="28" cy="14" rx="4.2" ry="5.0"/>
            <ellipse cx="36" cy="14" rx="4.2" ry="5.0"/>
            <ellipse cx="46" cy="18" rx="4.2" ry="5.0"/>
            <path d="M32 28c-8 0-14 7-14 14 0 7 6 12 14 12s14-5 14-12c0-7-6-14-14-14z" fill="${pc16}"/>
          </g>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }
      if(p === "hearts"){
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36">
          <path d="M18 30s-9-5.6-12.3-10.7C3 14.6 5.4 10 10 10c2.2 0 4.1 1.1 5.2 2.7C16.2 11.1 18.1 10 20.3 10 24.9 10 27.3 14.6 30.3 19.3 27 24.4 18 30 18 30z"
            fill="rgba(255,255,255,0.28)"/>
        </svg>`;
        layers.push(`url("data:image/svg+xml,${encodeURIComponent(svg)}")`);
        layers.push(base);
        return layers.join(", ");
      }

      // none
      return base;
    }



    // Firestore paths
    function roomRef(roomId){ return doc(db, "rooms", roomId); }
    function meRef(roomId, uid){ return doc(db, "rooms", roomId, "participants", uid); }
    function participantsCol(roomId){ return collection(db, "rooms", roomId, "participants"); }
    function chatCol(roomId){ return collection(db, "rooms", roomId, "messages"); }
    function kicksCol(roomId){ return collection(db, "rooms", roomId, "kicks"); }
    function kickRef(roomId, uid){ return doc(db, "rooms", roomId, "kicks", uid); }


// RTDB paths (migrated: presence/chat/dashboard/missions/profileUpdates)
function rRoomBase(roomId){ return `rooms/${roomId}`; }
function rSettingsRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/settings`); }
function rDashboardSettingsRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/dashboard/settings`); }
function rDashboardCountsRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/dashboard/counts`); }
function rPresenceRootRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/presence`); }
function rMePresenceRef(roomId, uid){ return rRef(rtdb, `${rRoomBase(roomId)}/presence/${uid}`); }
function rMessagesRootRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/messages`); }
function rMessageRef(roomId, msgId){ return rRef(rtdb, `${rRoomBase(roomId)}/messages/${msgId}`); }
// ✅ alias: legacy reaction code expects rChatMsgRef / ChatMsgRef
function rChatMsgRef(roomId, msgId){ return rMessageRef(roomId, msgId); }
try{ window.ChatMsgRef = rChatMsgRef; }catch(e){}

function rMissionsRootRef(roomId, dayKey){ return rRef(rtdb, `${rRoomBase(roomId)}/missions/${dayKey}`); }
function rProfileUpdatesRootRef(roomId){ return rRef(rtdb, `${rRoomBase(roomId)}/profileUpdates`); }

    async function ensureRoom(roomId){
      const r = roomRef(roomId);
      const snap = await getDoc(r);
      if(!snap.exists()){
        await setDoc(r, {
          createdAt: serverTimestamp(),
          title: roomId,
          adminHash: null,
          dashboard: { pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL },
          dashCounts: { pomoCount:null, sudaCount:null, updatedAtMs: null }
        });
      }
    }
    function defaultTheme(){
      const lp = loadLocalProfile();
      if(lp && lp.theme){
        return {
          emoji: (lp.theme.emoji || "✍️").trim(),
          bgColor: clampHexColor(lp.theme.bgColor || "#ffd0e2"),
          pattern: (lp.theme.pattern || lp.theme.bgPattern || "none"),
          patternColor: clampHexColor(lp.theme.patternColor || "#ffffff"),
          photoUrl: (lp.theme.photoUrl || ""),
          photoEnabled: !(lp.theme && (lp.theme.photoEnabled === false || lp.theme.photoEnabled === "false" || lp.theme.photoEnabled === 0)),
          emojiBg: clampHexColor(lp.theme.emojiBg || "#2b2b2b"),
          emojiBgTransparent: (lp.theme.emojiBgTransparent === true || lp.theme.emojiBgTransparent === "true"),
          bubbleColor: clampHexColor(lp.theme.bubbleColor || lp.theme.bgColor || "#ffd0e2"),
          timeColor: clampHexColor(lp.theme.timeColor || "#ffffff"),
          nameColor: clampHexColor(lp.theme.nameColor || "#ffffff"),
          chatNameColor: clampHexColor(lp.theme.chatNameColor || lp.theme.nameColor || "#ffffff"),
          statusTextColor: clampHexColor(lp.theme.statusTextColor || "#ffffff"),
          bubbleTextColor: clampHexColor(lp.theme.bubbleTextColor || "#ffffff"),
          emojiSize: Number(lp.theme.emojiSize || 40),
          photoSize: Number(lp.theme.photoSize || 68)
        };
      }
      return { emoji: "✍️", bgColor: "#ffd0e2", pattern: "none", patternColor:"#ffffff", photoUrl: "", photoEnabled:true, emojiBg:"#2b2b2b", emojiBgTransparent:false, bubbleColor:"#ffd0e2", timeColor:"#ffffff", nameColor:"#ffffff", statusTextColor:"#ffffff", bubbleTextColor:"#ffffff", emojiSize:40, photoSize:68 };
    }

async function ensureMeDoc(){
  // ✅ RTDB presence로 마이그레이션(프로필/상태/타이머/미션)
  const pref = rMePresenceRef(state.roomId, state.uid);
  const today = seoulDateKey();

  const seed = {
    name: (els.name?.value || "").trim(),
    dateKey: today,
    status: "break",
    totalSecondsToday: focusLoadSeconds(),
    sessionStartedAtMs: null,
    bubbleText: (((loadLocalProfile()||{}).bubbleText || "").toString().trim().slice(0,15)),
    theme: defaultTheme(),
    mission: state.myMission || { dayKey: today, text:"", done:false, doneAt:"" },
    lastSeenAtMs: Date.now(),
    updatedAt: Date.now(),
  };

  try{
    const snap = await rGet(pref);
    const data = snap.exists() ? (snap.val() || {}) : null;

    if(!data){
      await rSet(pref, seed);
    }else{
      // day rollover
      if(String(data.dateKey||"") !== String(today)){
        focusSaveSeconds(0);
        await rUpdate(pref, {
          dateKey: today,
          totalSecondsToday: 0,
          sessionStartedAtMs: null,
          status: "break",
          statusSource: "manualMidnight",
          updatedAt: Date.now(),
          lastSeenAtMs: Date.now(),
        });
      }

      // mission seed/rollover
      try{
        const m = state.myMission || loadMissionLocal();
        const need = (!data.mission) || (data.mission?.dayKey !== today);
        if(need){
          const m2 = (m.dayKey===today) ? m : { dayKey: today, text:"", done:false, doneAt:"" };
          state.myMission = m2;
          saveMissionLocal(m2);
          await rUpdate(pref, { mission: m2, updatedAt: Date.now(), lastSeenAtMs: Date.now() });
        }
      }catch(e){}

      // bubbleText seed
      try{
        if(data.bubbleText === undefined || data.bubbleText === null){
          const lp = loadLocalProfile() || {};
          const bt = (lp.bubbleText || "").toString().trim().slice(0,15);
          if(bt) await rUpdate(pref, { bubbleText: bt, updatedAt: Date.now(), lastSeenAtMs: Date.now() });
        }
      }catch(e){}

      // theme seed
      try{
        if(!data.theme){
          await rUpdate(pref, { theme: defaultTheme(), updatedAt: Date.now(), lastSeenAtMs: Date.now() });
        }
      }catch(e){}
    }

    // ✅ presence onDisconnect (브라우저/네트워크 끊기면 자동 제거)
    try{
      if(state._rtdbOnDisc){
        try{ state._rtdbOnDisc.cancel?.(); }catch(e){}
        state._rtdbOnDisc = null;
      }
      state._rtdbOnDisc = rOnDisconnect(pref);
      // ✅ 탭 종료/네트워크 끊김에서도 즉시 OFFLINE 마킹(누적시간 멈춤)
      // - lastSeenAtMs=0: 즉시 오프라인 처리(ONLINE_TTL_MS 대기 없이)
      state._rtdbOnDisc.update({ status:"off", sessionStartedAtMs:null, lastSeenAtMs: 0 });
    }catch(e){}
  }catch(e){
    console.warn("[presence] ensure failed", e);
    // 최소한은 기록
    try{ await rUpdate(pref, { lastSeenAtMs: Date.now(), updatedAt: Date.now() }); }catch(e2){}
  }
}

async function heartbeat(){
  if(!state.roomId || !state.uid) return;
  try{
    const now = Date.now();
    const st = (state.myStatus || "break");
    const patch = { lastSeenAtMs: now, updatedAt: now };

    // ✅ 재접속/일시 끊김으로 status가 "off"에 고정되는 현상 방지:
    // - joined 상태에서는 heartbeat마다 내 status를 함께 올려줌
    if(state.joined){
      patch.status = st;
      patch.statusSource = "hb";
      patch.sessionStartedAtMs = (st === "work") ? (state._workSessionStartedAtMs || now) : null;
    }

    await rUpdate(rMePresenceRef(state.roomId, state.uid), patch);
  }catch(e){}
}

function startRtdbConnectionWatch(){
  try{
    if(state._infoConnUnsub) return;
    const infoRef = rRef(rtdb, ".info/connected");
    let prev = null;
    const onC = (snap)=>{
      const connected = !!(snap && snap.val && snap.val());
      if(prev === null){ prev = connected; return; }

      // false → true (재연결)
      if(!prev && connected){
        try{
          if(state && state.joined && state.roomId && state.uid){
            const now = Date.now();
            const st = (state.myStatus || "break");
            const patch = {
              status: st,
              statusSource: "reconnectNet",
              lastSeenAtMs: now,
              updatedAt: now,
              sessionStartedAtMs: (st === "work") ? (state._workSessionStartedAtMs || now) : null
            };
            rUpdate(rMePresenceRef(state.roomId, state.uid), patch).catch(()=>{});
            heartbeat();
          }
        }catch(e){}
      }
      prev = connected;
    };
    rOnValue(infoRef, onC);
    state._infoConnUnsub = ()=>{ try{ rOff(infoRef, "value", onC); }catch(e){}; state._infoConnUnsub = null; };
  }catch(e){}
}


    function computeDisplayedTotal(p){
      const base = Number(p.totalSecondsToday || 0);
      if(p.status === "work" && p.sessionStartedAtMs){
        return base + Math.max(0, (Date.now() - p.sessionStartedAtMs)/1000);
      }
      return base;
    }

    // --- 활동 감지 (집중 시간 자동 전환) ---
    function bumpActivity(){
      const now = Date.now();
      // 너무 잦은 이벤트는 살짝 줄이기
      if(now - (state.activityThrottleMs || 0) < 800) return;
      state.activityThrottleMs = now;
      state.lastActivityMs = now;
    }
    ["mousemove","mousedown","keydown","scroll","touchstart"].forEach((ev)=>{
      window.addEventListener(ev, bumpActivity, {passive:true});
    });
    document.addEventListener("visibilitychange", ()=>{
      try{
        if(document.visibilityState === "hidden"){
          // ✅ 탭이 백그라운드로 가도 오늘 작업시간 로컬에 저장
          if(state && state.joined) persistMyFocusToLocal();
        }else if(document.visibilityState === "visible"){
          bumpActivity();
        }
      }catch(e){}
    });
    // ✅ 탭 종료/뒤로가기/닫기에서도 최대한 빨리 OFFLINE 처리(누적시간 멈춤)
    (function(){
      let fired = false;
      async function markOfflineBestEffort(){
        if(fired) return; fired = true;
        try{ persistMyFocusToLocal(); }catch(e){}
        try{
          if(state && state.roomId && state.uid){
            await rUpdate(rMePresenceRef(state.roomId, state.uid), {
              status:"off",
              sessionStartedAtMs:null,
              lastSeenAtMs: 0,
              updatedAt: Date.now()
            });
          }
        }catch(e){}
      }
      window.addEventListener("pagehide", ()=>{ markOfflineBestEffort(); }, {capture:true});
      window.addEventListener("beforeunload", ()=>{ markOfflineBestEffort(); }, {capture:true});
    })();


    function stopActivityWatch(){
      if(state.activityWatchTimer){
        clearInterval(state.activityWatchTimer);
        state.activityWatchTimer = null;
      }
      if(state.helperWatchTimer){
        clearInterval(state.helperWatchTimer);
        state.helperWatchTimer = null;
      }
      if(state.dayWatchTimer){
        clearInterval(state.dayWatchTimer);
        state.dayWatchTimer = null;
      }
    }

    // ✅ 로컬 헬퍼(PC 전역 마우스 활동) heartbeat 폴링
    // - 헬퍼가 active=true 를 보내면, 작업방 탭이 백그라운드여도 lastActivityMs를 갱신해서
    //   자동 휴식/자리비움 전환을 막습니다(=웹 밖 작업도 작업중 유지).
    // - 상태를 자동으로 '작업중'으로 올리진 않습니다(수동/기존 규칙 유지).
    
        const HELPER_HEARTBEAT_FRESH_MS = 15000; // 헬퍼 heartbeat 신호 유효시간(ms) (기본 15초)
function helperPairKey(){
      const nick = (state.nickname || "").trim();
      state.helperKeyInvalid = false;
      if(!nick) return "";
      // RTDB key 제한: . # $ [ ] / 는 불가 ('.'가 있으면 헬퍼 경로가 깨져요)
      if(nick.includes(".")){
        state.helperKeyInvalid = true;
        return "";
      }
      return nick;
    }

    // ✅ 로컬 헬퍼 연결 상태 UI
    function updateHelperStatusUI(){
      try{
        const targets = [];
        if(els.helperStatusDot && els.helperStatusText) targets.push([els.helperStatusDot, els.helperStatusText]);
        if(els.helperTopDot && els.helperTopText) targets.push([els.helperTopDot, els.helperTopText]);
        if(!targets.length) return;

        const now = Date.now();
        const lastFresh = Number(state.helperLastFreshMs || 0);
        const connected = !!(lastFresh && (now - lastFresh) <= HELPER_HEARTBEAT_FRESH_MS);
        const active = !!(state.helperActive && connected);

        let cls = "helperDot off";
        let text = "미연결";

        if(state.helperKeyInvalid){
          cls = "helperDot off";
          text = "닉네임에 '.' 포함 → 헬퍼연동 불가";
        }else if(state.helperAuthError){
          cls = "helperDot off";
          text = "읽기권한 없음 (rules)";
        }else if(connected && active){
          cls = "helperDot on";
          text = "헬퍼 감지! 🚨▪️▪️▪️🔥";
        }else if(connected && !active){
          cls = "helperDot wait";
          text = "연결됨 (대기) 💤";
        }

        for(const [dotEl, textEl] of targets){
          dotEl.className = cls;
          textEl.textContent = text;
        }

        // ✅ 디버그(문제 진단용): active/idleSec/mode 표시
        try{
          if(els.helperDebugText){
            const mode = getHelperMode();
            const idleSec = (state.helperIdleSecPresent && Number.isFinite(state.helperIdleSec)) ? state.helperIdleSec : null;
            const z = Number(state.helperIdleZeroStreak || 0);
            let extra = `mode:${mode}`;
            if(state.helperAuthError) extra += " | rules";
            if(state.helperKeyInvalid) extra += " | key";
            if(state.helperConnected){
              extra += ` | active:${state.helperActive ? "Y" : "N"}`;
              if(idleSec !== null){
                extra += ` | idleSec:${idleSec}`;
                if(!state.helperActive && idleSec === 0 && z >= 6) extra += " ⚠️idle0";
              }else{
                // idleSec 미제공이면 웹이 자체 누적
                if(state._helperInactiveSinceMs){
                  const s = Math.floor((Date.now() - state._helperInactiveSinceMs)/1000);
                  extra += ` | idle~${s}s`;
                }
              }
            }
            els.helperDebugText.textContent = extra;
          }
        }catch(e){}

      }catch(e){}
    }


    // ✅ 헬퍼 모드: manual(수동/안전) / auto(자동전환)
    function getHelperMode(){
      try{
        const lp = loadLocalProfile() || {};
        const m = String(lp.helperMode || state.helperMode || "auto");
        return (m === "manual" || m === "auto") ? m : "auto";
      }catch(e){ return (state.helperMode || "auto"); }
    }
    function setHelperMode(mode, save=true){
      const m = (mode === "manual") ? "manual" : "auto";
      state.helperMode = m;
      try{
        if(els.helperMode) els.helperMode.value = m;
        // 자동일 때만 자동전환 분 입력 활성화
        const en = (m === "auto");
        if(els.autoBreakMin) els.autoBreakMin.disabled = !en;
        if(els.autoIdleMin)  els.autoIdleMin.disabled  = !en;
      }catch(e){}
      if(save){
        try{
          const lp = loadLocalProfile() || {};
          lp.helperMode = m;
          saveLocalProfile(lp);
        }catch(e){}
      }
    }

async function pollHelperHeartbeat(){
      try{
        if(!state.joined) return;

        const key = helperPairKey();
        if(!key){
          state.helperConnected = false;
          state.helperActive = false;
          updateHelperStatusUI();
          return;
        }

        // ✅ 헬퍼/작업방 간 스키마 차이를 흡수하기 위해, heartbeat만이 아니라 pair 전체를 읽습니다.
        // - 어떤 헬퍼는 /heartbeat 안에 ts를 넣고
        // - 어떤 헬퍼는 /helperPairs/{nick}/ts 같은 루트에 ts를 둡니다.
        const url = `${RTDB_BASE_URL}/helperPairs/${encodeURIComponent(key)}.json?_=${Date.now()}`;
        const res = await fetch(url, { cache: "no-store" });

        // 네트워크/권한 문제로 읽기 실패 → 마지막 정상 신호가 없으면 미연결 처리
        if(!res.ok){
          const now = Date.now();

          // ✅ rules 권한 문제(401/403) 안내
          if(res.status === 401 || res.status === 403){
            state.helperConnected = false;
            state.helperActive = false;
            state.helperAuthError = true;
            updateHelperStatusUI();

            if(!state._helperAuthWarned){
              showToast("헬퍼 상태 읽기 권한이 없어요(401/403). RTDB rules에서 helperPairs 읽기 허용이 필요해요.");
              state._helperAuthWarned = true;
            }
            return;
          }

          const lastFresh = Number(state.helperLastFreshMs || 0);
          const connected = !!(lastFresh && (now - lastFresh) <= HELPER_HEARTBEAT_FRESH_MS);
          state.helperConnected = connected;
          if(!connected) state.helperActive = false;
          updateHelperStatusUI();
          return;
        }

        state.helperAuthError = false;

        const raw = await res.json();
        if(!raw){
          const now = Date.now();
          const lastFresh = Number(state.helperLastFreshMs || 0);
          const connected = !!(lastFresh && (now - lastFresh) <= HELPER_HEARTBEAT_FRESH_MS);
          state.helperConnected = connected;
          if(!connected) state.helperActive = false;
          updateHelperStatusUI();
          return;
        }

        // ✅ 스키마 호환: hb는 raw.heartbeat가 있으면 그걸 우선
        const hb = (raw && typeof raw === "object" && raw.heartbeat && typeof raw.heartbeat === "object")
          ? raw.heartbeat
          : raw;

        // ✅ active 호환
        const activeRaw = (hb.active ?? raw.active ?? hb.isActive ?? hb.is_active ?? hb.moving ?? hb.isMoving ?? hb.activity ?? hb.state ?? hb.status);
        let activeBool = false;
        if(typeof activeRaw === "boolean") activeBool = activeRaw;
        else if(typeof activeRaw === "number") activeBool = activeRaw > 0;
        else if(typeof activeRaw === "string"){
          const s = activeRaw.toLowerCase();
          activeBool = (s === "active" || s === "work" || s === "working" || s === "moving" || s === "move" || s === "on" || s === "true" || s === "1");
        }

        // ✅ ts 호환(heartbeat 내부/루트/cfg 등)
        const tsRaw = (
          hb.ts ?? raw.ts ??
          hb.timestamp ?? raw.timestamp ??
          hb.time ?? raw.time ??
          hb.t ?? raw.t ??
          hb.serverTs ?? raw.serverTs ??
          hb.server_ts ?? raw.server_ts ??
          hb.lastSeenAtMs ?? raw.lastSeenAtMs ?? raw.lastSeenAt ?? raw.last_seen_at_ms ??
          raw.cfg?.ts ?? raw.cfg?.timestamp ?? raw.cfg?.serverTs ?? raw.cfg?.server_ts ??
          hb.cfg?.ts ?? hb.cfg?.timestamp ?? hb.cfg?.serverTs ?? hb.cfg?.server_ts
        );
        const ts = Number(tsRaw || 0);

        // ✅ idleSec 호환(있으면 더 정확하게 상태 동기화)
        const idleSecRaw = (
          hb.idleSec ?? raw.idleSec ??
          raw.cfg?.idleSec ?? raw.cfg?.idle_sec ??
          hb.cfg?.idleSec ?? hb.cfg?.idle_sec
        );
        const idleSec = Number(idleSecRaw || 0);

        // 헬퍼가 서버 timestamp를 쓰므로, ts는 서버시간(ms)
        const now = Date.now();
        const fresh = ts && Math.abs(now - ts) <= HELPER_HEARTBEAT_FRESH_MS;

        // ✅ fresh 신호일 때만 '마지막 정상 신호' 시각을 갱신
        if(fresh) state.helperLastFreshMs = now;

        const lastFresh = Number(state.helperLastFreshMs || 0);
        const connected = !!(lastFresh && (now - lastFresh) <= HELPER_HEARTBEAT_FRESH_MS);

        state.helperConnected = connected;
        state.helperActive = !!(activeBool && connected);
        state.helperLastTs = ts || 0;

        updateHelperStatusUI();

                // ✅ idleSec/무반응 누적 처리(헬퍼가 idleSec를 못 올리거나 0으로 고정되는 케이스 방어)
        state.helperIdleSecPresent = (idleSecRaw !== undefined && idleSecRaw !== null && idleSecRaw !== "");
        state.helperIdleSec = (Number.isFinite(idleSec) ? idleSec : null);

        if(connected){
          if(state.helperActive){
            state.lastActivityMs = now;
            state._helperInactiveSinceMs = 0;
            state.helperIdleZeroStreak = 0;
          }else{
            // inactive 상태가 유지되면 웹에서 자체적으로 무반응 시간을 누적(헬퍼 idleSec가 고장나도 동작)
            if(!state._helperInactiveSinceMs) state._helperInactiveSinceMs = now;

            // idleSec가 0으로 반복되면 이상 신호로 간주(몇 번까지만 신뢰)
            if(state.helperIdleSecPresent && state.helperIdleSec === 0){
              state.helperIdleZeroStreak = Number(state.helperIdleZeroStreak || 0) + 1;
            }else{
              state.helperIdleZeroStreak = 0;
            }

            // idleSec가 유효(>0)면 마지막 활동 시각을 보정해줌(백그라운드 탭에서도 정확)
            if(state.helperIdleSecPresent && Number.isFinite(state.helperIdleSec) && state.helperIdleSec > 0){
              const impliedLast = now - (state.helperIdleSec * 1000);
              state.lastActivityMs = Math.max(Number(state.lastActivityMs || 0), impliedLast);
              state._helperInactiveSinceMs = Math.min(state._helperInactiveSinceMs || now, impliedLast);
            }
          }
        }

// ✅ helperActive가 '꺼졌다가 켜질 때'(=움직임 재감지) 자동 복귀 규칙
        // - 단, 내가 '자동 전환(auto*)' 때문에 휴식/자리비움이 된 경우에만 work로 복귀
        const prevActive = !!state._prevHelperActive;
        state._prevHelperActive = !!state.helperActive;

        const me = state.currentParticipants ? state.currentParticipants.get(state.uid) : null;
        const status = (state.myStatus || me?.status || "idle");
        const src = String(state.myStatusSource || me?.statusSource || "");

        // 1) 작업중이면: 헬퍼 active 동안은 마지막 활동을 갱신(자동 break/idle 방지)
        if(status === "work" && state.helperActive){
          state.lastActivityMs = now;
          return;
        }

        // 2) 자동으로 break/idle 된 상태에서, 헬퍼가 다시 active(재감지) 되면 작업중으로 복귀
        if(state.helperActive && !prevActive && (status === "break" || status === "idle") && src.startsWith("auto")){
          transitionTo("work","helperResume");
          state.lastActivityMs = now;
          showToast("헬퍼 감지! 🚨▪️▪️▪️🔥", 1800);
        }
      }catch(e){
        const now = Date.now();
        const lastFresh = Number(state.helperLastFreshMs || 0);
        const connected = !!(lastFresh && (now - lastFresh) <= HELPER_HEARTBEAT_FRESH_MS);
        state.helperConnected = connected;
        if(!connected) state.helperActive = false;
        updateHelperStatusUI();
      }
    }
function startHelperWatch(){
      // helper는 1초마다 폴링(헬퍼 ping_seconds 권장=1~2)
      if(state.helperWatchTimer) clearInterval(state.helperWatchTimer);
      state.helperWatchTimer = setInterval(pollHelperHeartbeat, 1000);
      // 즉시 1회
      pollHelperHeartbeat();
    }

    function startActivityWatch(){
      stopActivityWatch();
      startHelperWatch();
      state.activityWatchTimer = setInterval(()=>{
        if(!state.joined || !state.roomId || !state.uid) return;

        const me = state.currentParticipants ? state.currentParticipants.get(state.uid) : null;
        const status = me?.status || "idle";
        if(status !== "work") return;

                // ✅ 자동/수동 모드
        const mode = getHelperMode();
        if(mode !== "auto") return;

        // ✅ 무반응 시간 계산(헬퍼 idleSec가 고장나도, inactive 시작 시각으로 누적)
        let idleMs = Date.now() - (state.lastActivityMs || Date.now());
        if(state.helperConnected){
          if(state.helperActive){
            idleMs = 0;
          }else{
            // 1) 헬퍼가 idleSec를 정확히 올려주면 그 값을 우선 사용
            if(state.helperIdleSecPresent && Number.isFinite(state.helperIdleSec) && state.helperIdleSec > 0){
              idleMs = state.helperIdleSec * 1000;
            }else if(state._helperInactiveSinceMs){
              // 2) idleSec가 없거나 0으로 고정되면, inactiveSince로 누적(헬퍼 이벤트 기반)
              idleMs = Date.now() - state._helperInactiveSinceMs;
            }
          }
        }

        // ✅ 로컬(내 프로필)에서 자동 전환 시간(분)을 읽어 적용
        let ab = 10, ai = 15;
        try{
          const lp = loadLocalProfile() || {};
          ab = Math.min(180, Math.max(1, Number(lp.autoBreakMin ?? 10)));
          ai = Math.min(180, Math.max(1, Number(lp.autoIdleMin ?? 15)));
          if(ai < ab) ai = Math.min(180, ab + 5);
        }catch(e){}
        if(idleMs >= ai*60*1000){
          transitionTo("idle","autoIdle");
          showToast(`${ai}분 무반응 → 자리비움`);
        }else if(idleMs >= ab*60*1000){
          transitionTo("break","autoBreak");
          showToast(`${ab}분 무반응 → 휴식중`);
        }
      }, 15000);

      // ✅ 자정(KST) 넘어가면 집중시간 로컬/내 문서 리셋
      if(state.dayWatchTimer) clearInterval(state.dayWatchTimer);
      state._lastDayKey = state._lastDayKey || seoulDateKey();
      state.dayWatchTimer = setInterval(async ()=>{
        try{
          const dk = seoulDateKey();
          if(!state._lastDayKey) state._lastDayKey = dk;
          if(state._lastDayKey !== dk){
            state._lastDayKey = dk;
            focusSaveSeconds(0);
            // 내가 방에 들어와 있는 상태면 내 문서도 리셋
            if(state.uid && state.roomId){
              const pref = rMePresenceRef(state.roomId, state.uid);
              try{ setHelperMode("manual"); }catch(e){}
              try{ await transitionTo("break","manualMidnight"); }catch(e){}
            }
          }
        }catch(e){}
      }, 60000);

    }

    
async function transitionTo(nextStatus, source="manual"){
  // ✅ 상태 전환 직전 현재 집중시간을 로컬에 누적 저장
  persistMyFocusToLocal();
  if(!state.roomId || !state.uid) return;
  const now = Date.now();

  // ✅ 구독이 꺼져 있어도 UI는 즉시 반영
  state.myStatus = nextStatus;
  state.myStatusSource = source;

  const patch = { status: nextStatus, statusSource: source, updatedAt: now, lastSeenAtMs: now };
  if(nextStatus === "work"){
    patch.sessionStartedAtMs = now;
    state._workSessionStartedAtMs = now;
  }else{
    patch.sessionStartedAtMs = null;
    state._workSessionStartedAtMs = 0;
  }

  // totalSecondsToday는 로컬 기준 누적을 올려줌(읽기 없이)
  try{
    patch.totalSecondsToday = Math.floor(Number(focusLoadSeconds()||0));
    patch.dateKey = seoulDateKey();
  }catch(e){}

  try{
    await rUpdate(rMePresenceRef(state.roomId, state.uid), patch);
  }catch(e){
    console.warn("[status] update failed", e);
  }

  // UI
  state.myStatus = nextStatus;
  syncMyStatusUI();
}

    async function applyProfile(){
      const theme = {
        emoji: ((window.firstEmojiGrapheme|| (typeof firstEmojiGrapheme==='function' ? firstEmojiGrapheme : null) || ((s)=>{ try{const a=Array.from(String(s||'').trim()); return a[0]||'';}catch(e){return '';} }))(els.emoji.value || "✍️")),
        bgColor: clampHexColor(els.bgColor.value),
        pattern: (els.bgPattern && els.bgPattern.value ? els.bgPattern.value : "none"),
        bgPattern: (els.bgPattern && els.bgPattern.value ? els.bgPattern.value : "none"),
        patternColor: clampHexColor((els.patternColor && els.patternColor.value) ? els.patternColor.value : "#ffffff"),
        photoUrl: state.myPhotoUrl || "",
        photoEnabled: (els.photoEnabled ? !!els.photoEnabled.checked : true),
        emojiBg: clampHexColor((els.emojiBgColor && els.emojiBgColor.value) ? els.emojiBgColor.value : "#2b2b2b"),
        emojiBgTransparent: (els.emojiBgTransparent ? !!els.emojiBgTransparent.checked : false),
        bubbleColor: clampHexColor((els.bubbleColor && els.bubbleColor.value) ? els.bubbleColor.value : (els.bgColor ? els.bgColor.value : "#ffd0e2")),
        timeColor: clampHexColor((els.timeColor && els.timeColor.value) ? els.timeColor.value : "#ffffff"),
        nameColor: clampHexColor((els.nameColor && els.nameColor.value) ? els.nameColor.value : "#ffffff"),
        chatNameColor: clampHexColor((els.chatNameColor && els.chatNameColor.value) ? els.chatNameColor.value : ((els.nameColor && els.nameColor.value) ? els.nameColor.value : "#ffffff")),
        statusTextColor: clampHexColor((els.statusTextColor && els.statusTextColor.value) ? els.statusTextColor.value : "#ffffff"),
        bubbleTextColor: clampHexColor((els.bubbleTextColor && els.bubbleTextColor.value) ? els.bubbleTextColor.value : "#ffffff"),
        emojiSize: 82,
        photoSize: 82
      };
      const bubbleText = (els.bubbleText.value || "").trim().slice(0, 15);
      const newNick = (els.profileNick?.value || "").trim().slice(0,20);
      if(newNick){
        state.nickname = newNick;
        if(els.name) els.name.value = newNick;
        try{ localStorage.setItem("mk_last_name", newNick); }catch(e){}
      }


      // ✅ 자동 전환(분) — 작업중일 때만 적용
      const autoBreakMin = Math.min(180, Math.max(1, Number(els.autoBreakMin?.value || 10)));
      const autoIdleMin  = Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || 15)));
      if(autoIdleMin < autoBreakMin){ /* 안전장치 */
        // 자리비움이 휴식보다 빨라지면 휴식+5로 보정
        const fixed = Math.min(180, autoBreakMin + 5);
        if(els.autoIdleMin) els.autoIdleMin.value = String(fixed);
      }


      // ✅ 헬퍼 모드 반영
      try{ setHelperMode((els.helperMode && els.helperMode.value==='manual')?'manual':'auto', true); }catch(e){}

      // ✅ 브라우저에 프리셋 저장(로그인/입장 전에도 유지)
      try{
        const lp = loadLocalProfile() || {};
        lp.theme = theme;
        lp.bubbleText = bubbleText;
        if(state.nickname) lp.nickname = state.nickname;
        lp.autoBreakMin = Math.min(180, Math.max(1, Number(els.autoBreakMin?.value || lp.autoBreakMin || 10)));
        lp.helperMode = (els.helperMode && els.helperMode.value==='manual') ? 'manual' : 'auto';
        lp.autoIdleMin  = Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || lp.autoIdleMin || 15)));
        if(lp.autoIdleMin < lp.autoBreakMin) lp.autoIdleMin = Math.min(180, lp.autoBreakMin + 5);
        saveLocalProfile(lp);
      }catch(e){}

      // 입장 전(아직 uid 없음)이면 로컬만 저장하고 끝
      if(!state.uid || !state.roomId){
        showToast("저장! (이 브라우저에 기억해둘게)");
        hideModal(els.profileModal);
        return;
      }

      const pref = rMePresenceRef(state.roomId, state.uid);
      await rUpdate(pref, { theme, bubbleText, name: (state.nickname || undefined), autoBreakMin, autoIdleMin: Math.min(180, Math.max(1, Number(els.autoIdleMin?.value || 15))), updatedAt: Date.now(), lastSeenAtMs: Date.now() });
      try{
        await rPush(rProfileUpdatesRootRef(state.roomId), {
          uid: state.uid,
          name: state.nickname || (els.name?.value||"").trim(),
          tsMs: Date.now(),
          type: "profile_update",
          theme,
          bubbleText
        });
      }catch(e){}


      // ✅ 즉시 반영(스냅샷 대기 없이 내 타일부터 갱신)
      try{
        const meNow = state.currentParticipants?.get?.(state.uid);
        if(meNow){
          meNow.theme = Object.assign({}, (meNow.theme||{}), theme);
          state.currentParticipants.set(state.uid, meNow);
          // 캐시 무효화 후 재렌더
          try{ state.lastRendered?.delete?.(state.uid); }catch(e){}
          const arr = [...state.currentParticipants.values()];
          const onlineArr = arr.filter(p=> isDisplayablePresence(p));
          onlineArr.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));
          renderGridTilesOrRoster(onlineArr);
        }
      }catch(e){}

      showToast("저장!");
      hideModal(els.profileModal);
}

    function updatePhotoEnabledUI(){
      const on = (els.photoEnabled ? !!els.photoEnabled.checked : true);
      if(els.photoUploadRow) els.photoUploadRow.style.display = on ? "" : "none";
      if(els.photoSizeRow) els.photoSizeRow.style.display = on ? "" : "none";
    }

    // Photo upload (Storage)
    async function uploadPhoto(){
      const f = els.photoFile.files?.[0];
      if(!f){ showToast("파일 선택!"); return; }
      if(f.size > 2 * 1024 * 1024){ showToast("2MB 이하 추천!"); return; }
      if(!/^image\//.test(f.type) && !/\.gif$/i.test(f.name)){ showToast("이미지 파일만!"); return; }

      const path = `rooms/${state.roomId}/avatars/${state.uid}/profile`; // overwrite-friendly
      const ref = sRef(storage, path);

      try{
        await uploadBytes(ref, f, { contentType: f.type || "image/gif" });
        const url = await getDownloadURL(ref);
        state.myPhotoUrl = url;
        // ✅ 업로드 시 로컬 설정에도 즉시 저장(재입장 시 유지)
        try{
          const lp = loadLocalProfile() || {};
          lp.theme = lp.theme || {};
          const oldUrl = (lp.theme.photoUrl || "");
          if(oldUrl && oldUrl !== url){
            try{
              localStorage.removeItem("mk_photo_cache_url_v1");
              localStorage.removeItem("mk_photo_cache_blob_v1");
            }catch(e){}
          }
          lp.theme.photoUrl = url;
          saveLocalProfile(lp);
          try{ localStorage.setItem("mk_photo_cache_url_v1", url); }catch(e){}
        }catch(e){}
        await rUpdate(rMePresenceRef(state.roomId, state.uid), {
          "theme/photoUrl": url,
          updatedAt: Date.now(),
          lastSeenAtMs: Date.now()
        });
        showToast("업로드 완료!");
      }catch(e){
        console.error(e);
        showToast("업로드 실패(스토리지 규칙/설정 확인)");
      }
    }

    // Room subscribe (dashboard links)
    function coerceCount(v){
  if(v==null) return null;
  if(typeof v==="number" && isFinite(v)) return v;
  if(typeof v==="string"){
    const s=v.trim().replace(/,/g,"");
    if(s==="" ) return null;
    const n=Number(s);
    if(!Number.isNaN(n) && isFinite(n)) return n;
    return v; // fallback keep string
  }
  if(Array.isArray(v)) return v.length;
  if(typeof v==="object"){
    // common keys
    const keys = ["count","online","onlineCount","users","userCount","members","memberCount","value","total","n","num","size","length"];
    for(const k of keys){
      if(v[k]!=null){
        const r=coerceCount(v[k]);
        if(r!=null) return r;
      }
    }
    // first numeric-looking property
    for(const [k,val] of Object.entries(v)){
      const r=coerceCount(val);
      if(typeof r==="number") return r;
    }
    return null;
  }
  return null;
}

    function renderDashboard(){
  try{
    const joined = !!state.joined;
    if(!joined){
      try{ if(els.pomoCount) els.pomoCount.textContent = "—"; }catch(e){}
      try{ if(els.sudaCount) els.sudaCount.textContent = "—"; }catch(e){}
      try{ if(els.pomoOk) els.pomoOk.textContent = "—"; }catch(e){}
      try{ if(els.sudaOk) els.sudaOk.textContent = "—"; }catch(e){}
      try{ if(els.goPomo){ els.goPomo.disabled = true; els.goPomo.onclick = null; } }catch(e){}
      try{ if(els.goSuda){ els.goSuda.disabled = true; els.goSuda.onclick = null; } }catch(e){}
      try{ if(els.goPomoMini){ els.goPomoMini.disabled = true; els.goPomoMini.onclick = null; } }catch(e){}
      try{ if(els.goSudaMini){ els.goSudaMini.disabled = true; els.goSudaMini.onclick = null; } }catch(e){}
      return;
    }

    const d = (state.roomSettings && state.roomSettings.dashboard) ? state.roomSettings.dashboard : {};
    const cRemote = (state.roomSettings && state.roomSettings.dashCounts) ? state.roomSettings.dashCounts : {};
    const cLocal = state.localDashCounts || {};
    const c = (cLocal && (cLocal.pomoCount!=null || cLocal.sudaCount!=null)) ? cLocal : cRemote;

    const pomoVal = coerceCount(c.pomoCount);
    const sudaVal = coerceCount(c.sudaCount);

    if(els.pomoCount) els.pomoCount.textContent = (pomoVal!=null ? pomoVal : "—");
    if(els.sudaCount) els.sudaCount.textContent = (sudaVal!=null ? sudaVal : "—");

    // raw 값이 객체면 툴팁으로 확인 가능하게
    if(els.pomoCount) els.pomoCount.title = (typeof c.pomoCount==="object" ? JSON.stringify(c.pomoCount) : "");
    if(els.sudaCount) els.sudaCount.title = (typeof c.sudaCount==="object" ? JSON.stringify(c.sudaCount) : "");

    const updated = c.updatedAtMs ? new Date(c.updatedAtMs).toLocaleString("ko-KR") : "-";
    if(els.dashUpdated) els.dashUpdated.textContent = updated;

    // 링크는 새 탭으로만 (입장 후에만 활성)
    if(els.goPomo){
      els.goPomo.disabled = !d.pomoUrl;
      els.goPomo.onclick = d.pomoUrl ? ()=>openUrl(d.pomoUrl) : null;
    }
    if(els.goPomoMini){
      els.goPomoMini.disabled = !d.pomoUrl;
      els.goPomoMini.onclick = d.pomoUrl ? ()=>openUrl(d.pomoUrl) : null;
    }
    if(els.goSuda){
      els.goSuda.disabled = !d.sudaUrl;
      els.goSuda.onclick = d.sudaUrl ? ()=>openUrl(d.sudaUrl) : null;
    }
    if(els.goSudaMini){
      els.goSudaMini.disabled = !d.sudaUrl;
      els.goSudaMini.onclick = d.sudaUrl ? ()=>openUrl(d.sudaUrl) : null;
    }
    if(els.goChool) els.goChool.onclick = ()=>openUrlJoined(d.choolUrl);
    if(els.goSheet) els.goSheet.onclick = ()=>openUrlJoined(d.sheetUrl);
    if(els.goMacHelper) els.goMacHelper.onclick = ()=>openUrlJoined(MAC_HELPER_URL);
    if(els.goWinHelper) els.goWinHelper.onclick = ()=>openUrlJoined(WIN_HELPER_URL);

    if(els.pomoUrl) els.pomoUrl.value = d.pomoUrl || "";
    if(els.sudaUrl) els.sudaUrl.value = d.sudaUrl || "";
    if(els.choolUrl) els.choolUrl.value = d.choolUrl || "";
    if(els.sheetUrl) els.sheetUrl.value = d.sheetUrl || "";
    if(els.dashApiUrl) els.dashApiUrl.value = d.dashApiUrl || "";
  }catch(e){}
}

    
function subscribeRoom(){
  // ✅ RTDB로 마이그레이션: 대시보드 링크/관리자해시 + (선택) 집계값
  try{ if(state.unsubRoom) state.unsubRoom(); }catch(e){}
  try{ if(state.unsubDashCounts) state.unsubDashCounts(); }catch(e){}
  state.unsubRoom = null;
  state.unsubDashCounts = null;
  if(!state.nonChatEnabled){ return; }

  const sref = rSettingsRef(state.roomId);
  const onSettings = (snap)=>{
    const r = (snap && snap.exists && snap.exists()) ? (snap.val()||{}) : (snap?.val?.()||{});
    const dash = Object.assign(
      {pomoUrl:"", sudaUrl:"", choolUrl:"", sheetUrl:"", dashApiUrl: DEFAULT_DASH_API_URL},
      (r.dashboard || {})
    );
    state.roomSettings.dashboard = dash;
    state.roomSettings.adminHash = r.adminHash || null;
    state.adminHash = state.roomSettings.adminHash;

    // counts는 별도 구독이지만, settings에 들어있으면 fallback
    if(r.dashCounts && !state.roomSettings.dashCounts) state.roomSettings.dashCounts = r.dashCounts;

    ensureDashPolling();
    renderDashboard();
  };
  try{
    rOnValue(sref, onSettings);
    state.unsubRoom = ()=>{ try{ rOff(sref, "value", onSettings); }catch(e){} };
  }catch(e){
    console.warn("[room] subscribe settings failed", e);
  }

  const cref = rDashboardCountsRef(state.roomId);
  const onCounts = (snap)=>{
    const v = (snap && snap.exists && snap.exists()) ? (snap.val()||{}) : (snap?.val?.()||{});
    state.roomSettings.dashCounts = v || {pomoCount:null, sudaCount:null, updatedAtMs:null};
    renderDashboard();
  };
  try{
    rOnValue(cref, onCounts);
    state.unsubDashCounts = ()=>{ try{ rOff(cref, "value", onCounts); }catch(e){} };
  }catch(e){}
}

// Admin settings
async function unlockAdmin(){
  const pass = (els.adminPass.value || "").trim();
  if(!pass){ showToast("관리자 비번 입력"); return; }
  const hash = await sha256Hex(pass);

  // settings가 비어있으면 등록
  if(!state.adminHash){
    try{
      await rUpdate(rSettingsRef(state.roomId), { adminHash: hash });
      state.adminHash = hash;
      state.adminOk = true;
      els.adminArea.style.display = "block";
      showToast("비번 등록!");
      return;
    }catch(e){
      console.warn(e);
      showToast("비번 등록 실패(권한/rules 확인)");
      return;
    }
  }

  if(hash === state.adminHash){
    state.adminOk = true;
    els.adminArea.style.display = "block";
    showToast("확인 완료!");
  }else{
    state.adminOk = false;
    els.adminArea.style.display = "none";
    showToast("비번이 달라…");
  }
}

async function saveDashboard(){
  if(!state.adminOk){ showToast("관리자 확인부터!"); return; }
  const dashboard = {
    pomoUrl: (els.pomoUrl.value || "").trim(),
    sudaUrl: (els.sudaUrl.value || "").trim(),
    choolUrl: (els.choolUrl.value || "").trim(),
    sheetUrl: (els.sheetUrl.value || "").trim(),
    dashApiUrl: (els.dashApiUrl && els.dashApiUrl.value ? els.dashApiUrl.value : "").trim(),
  };
  try{
    await rUpdate(rSettingsRef(state.roomId), { dashboard });
    showToast("저장!");
  }catch(e){
    console.warn(e);
    showToast("저장 실패(권한/rules 확인)");
  }
}


    // Chat
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    const CHAT_MAX_VIEW = 100;
    // If mission events share the same collection, fetch a bit more so chat still shows up to 70.
    const CHAT_QUERY_LIMIT = 10; // ✅ always load last 10 to reduce reads (first/re-entry)
    const CHAT_KEEP_MAX = 50;   // ✅ while staying in room, keep up to 50 in memory/UI
    // ✅ Reactions (간단 이모지)
    const REACTS = [
      { k:"heart", e:"❤️" },
      { k:"boom",  e:"👍" },
      { k:"fire",  e:"🔥" },
    ];

    
function __getMyReactOn(msgObj, emoji){
      try{
        if(!msgObj || !emoji || !state || !state.uid) return false;
        const reacts = (msgObj.reactions || msgObj.react || null);
        if(!reacts || !reacts[emoji]) return false;
        return !!(reacts[emoji][state.uid]);
      }catch(e){ return false; }
    }

    async function toggleReaction(msgId, emoji){
  if(!state.roomId || !state.uid) return;

  // ✅ 현재 캐시 기준으로 on/off 판정
  let msgObj = null;
  try{ msgObj = state.chatCacheById ? (state.chatCacheById.get ? state.chatCacheById.get(msgId) : null) : null; }catch(e){}
  const wasOn = __getMyReactOn(msgObj, emoji);
  const wantOn = !wasOn;

  const base = (typeof rChatMsgRef === "function") ? rChatMsgRef(state.roomId, msgId) : rMessageRef(state.roomId, msgId);

  // ✅ rules 호환을 위해 reactions → react 순으로 시도
  const keysToTry = ["reactions","react"];
  let lastErr = null;
  // auth guard
  try{
    if(!state.uid || !auth.currentUser){
      showToast("로그인 준비 중이라 리액션을 저장할 수 없어요 😿 잠깐만 다시 눌러줘!", 2600);
      return;
    }
  }catch(e){}

  for(const key of keysToTry){
    try{
      const myLeaf = rChild(base, `${key}/${emoji}/${state.uid}`);
      if(wantOn){
        await rSet(myLeaf, 1);
      }else{
        await rRemove(myLeaf);
      }

      // ✅ 로컬 캐시도 즉시 반영(렌더 지연/권한 실패 구분)
      try{
        if(msgObj){
          msgObj[key] = msgObj[key] || {};
          msgObj[key][emoji] = msgObj[key][emoji] || {};
          if(wantOn){
            msgObj[key][emoji][state.uid] = 1;
          }else{
            delete msgObj[key][emoji][state.uid];
            if(Object.keys(msgObj[key][emoji] || {}).length === 0) delete msgObj[key][emoji];
          }
        }
      }catch(e){}

      return;
    }catch(e){
      lastErr = e;
    }
  }

  console.warn("[react] failed", lastErr);
  let code = "";
  try{ code = String(lastErr?.code || lastErr?.name || "").toLowerCase(); }catch(e){}
  let msg = "리액션 저장이 안 돼요 😿";
  if(code) msg += ` (${code})`;
  const m = String(lastErr?.message || "");
  if(code.includes("permission") || m.includes("PERMISSION_DENIED") || m.includes("permission_denied")){
    msg += " — RTDB rules에서 rooms/{roomId}/messages/{msgId}/reactions 쓰기 허용 필요";
  }else if(m){
    msg += " — 콘솔 에러 참고";
  }
  showToast(msg, 4200);
}

    function makeMsgNode(m){
      const div = document.createElement("div");

      // ✅ system message
      if(m && m.type === "sys"){
        div.className = "msg system";
                try{ div.setAttribute("data-msg-id", String(m.id||"")); }catch(e){}
div.innerHTML = `<div class="text">${escapeHtml(m.text || "")}</div>`;
        return div;
      }

      const isMe = (m.uid && state.uid && m.uid === state.uid);
      div.className = "msg " + (isMe ? "me" : "other");
            try{ div.setAttribute("data-msg-id", String(m.id||"")); }catch(e){}
const p = (m.uid && state.currentParticipants) ? state.currentParticipants.get(m.uid) : null;
      const emoji = (p && p.theme && p.theme.emoji) ? String(p.theme.emoji) : "💬";
      const nick = (m.name || (p && p.name) || "익명");
      div.innerHTML = `
        <div class="meta"><span><span class="chatEmoji">${escapeHtml(emoji)}</span><span class="chatName">${escapeHtml(nick)}</span></span></div>
        <div class="text">${escapeHtml(m.text || "")}</div>
      `;

      // theme-based text colors (if provided)
      try{
        const nc = p && p.theme && (p.theme.chatNameColor || p.theme.nameColor) ? clampHexColor(p.theme.chatNameColor || p.theme.nameColor) : null;
        if(nc){
          const nEl = div.querySelector(".chatName");
          if(nEl) nEl.style.color = nc;
        }
      }catch(e){}

      // ✅ reactions (others' messages only)
      try{
        if(m && m.id){
          const react = ((m.reactions && typeof m.reactions==="object") ? m.reactions : ((m.react && typeof m.react==="object") ? m.react : {}));

          // 1) show ONLY used reactions under the message
          const chips = document.createElement("div");
          chips.className = "reactRow";
          let hasAny = false;

          for(const r of REACTS){
            const bucket = (react[r.k] && typeof react[r.k]==="object") ? react[r.k] : {};
            const cnt = Object.keys(bucket).length;
            if(!cnt) continue;

            hasAny = true;
            const on = !!bucket[state.uid];
            const b = document.createElement("button");
            b.type = "button";
            b.className = "reactBtn reactChip" + (on ? " on" : "");
            b.setAttribute("data-react-key", r.k);
            b.setAttribute("data-msg-id", m.id);
            b.innerHTML = `${escapeHtml(r.e)}<span class="reactCount">${cnt}</span>`;
            chips.appendChild(b);
          }
          if(hasAny) div.appendChild(chips);
          try{ chips.scrollLeft = 0; }catch(e){}

          // 2) hover toggle (opens picker)
          const tgl = document.createElement("button");
          tgl.type = "button";
          tgl.className = "reactToggle";
          tgl.setAttribute("data-msg-id", m.id);
          tgl.textContent = "😊";
          div.appendChild(tgl);

          // 3) picker (shows all options when toggled)
          const picker = document.createElement("div");
          picker.className = "reactPicker";
          picker.setAttribute("data-msg-id", m.id);

          for(const r of REACTS){
            const bucket = (react[r.k] && typeof react[r.k]==="object") ? react[r.k] : {};
            const on = !!bucket[state.uid];
            const b = document.createElement("button");
            b.type = "button";
            b.className = "reactBtn reactPick" + (on ? " on" : "");
            b.setAttribute("data-react-key", r.k);
            b.setAttribute("data-msg-id", m.id);
            b.innerHTML = `${escapeHtml(r.e)}`;
            picker.appendChild(b);
          }
          div.appendChild(picker);
          try{ picker.scrollLeft = 0; }catch(e){}
        }
      }catch(e){}

      return div;
    }

    function renderChatFull(list, forceBottom){
      const el = els.chatList;
      if(!el) return;
      const nearBottom = (typeof forceBottom === "boolean") ? forceBottom : isChatNearBottom();

      // ✅ keep "more" bar (inside chatList) across full re-renders
      let keepMore = null;
      try{
        keepMore = document.getElementById("chatMoreBar");
        if(keepMore) keepMore.remove();
      }catch(e){ keepMore = null; }

      const prevTop = el.scrollTop || 0;
      const prevH = el.scrollHeight || 0;

      el.innerHTML = "";
      if(keepMore) el.appendChild(keepMore);

      const frag = document.createDocumentFragment();
      for(const m of list){
        frag.appendChild(makeMsgNode(m));
      }
      el.appendChild(frag);

      if(nearBottom){
        requestAnimationFrame(()=>{ try{ el.scrollTop = el.scrollHeight; }catch(e){} });
      }else{
        // keep scroll position roughly stable when older messages are prepended
        const newH = el.scrollHeight || 0;
        const delta = newH - prevH;
        if(delta > 0 && (state.chatDidPrependOnce)){
          try{ el.scrollTop = prevTop + delta; }catch(e){}
          state.chatDidPrependOnce = false;
        }
      }
    }

    function isChatNearBottom(){
      try{
        const el = els.chatList;
        if(!el) return true;
        const threshold = 24;
        return (el.scrollTop + el.clientHeight >= el.scrollHeight - threshold);
      }catch(e){ return true; }
    }
    function scrollChatToBottom(){
      try{
        const el = els.chatList;
        if(!el) return;
        el.scrollTop = el.scrollHeight;
      }catch(e){}
    }
    function showChatNewBar(){
      if(!els.chatNewBar || !els.chatUnseenCount) return;
      if(state.chatUnseen <= 0) return;
      els.chatUnseenCount.textContent = String(state.chatUnseen);
      els.chatNewBar.style.display = "flex";
    }
    function hideChatNewBar(reset=false){
      if(reset) state.chatUnseen = 0;
      if(els.chatNewBar) els.chatNewBar.style.display = "none";
    }

    
function subscribeChat(){
  // clean up existing listeners
  try{ if(state.unsubChat) state.unsubChat(); }catch(e){}
  try{ if(state.unsubChatChg) state.unsubChatChg(); }catch(e){}
  try{ if(state.unsubChatLive) state.unsubChatLive(); }catch(e){}
  state.chatDisplayIds = [];
  state.chatRollingById = {};
  state.chatCache = [];
  state.chatCacheById = {};
  state.chatFirstLoadDone = false;
  state.chatDidPrependOnce = false;

  // limits (requested)
  const INIT_LIMIT = 10;   // 입장 시
  const STAY_LIMIT = 20;   // 입장 유지 시
  const MORE_LIMIT = 20;   // 더보기 1회
  const MAX_LIMIT  = 40;   // 총 최대(20+20)

  state.chatWindowMax = STAY_LIMIT;     // currently enforced visible window
  state.chatMoreUsed = false;           // 더보기 사용 여부(1회)
  state.chatStayExpanded = false;       // 10 -> 20 확장 완료 여부

  const root = rMessagesRootRef(state.roomId);

  function normalizeDocsFromSnapVal(valObj){
    const docs = [];
    for(const [id, data] of Object.entries(valObj || {})){
      if(!data) continue;
      docs.push({ id, ...data });
    }
    docs.sort((a,b)=>{
      const ta = Number(a.tsMs||0);
      const tb = Number(b.tsMs||0);
      if(ta !== tb) return ta - tb;
      return String(a.id||"").localeCompare(String(b.id||""));
    });
    // mission/sfx 제외(채팅만)
    return docs.filter(m => !(m && (m.type === "mission" || m.type === "sfx" || m.type === "ticker")));
  }

  function rebuildCacheFromMap(){
    let merged = Object.values(state.chatRollingById || {});
    merged.sort((a,b)=>{
      const ta = Number(a.tsMs||0);
      const tb = Number(b.tsMs||0);
      if(ta !== tb) return ta - tb;
      return String(a.id||"").localeCompare(String(b.id||""));
    });
    // enforce window max (20 or 40)
    const keep = Math.max(1, Number(state.chatWindowMax||STAY_LIMIT));
    merged = merged.slice(-keep);
    // rebuild map
    const nextMap = {};
    for(const mm of merged){
      if(mm && mm.id) nextMap[mm.id] = mm;
    }
    state.chatRollingById = nextMap;
    // cache
    state.chatCache = merged;
    state.chatCacheById = {};
    for(const mm of merged){ if(mm && mm.id) state.chatCacheById[mm.id] = mm; }
    return merged;
  }

  function ensureChatMoreUI(){
    if(!els.chatList) return;
    let bar = document.getElementById("chatMoreBar");
    if(!bar){
      bar = document.createElement("div");
      bar.id = "chatMoreBar";
      bar.className = "chatNewBar chatMoreBar";
      bar.style.marginTop = "0";
      bar.style.marginBottom = "8px";
      bar.style.display = "none";

      const btn = document.createElement("button");
      btn.type = "button";
      btn.id = "chatMoreBtn";
      btn.className = "chatJumpBtn";
      btn.textContent = "⬆️ 더보기(과거 20개)";
      btn.addEventListener("click", async ()=>{
        if(state.chatMoreUsed) return;
        try{ btn.disabled = true; }catch(e){}
        try{
          await loadMoreOlderOnce();
        }finally{
          try{ btn.disabled = false; }catch(e){}
          updateChatMoreUI();
        }
      });
      bar.appendChild(btn);
    }
    // keep at top of chatList
    try{
      if(els.chatList.firstChild !== bar){
        els.chatList.prepend(bar);
      }
    }catch(e){}
  }

  function updateChatMoreUI(){
    const bar = document.getElementById("chatMoreBar");
    if(!bar || !els.chatList) return;
    const atTop = (els.chatList.scrollTop || 0) <= 60; // ✅ 약간만 위로 올려도 더보기 노출
    const can = state.chatStayExpanded && !state.chatMoreUsed;
    bar.style.display = (can && atTop) ? "flex" : "none";
  }

  async function loadLastOnce(n){
    const q = rQuery(root, rOrderByChild("tsMs"), rLimitToLast(n));
    const snap = await rGet(q);
    const val = snap && snap.val ? (snap.val() || {}) : {};
    return normalizeDocsFromSnapVal(val);
  }

  async function loadBeforeTs(ts, n){
    // load older messages (endAt(ts-1)) up to n
    const end = Number(ts||0) - 1;
    if(!end || end < 0) return [];
    const q = rQuery(root, rOrderByChild("tsMs"), rEndAt(end), rLimitToLast(n));
    const snap = await rGet(q);
    const val = snap && snap.val ? (snap.val() || {}) : {};
    return normalizeDocsFromSnapVal(val);
  }

  async function expandToStayLimit(){
    if(state.chatStayExpanded) return;
    const current = rebuildCacheFromMap();
    if(current.length >= STAY_LIMIT){
      state.chatStayExpanded = true;
      return;
    }
    const oldest = current[0];
    const oldestTs = Number(oldest?.tsMs||0);
    if(!oldestTs) { state.chatStayExpanded = true; return; }
    const need = STAY_LIMIT - current.length;
    const older = await loadBeforeTs(oldestTs, Math.min(need, STAY_LIMIT));
    if(older && older.length){
      // prepend older
      for(const mm of older){
        if(mm && mm.id) state.chatRollingById[mm.id] = mm;
      }
      // flag for scroll anchoring
      state.chatDidPrependOnce = true;
    }
    state.chatStayExpanded = true;
    const list = rebuildCacheFromMap();
    const nearBottom = true;
    renderChatFull(list, nearBottom);
    state.chatDisplayIds = list.map(m=>m.id);
    try{
      state.chatUnseen = 0; hideChatNewBar(true);
    }catch(e){}
  }

  async function loadMoreOlderOnce(){
    if(state.chatMoreUsed) return;
    const current = rebuildCacheFromMap();
    if(!current.length) { state.chatMoreUsed = true; return; }
    const oldestTs = Number(current[0]?.tsMs||0);
    if(!oldestTs){ state.chatMoreUsed = true; return; }

    const older = await loadBeforeTs(oldestTs, MORE_LIMIT);
    if(older && older.length){
      // increase window to 40
      state.chatWindowMax = MAX_LIMIT;
      for(const mm of older){
        if(mm && mm.id) state.chatRollingById[mm.id] = mm;
      }
      state.chatDidPrependOnce = true;
      const list = rebuildCacheFromMap();
      // not force bottom; keep scroll anchored
      renderChatFull(list, false);
      state.chatDisplayIds = list.map(m=>m.id);
    }
    state.chatMoreUsed = true;
  }

  // initial load 10
  (async ()=>{
    try{
      const initial = await loadLastOnce(INIT_LIMIT);
      // seed map
      for(const mm of initial){
        if(mm && mm.id) state.chatRollingById[mm.id] = mm;
      }
      const list = rebuildCacheFromMap();
      renderChatFull(list, true);
      state.chatDisplayIds = list.map(m=>m.id);
      state.chatFirstLoadDone = true;
      try{ state.chatUnseen = 0; hideChatNewBar(true); }catch(e){}
      // ensure UI bits
      ensureChatMoreUI();
      updateChatMoreUI();

      // auto expand to 20 after "stay"
      setTimeout(()=>{ try{ expandToStayLimit().then(()=>{ ensureChatMoreUI(); updateChatMoreUI(); }); }catch(e){} }, 1200);

      // live listener: only new items from latestTs+1
      const latestTs = Number(list[list.length-1]?.tsMs||0) || 0;
      const liveFrom = latestTs ? (latestTs + 1) : 0;
      const qLive = liveFrom
        ? rQuery(root, rOrderByChild("tsMs"), rStartAt(liveFrom))
        : rQuery(root, rOrderByChild("tsMs"));

      const onAdd = (snap)=>{
        try{
          const id = snap.key;
          const data = snap.val ? snap.val() : null;
          if(!id || !data) return;
          const mm = { id, ...data };
          // ✅ Ticker(입장 알림 등): 채팅에 렌더하지 않고 상단 띠로만 표시
          if(mm && mm.type==="ticker"){
            try{
              const ts = Number(mm.tsMs||0);
              // 중복 방지(같은 세션에서 빠르게 여러 번 들어올 때)
              const last = Number(sessionStorage.getItem("lastTickerTs") || 0);
              if(!ts || ts > last){
                sessionStorage.setItem("lastTickerTs", String(ts||Date.now()));
                showJoinTicker(mm.text||"");
              }
            }catch(e){}
            return;
          }
          // ✅ SFX는 렌더하지 않고 재생만
          if(mm && mm.type==="sfx"){
            try{
              const ts = Number(mm.tsMs||0);
              if(!state.sfxInitDone){
                state.lastSfxTs = Math.max(Number(state.lastSfxTs||0), ts||0);
                state.sfxInitDone = true;
              }else if(ts && ts > (state.lastSfxTs||0)){
                state.lastSfxTs = ts;
                if(!(mm.uid && state.uid && mm.uid === state.uid)) playSfx(mm.kind);
              }
            }catch(e){}
            return;
          }
          if(mm && mm.type==="mission") return;

          // SFX 재생(초기 기준 없으면 잡아둠)
          try{
            if(mm.type === "sfx"){
              const ts = Number(mm.tsMs||0);
              if(ts && ts > (state.lastSfxTs||0)){
                state.lastSfxTs = ts;
                if(!(mm.uid && state.uid && mm.uid === state.uid)) playSfx(mm.kind);
              }
            }
          }catch(e){}

          const nearBottom = isChatNearBottom();
          state.chatUserNearBottom = nearBottom;

          // add & trim
          state.chatRollingById[id] = mm;
          const list2 = rebuildCacheFromMap();
          const newIds = list2.map(m=>m.id);
          const oldIds = state.chatDisplayIds || [];

          if(oldIds.length){
            const oldSet = new Set(oldIds);
            const addCount = newIds.filter(x=>!oldSet.has(x)).length;
            if(addCount > 0 && !nearBottom){
              state.chatUnseen = (Number(state.chatUnseen)||0) + addCount;
              showChatNewBar();
            }else if(nearBottom){
              hideChatNewBar(true);
            }
          }

          renderChatFull(list2, nearBottom);
          state.chatDisplayIds = newIds;

          ensureChatMoreUI();
          updateChatMoreUI();
        }catch(e){}
      };

      rOnChildAdded(qLive, onAdd);
      state.unsubChatLive = ()=>{ try{ rOff(qLive, "child_added", onAdd); }catch(e){} };

      // change listener (reactions / edits)
      const qChg = rQuery(root, rOrderByChild("tsMs"), rLimitToLast(CHAT_MAX_VIEW));
      const onChg = (snap)=>{
        try{
          const id = snap.key;
          const data = snap.val ? snap.val() : null;
          if(!id || !data) return;
          const mm = { id, ...data };
          if(mm && (mm.type==="mission" || mm.type==="sfx" || mm.type==="ticker")) return;

          // update only if we have it
          if(state.chatRollingById && state.chatRollingById[id]){
            state.chatRollingById[id] = mm;
            const list3 = rebuildCacheFromMap();
            renderChatFull(list3, state.chatUserNearBottom);
            state.chatDisplayIds = list3.map(m=>m.id);
            ensureChatMoreUI();
            updateChatMoreUI();
          }
        }catch(e){}
      };
      rOnChildChanged(qChg, onChg);
      state.unsubChatChg = ()=>{ try{ rOff(qChg, "child_changed", onChg); }catch(e){} };

      // attach scroll-top watcher for "more" bar
      if(els.chatList && !state._chatMoreScrollHooked){
        state._chatMoreScrollHooked = true;
        els.chatList.addEventListener("scroll", ()=>{ try{ updateChatMoreUI(); }catch(e){} }, { passive:true });
      }

    }catch(e){
      console.error(e);
      // fall back to old onValue if something blows up
      try{
        const q = rQuery(root, rOrderByChild("tsMs"), rLimitToLast(INIT_LIMIT));
        const onMsgs = (snap)=>{
          const val = snap && snap.val ? (snap.val() || {}) : {};
          const list = normalizeDocsFromSnapVal(val);
          // enforce stay limit
          state.chatRollingById = {};
          for(const mm of list.slice(-STAY_LIMIT)){ if(mm && mm.id) state.chatRollingById[mm.id] = mm; }
          const merged = rebuildCacheFromMap();
          renderChatFull(merged, true);
          state.chatDisplayIds = merged.map(m=>m.id);
          ensureChatMoreUI(); updateChatMoreUI();
        };
        rOnValue(q, onMsgs);
        state.unsubChat = ()=>{ try{ rOff(q, "value", onMsgs); }catch(e){} };
      }catch(e2){}
    }
  })();

  // unified unsubscribe
  state.unsubChat = ()=>{
    try{ if(state.unsubChatLive) state.unsubChatLive(); }catch(e){}
    try{ if(state.unsubChatChg) state.unsubChatChg(); }catch(e){}
  };
}


// ===== SFX(입장) : 모두에게 들리게(채팅 컬렉션에 'sfx' 이벤트로 브로드캐스트) =====
// ⚠️ 브라우저 자동재생 정책 때문에, '첫 클릭/키입력' 전에는 재생이 막힐 수 있어요.
//    그래서 막히면 큐에 쌓아두고, 첫 사용자 입력에서 한 번에 재생합니다.

const __ENTER_SFX_SRC = "data:audio/wav;base64,UklGRmiBAABXQVZFZm10IBIAAAABAAEAIlYAAESsAAACABAAAABmYWN0BAAAAJtAAABkYXRhNoEAAAoADAAIAAkACAAGAAcABwALAAkACAAIAAYAAgAEAAIABgADAAQABwADAAYACQAGAAQABQAGAAYACQALAAUACQAKAAQABAAFAAIABAAFAAEABQAGAAAA//8GAAcABQACAAIABQAEAAMABwADAAQABQAJAAkABAAEAAYACAAGAAMAAgAEAAMABgAMAAgABwAJAAkADAAMAAgACwAMAAkAAwAFAAUABQAEAAUABwAIAAoACgAKAAYACwAHAAsACQAIAAUACgAIAAUACwAHAAcABgAIAAcACAAKAAgACQAKAAoACwAPAAoACQAMAAoACgAMABEADQAPABEADAAQABIADgAJAAgADgAMAA4ADAAKAAsAEgAQAA0AEAATABEACgAPABIAEAATAA4AEQAQABEAFQANABEADAAJAA8AEgASAA8AEQASAA0AEQANABIAEwAPABIADgARABIADwAXABgAFAATABIAFQASABkAGgARABAAEQATABMAEQAWABYAGQAXABoAGwAbABoAFwAWABoAGAAaABYAFAAUABcAGgAZABwAGQAcABwAHAAWABYAGAAUABMAGAAYABQADwAWABcAFgAXABQAEgAVABMAFAAOABAAEAARABEAFQAVAAsAEQASABMAEAAPABIADQAOAAsADAAQABIADwAPABAADgAPAAoADAANABAADQASABEACQAQAA4ADgAPABEAEQALAAwABwAMAA0AEAAQAA0ADQAKAAsADgAKAAgADwAMAAoACwALAA4AEAALAAkACQAFAAkADAANAAwABQAMAA8ABwAJAAgACQALAA8ABwAKAA4ACAAKAAsACQAMAA0ACwAKAAcACwALAAsACQAFAAwADwANABIADAAKAAoAEQAMAAoACgAJAAsACQANAA8AFAAPAA0ACAAHAAwACQANAAwACgARAAsACgAKAAoACgANAA0ADAANAAwADwAKAAwAEQAKAA0ADAAKAA0ACgAMAAgABgAJAAgADQALAA8ADwASAA4ADAAOAA8ADwAMABEADwARABAAEAARABEAEAALAAsACgAIAAoACgAOAAgABQAKAAgACgAOAAsACgAIAAoABgAGAA0ACgAHAAkACAAIAAsADgAGAAUACAAGAAoABgACAAAABQAFAAgADAAIAAgABQAEAAUACAAGAAgABwABAAcACQAFAAcABAAJAAkABQAGAAQADAAEAAYACAAEAAgABQAFAAUACAAGAAUABwAHAAkACAAEAAMABQACAAIAAQADAAEA/f8DAAQAAgD//wYABQAEAAEAAAACAAQA//8AAAMAAAAAAAIAAgACAAEA//8GAAUABAACAAIAAAAAAAAAAwABAAQABQABAAQAAwABAAEABgAIAAQABQAEAAQAAQACAAIABwAIAAMABQAEAAMACAAHAAsABgAGAAUABgAEAAIAAgACAAcABAAEAAcADAAJAAgABAALAAoACAAJAAcACAAHAAgABgAKAAUAAgAEAAcAAwD8/wUABAAAAAkABgAGAAMAAgAEAAEAAgACAAcACAAEAAUACAAGAAcAAwAGAAQAAgAKAAQAAgABAAIABAACAAIABQACAAMAAAAGAAcABQAEAAcABwAIAAQABQAMAAQABgAGAAcAAgADAAEABAADAAQACAADAAkABAACAAQABQAEAAYABQAJAAgABgAIAAIA//8BAAMAAwACAAEAAgADAAUAAgABAAMABAADAAIAAgD+/wUABgAAAP7/AAAEAAQABAAIAAcAAgADAAMABwADAAQACAAJAAUAAQACAP3///8DAAQABQAHAAYACwAIAAcABgAGAAgACAAMAAoACgAJAAgABgAEAAQACQAFAAwACQAFAAoABQAEAAgABwAHAAQAAwAIAAcACAAGAAgABwADAAIABgAEAAMA//8DAAUABgAHAAUABAAEAAkAAgADAAAABAAFAAYAAwABAAIABAAAAP//AgAAAP/////+/wIABwACAAIAAwACAAIABQAAAAEAAwABAAEABAAAAAIAAgD+/wAAAgAEAAEAAQABAAYABwACAAIAAQD/////AAD8//7/+P/3/wAA///6//3/+////wAAAAAEAAAA/f/+///////+/wAAAgD+//z/AgADAAIAAQAEAAIAAwADAP//AAADAAgAAQAFAAIABQAHAAAABQAEAAEAAQABAAQABgACAAMAAwAGAAUACAAIAAgABgACAAcABwAGAAYABQAEAAcADAAJAAIABAADAAQAAgAHAAsABwAGAAYABwAMAAsABgAKAAsADQALAAoABgANAAoADAANAAoADAALAAsACgAMABAADQALAAkACAALAAoADAAMAAoACwAIAAsADAAMAAwACgAIAAgADQAUAA8ADwAOABIAEwARABQAEAASAAoACgANAAoADQAOABAAEQAOABIAEQASABAAFQAXABIAEQASAA8AEgAMAA8AFAAVABAADAASABEAEQAQABQAEQASABUAEgASABIAFAAQABEAGAATABQADgAVABUAEgARABAAEAAOABAADQAPABQADQALAAkAEQALAAgADQAOAAsADgAOAA8ADgAJAAsADQAJAAwADgAKAA8ACwAMAAsACwAMAAwADAAKAAgACAALAAsACgALAAUABwAJAA0ACQAJAAgACQAJAAcADgAJAAsACgAIAAQABgAGAAgADAAIAAMAAwAEAAEAAwACAAIAAgAFAAMAAgACAAUABAD+/wMAAwAEAAAABAACAAIAAgAIAAcACAAIAAgABwAJAAQACQAGAAcABwAIAAYAAwAGAAMADAAIAAgADAAJAAYACQAJAA4ACwAKAAoABwALAAgACAAIAAYAAwAFAAkACAAIAAwABwALAA0ACQAOAAkADwANAAcACQAIAAoABwAJAAgACAAHAAcACAAGAAUAAgAFAAMAAQAAAAIAAwAGAAkAAQAFAAcAAgD//wUACQAGAAUABAAGAAYABgAGAAMAAgADAAQABwAHAAcAAwAEAAMABwAHAAoACgAEAAIAAwADAAQABAAFAAcABQAEAAUABQAEAAUAAwAFAAQACQAHAAUABwAKAAsACAAHAAcACAAJAAYACgALAAcACAALAAoACQALAAcABwAKAAcAAgAKAAYABgAHAAcADAAIAAcABQACAAQACwAKAAwADAAKAAcACAAJAAkACgAFAAQACgAJAAYACAAJAAYABgAIAAcABgAIAAgABgAEAAwABgAGAAkABAAFAAgACgAEAAQACgAFAAQABwAHAAcABwAFAAIABAADAAcABAADAAUABgAIAAkADAAMAAgACwAPAAoADQAIAAYADQAPABIADgAMAAwACwAJAAoADAAMAA8ACQAKAAcABwALAAwADAAMAAYACQALAAoADQAJAAUAAgAJAAoABgAKAAgABgAGAAMABwAHAAYABwAFAAkABwAFAAQABAAHAAcACwAIAAYACQAHAAYACAALAAwACAAOAAoACQAIAA0ADQAHAAsACQALAAgACwAHAAYADAAIAAoACgAMAAwAEAAOAAwAFQALAA8ADwAMABEAEwAOAA0AEgANAA4ADgAJABMADwARAA0ACQAMAAoADwAQABIADAAIAAkAEAANAAsAEwAOAAwADgASABQADQAMAA0AEwANABAAEQALABEAFAASABEAEwAPABMAFAARAAkADwAQAAkAEAAMAAkAFAAQAAkABgANAAwAEAASAAoAEwAPAA0AEAASAA8ADQAKAA0ADQALAA8AEAAPAAsAEQANAAsADQAJAA4ADwAOAA0ADAAPABAAEAAQAAsADgAWABAADwANAAoABgAMAAcACgAJAAsADQAQABQAEQAQAA4ADAAKABEAEAAQAAoACwANAA0ACwAQABIADAALAA8ADAALAAsADwAOAA0ADgALAAoACQAOAA0ADgAGAAkAEgAQAAwAEAAQAAwADgARABEADAANAA0ADQALAAoABwAJAAUABAAMAAYAAwAJAAYADAAKAAgABQAEAAgABQAIAAcABwAGAAYACgAFAAQABAAKAAUABAALAAYACQAKAA8ADwAKAAkADAAJAAUABgAFAAsACQAJAAkACQAJAAwACgAJAAsABwAJAAgABgAJAA4ADgAMAAwAEAAPABIADgAQABQAEwARAAwAEQASAA8AEwAVABEAFQARABIAEAAUABMAEgAQABAAFgALAAwAEAARAA8AEgASAA0ADAANAA4ADwAUABQADQAPAA8AEQAUABMAEgATABIAEgATABIADwARAA8AEAAQAA4AEwAUABAACwAPAA4ADQARAAwAFwAOAA8AEwAUABUAEwARAA4AEQAOABQADAAOAA8ADwAQABAAEAALAA8ADAALABAADgAIAAkADgANAAsADgAOAA4ACwALAAoAEgASAA0ADQANABAAEQAMAA8ACQANAAsACQAUABAADgAKABAAEAAPAA0ADwAQABIACwAOABMADgAOAA0AFQAOAAoACQALAAwACAAMABAAEgARAA8AEQASABAAEgAPAAwADAAOAA4ADQAOAAYADAAKAA0ACwAMAAsACwAHAAoACQAFAAwACgANAA0ADwAPAA8AFwAPAAwADAAJAAwADAAKAAkACQAKAA0ADQANAAgACgAOAA4AEAAKAAsACAAPAA4ADAAMAAkACgAJABAAAwAIABEABwAGAA0ADQAKAAoABQAGAAUABAAHAAgABgAFAAcADAAPAAQAAwAEAAYABAAEAAQAAQABAAIABAAEAAEAAwAJAAsABgAFAAQABgAJAAUACAAKAAkADAAHAAoACgAFAAgACwAJAAcACQAKAAcACwALAAoACgAKAAwACQALAAsABwAJAAsACgAKAAsACwALAAoAEgARAAsACQAIAAwADQAJAAkACQANABEADAAKAAUACgANAAgADgAIAAcACwAJAAYABgAJAAQABAAIAAgACAAJAAoABwAHAAwACwANAAcADgAJAAUABgADAAcABwALAAkACgAJAAgABAADAAgACAAIAAkACQAKAA0ADwAKAAcACAAOAAgACQALAAkABgAIAA0ABwAMAAwACwAOAAcACgAKAAoACgAMABEACwALAAwACQAOABAADgAQAA8ADgARABAABgAIAAgABwANAA4ACgALAAsACgAKAAkACAAKAA4ADQASAAwADgAMAAgACgAKAA0ABwALAAkADAALAAUABQAFAAkACAAJAAQABgAKAAkACQAJAAsADgAJAAoACwAJAAsADgALAA0AEAAKAAwACgAMAAgACgALAAYACgAKAAwADAALAAkADAANAA0ADgAIAAoADgAOAA8ADAAJAAsACwAQABEAEAAPABEAEAAUABQADQAQABAADQASABMAEgAQAA4ADAAOABMAEQAVABMAEQARABEADAAOABMAFQATABMAEwAVABQAFgAUABEAEgAOABIAEgASABAAEwASABIAFAATABgAEAASABEAEwAQABAAEAAPAA4AGAAWAA8AEQAUABIADwAVABEAFAAPABQAFAATABYAFgAVABkAFgATABUAEgAYABYADAAPABIAEgATAA8ADgATABMAEgARABQAFAASAA8ADAATABEAEAASAAsADwASAA8ADQANAA8ADgAOAA8AFAAUABAADgAPABIAEgASABgAGAAQABIAEQATABQAEQATAA4AFQASAA4ACgAOAAkACgARAAwAEQAOAA0ADQASABIAFAATABMAEwARABUAEgAVABQADwATABAAEAAZAA8AEAAWABMAFAATABEAEQAWABQAFAAUABIAEAATABEADwASABQAFgAUABUAFAAPAAwADAAMABIAFQAPAA8AFAAUAA8AFAAUABUAFgASABoAFAASABUAFAARABQAFQAYABQA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JQAuADEAMAAvAC4AJwAjAB4AEgASABEAEwAUABgAHAAbABcAFwAeACAAGQAcAB4AHgAcABsAFwAYABwAGgAaABwAHQAcACYAJQAjACYAKAAoAB8AKgA0AC4AKgA0ADMALAAyADcANgA1ADgAOgA5ADoAPQA+AEAAQABBAEMAQgBDAEYARgBFAEYARwBFAEsARwBEAEQARQBDAEMARwBEAEgATQBNAEwASwBHAEoATQBKAE8ASwBNAFAATwBQAFEATQBLAFMAUwBQAFAAUQBUAFkAVgBUAFkAVQBVAF4AXABbAF8AXgBgAFwAXgBaAFsAWwBeAGUAXQBeAGUAZQBkAGYAagBjAGUAZgBkAGQAZQBoAGgAZwBpAGUAaABqAGYAaQBnAGYAbwBuAGwAaQBvAG0AbQBvAGwAbABvAGwAawBwAG0AcgBrAHEAcgBuAG4AbQBuAGsAcgB0AHEAcgB0AHAAcQBvAHMAbwBvAG4AdABxAG4AcABwAHQAcQBzAHoAcwBzAHUAdQB6AHcAcwB0AHkAeQB2AHcAdgB0AHYAdgBxAHAAdwB6AHUAcgB2AHgAcwB5AHoAeQB7AH0AfAB9AIEAeQB8AH0AewB9AHgAeQB6AHQAewB3AH4AfAB4AIIAhACDAH8AhAB/AIAAfQB7AHsAfwB+AHsAeQB9AH8AgACHAIIAgACGAIcAgwCDAIcAhwCJAIcAhQCFAIIAfQCAAIEAgACCAIkAhgB9AIIAhgCCAIIAhgCEAIUAhgCKAIkAjQCJAIwAjQCIAIsAjQCQAI8AjgCOAI8AigCOAJEAkACKAI4AjACOAJIAhwCOAJQAjQCLAJIAjwCIAI0AjQCLAI8AjACMAI0AjgCBAIoAkACQAIkAiwCOAIoAjgCRAI4AkQCSAIwAkwCUAJAAkACNAI4AkgCUAJMAjwCVAJUAiwCOAI4AkgCNAIwAjwCPAI0AjgCTAI0AlQCNAJIAlACTAJgAlgCVAJgAmQCXAJEAmgCYAI4AkgCYAJUAlgCeAJQAkwCbAJ4AlACXAJYAlgCTAJYAlQCOAJIAkgCZAJQAmwCXAJIAlACdAJEAjgCWAJMAlgCUAJMAlACZAJgAlQCRAJcAnQCYAJQAkgCZAJQAmACVAJQAlgCOAJIAlACVAJQAnACYAJIAlgCTAJUAkwCTAJgAmQCUAJAAlACUAJAAkQCLAJIAjgCOAJMAkACRAI0AkACPAJAAkQCSAJIAjgCVAI8AjQCMAI4AjgCNAJIAkACOAI4AigCNAI0AjQCPAJAAiwCTAJMAiwCRAI4AjQCLAI8AjACOAI4AiwCMAI0AkQCOAJEAjwCLAIsAiQCIAIoAjQCRAI4AiwCHAIYAigCNAIoAjgCPAJIAkACQAI4AjQCQAJAAkQCRAJIAjgCSAJMAkgCRAJEAkQCTAJAAkACQAJAAkACWAJAAlACPAJUAlwCTAJgAlgCZAJoAlwCWAJQAkQCVAJMAkACSAJQAjwCPAJIAkQCTAJQAlACWAJYAkgCRAJQAlACSAJEAkACSAJAAkACTAJEAlQCVAJYAkgCVAJUAjwCWAJQAkQCTAJMAlwCSAJMAlACVAJUAlACXAJUAlgCVAJQAkACSAJEAkgCTAJUAmQCYAJoAlQCRAJQAjwCSAJIAjgCTAJIAkgCMAIoAjgCMAIsAjgCSAI4AkACSAJIAlQCRAJEAkACQAJcAlQCRAJIAkACPAJEAkgCUAJEAjwCQAI8AkQCSAJAAkgCTAJIAkgCLAI4AkACTAI8AmQCUAJIAlwCWAJYAkwCWAI8AlQCXAJIAkACQAJEAlwCRAI8AlwCWAI8AjwCQAJEAkgCMAI0AkACSAJAAkgCRAIwAkgCRAJUAkwCRAJMAjgCTAJIAkwCTAJQAlACSAJEAkQCUAJEAkACQAI8AjgCMAI0AjwCQAI4AjQCSAJYAjgCQAI4AiwCPAI0AjQCMAJEAjgCRAI4AigCPAJEAkgCOAJEAjQCQAJQAkQCTAJAAjwCLAJUAmgCXAJAAkQCUAJMAlACTAJMAkgCRAI4AkQCPAJAAkQCQAIwAkwCZAJQAkQCRAJUAjwCQAI8AjgCTAJEAmACSAJMAlQCUAJgAmgCQAIsAkwCVAJEAlACSAI8AlACWAJYAkwCTAJAAlQCZAJQAkgCQAIkAigCMAJAAkwCUAJEAjwCVAI8AkgCMAI0AkwCSAJEAkACLAJEAlACTAI4AjgCWAJMAkgCRAI4AkgCRAIoAjgCRAI8AjgCMAIoAjACJAIkAigCLAIgAjQCMAI0AiACIAIgAhgCJAIMAiACEAIkAhwCFAIoAhQCBAIcAiwCEAIMAhACCAIEAggCBAIAAhACCAIIAgwCBAIEAgwB9AHwAfAB/AH8AfgB9AHgAfAB/AH0AewB7AHkAegB9AHsAcwB0AHsAfwB+AHMAegB5AHwAeQBzAHQAeQB1AG4AcQBrAHAAcABtAG8AbgBwAHQAcABsAGwAbQBwAHAAbgBsAG4AaQBqAG0AbABpAGkAbgBsAG0AaQBmAGUAZwBqAGwAbgBnAGYAcABsAGgAZgBlAGEAYgBhAGEAYwBfAFoAXABdAGAAYABcAFsAWgBdAF4AXABdAFwAWwBfAFoAWQBcAF8AWwBbAF4AYABcAF4AXQBZAF8AXgBaAFUAXABaAFoAWQBTAFoAVQBVAFgAWgBVAFoAVABTAFcAUwBWAFEAWgBeAFwAWgBUAFgAWwBWAFoAWQBXAF0AVwBWAFUAVwBVAFQAWwBQAFcAWABWAFkAVwBTAFMAVgBNAFAAUABSAFEATgBUAE4AUABRAEwAUQBSAFAAUgBQAFEAUwBJAEkATwBNAFAAUABRAE8ATgBNAE8ATQBNAFQATQBOAEoAUgBTAE0ATQBNAFEATABSAFIAUwBPAE0AUQBXAFQAUABRAFAAUABTAFQAUQBSAFIAVQBVAFUAUABUAFUATQBWAFAASwBQAFEAWABQAFAAUgBVAFQAVABWAFYAUwBUAFkAVQBVAFUAUwBVAFQAVgBWAFUAVwBXAFMAVgBUAFUAWABYAFsAVgBVAFYAUQBVAFYAWQBbAFYAVgBVAFEAVABYAFQAVABYAFQAVgBZAFkAUgBXAFMATABNAFIAVwBWAFUAVABTAFUAVABZAFcAVABQAE4AUABVAFcAVQBSAFMAVwBTAFkAUwBVAFYAVwBYAFUAVwBTAFIAUwBQAFQAVQBUAFIAUABVAFUAVwBZAFoAUgBZAFsAVwBdAFoAWQBWAFcAWABaAFkAVwBYAFoAYABZAFkAWgBbAFwAWABWAFcAXABcAFgAVwBYAFQAWABXAFIAWABXAFUAUQBPAFAAUgBTAE8ATwBUAFYAUwBQAFEAVABPAE4AUABTAFIATwBUAFIATgBSAFAATQBOAFIATwBPAEoATQBTAFQAUABPAFEASwBNAFIAUABOAFMAUABPAFYATgBRAE8AUwBTAE4AUQBOAE0ASQBPAE0ATgBQAFEAUgBKAEwATABQAEoATQBMAEwASwBEAEgASwBIAEoASQBKAEoARwBKAEoATwBMAEoASQBJAEwASgBIAEoASgBLAE4ASgBMAE4ATgBPAE0ASQBPAEkASwBOAEkARwBIAFAARwBMAE0ATABMAE8ASgBHAE0ASABIAEcARwBGAEsARQBEAEkARwBHAEMARgBHAEwASABMAEgASgBOAE4ATABOAEoASgBNAE8ATABMAEkASABIAE0ASQBHAEsASQBKAEQARwBIAEcASQBNAEkASwBGAEsASABFAEQASABMAEcASwBKAEwASgBHAE0ASgBOAE4ASQBQAE8AUgBMAEoASABIAEsATABKAEwASwBEAEUARwBHAEsARwBLAEYARQBJAEMARQBCAEIARgBEAEcARwBFAEQAQwBEAEMARABBAEQARQA/AEYAQgBDAEkAQgBAAEMAQABBAEIAPAA9AEYARQBFAEEAQABEAEAAQgBFAEIAQQBFAD8ASQBCAD4ASABIAEYAPgBDAEAAQgA/AEYARwBCAEIAPAA+AEAAQABAAD8APgBGAD4APwA/AD0APwA9AEMAPwA7AD0APQA7AD4AQAA4ADoAPAA5AD0APgBAADwANgA3ADMANAA0ADMANAAvADAAMQA0ADgALwAxADIAMAA1ADEANAA1ADYANQA0ADYANQA0AC0AMgA0ADQAMAAyAC0ALwAyADIAMwAzADIAMAAxAC4AMAAtADMAMwA0ADMAMQA4ADYAMQA0ADMAMwA0ADEAOQA1ADYAOQA3ADgAOQA3ADcANwA3ADkAOAA1ADUAOAA5ADEAOAA6ADQANAAzADEAMgA5ADIAMgAzADMALwAvADYALwAxADMAMgAzADQALwAvADMANQA4ADEAMgAzADIAMgA0ADAAJwAuADEALQAsADAAKgAsADMALAAwAC0AMAApAC4AMgAxADAALwAyADEALAAuADIALgAwADEALgAtACwAKwAqACwALwAqACcALgAuACgALQApACUAKgApACoALAAoACsAJwAmACcAIwAoACwAKAAqACsAKAAtAC4ALgAuACkAKAAmACoAMAAmACkALAArACoAKgAnACgAKgAqACYAKAAnACYAKgAnACgAJgAtACsAJQAqAC0AKQAvAC4ALAAlACUAKQAsACsAKQApACkALAAsACwALgArACcALAArACgAKgAmACkALQAoACoALAAmACkAKAAtAC0AKAArACUAJgAsAC4AJwAtAC4AKQArACoALQAnACkAMAAtACsAJwAmACgAKQAmACoAKQApADAALAAoACgALQAsACoAKAAvACUAIQAnACkAKAAqACYAKQArACkAKAAnACcAJwAoACYALAAoACgALAArACYAKQAmACcAIwAfACcAKwAkACEAIQAhACUAIgAkACEAIwAiACQAJAAgACUAJQAgAB4AIgAmACgAJwAgACgAKAAqACcAJQAjACcAKAAjACcAIwAkACIAJAAjACMAIgAkACcAJwAqACoAJwAmACgAIQAjACIAJwAoACYAKAAkACIAJgAnACgAJAAeAB8AJAAkACMAJQAlACEAIwAnACUAJQAnACoAIAAfACEAGwAgACAAHgAdAB0AGAAdAB8AHQAjACAAIgAdAB4AHQAfABgAHgAcACEAHwAbACEAHQAeABoAHgAeAB8AJAAjACYAIAAbAB8AIQAjABsAHQAeAB8AIgAgACEAHQAcAB4AGgAdACQAIQAfACAAHAAhABwAGwAdACEAHQAfAB4AIAAiACIAJAAeACQAIgAiACAAIQAgACAAHQAZACEAIAAnACUAHAAfACIAIAAfACgAIgAfACUAHwAkACYAJgAeACIAHwAeACEAHwAgAB8AIgAgAB4AIAAcACMAIAAdAB8AHgAgABYAHwAgAB4AGgAXABkAGwAcAB0AIgAcABsAHQAcAB0AFQAbABgAFgAaABkAHAAgABkAGQAZABwAHAAdABwAFwAgAB0AHwAaABoAHAAZABkAHAAZABoAHwAbABkAHAAfAB8AHQAfAB0AGgAgACEAHQAjACEAHwAfACAAGwAbAB0AGgAZABoAHgAbABgAHAAbABwAHwAcABwAGwAhAB0AGAAfABwAGgAcABwAHgAZABsAGAAcABgAGQAZABgAFwAUABoAFAAXABoAGQAZABcAFwAYABMAGwAYABsAFgAXABwAGwAfABwAGAAgABoAHAAdABkAHwAfAB8AHAAdABoAHwAfABsAIAAfACUAIQAlACEAGQAfACYAIwAhACYAIgAiACEAIwAhACEAJwAiACAAIgAgABwAGAAhAB4AHAAgAB0AHwAbABoAGwAfACAAGwAbABsAGgAdACAAFgAXACAAHgAcABkAHgAaABwAGAAaABYAEwAWABMAEAAOABAADQAMABIADAALABIAFAAPABAAEwASABMAEQAQABIAEAAPABMAEwAVABAADgARABIAFwARABMAFQAVABYAFQAWABYAFQARABIADwAQAA8AEAARAAwAEQATAA4AEAAOAA4ADgANAA0ACQAMAAoADAAOAAgABQAHAAYACgAGAAgACwALABUADAAMAA0ADwAMAAcADQAKAAgABgALAAoADAAJAAkACAAHAAkABAAJAA0ACgAFAAkADAAKAAgACAADAAQABwAIAAQABAAGAAkACgAIAAcABAAKAAoACAAIAAYABwAIAAoACwAJAAsACQAHAAcAAQAAAAcAAwABAAcABgAHAAUACAACAAYABwAFAAQAAQAJAAwAAQADAAgACgAIAAYADgAKAAwADwAHAAkACgAHAAwACwAEAAgACwAIAAsACAAHAAkABgAHAAEABAAEAAMACAAGAAwABwAIAAkACAAIAAMABwAIAAcABAAGAAgABAAEAAgAAwAGAA0ACgAGAAIAAAAGAAIACQAFAAYACQAHAAkABgANAAwACAAJAAwADAALAAkACgAQABEACwAOAA0ACwAMAAkACQAHAAYADAAQAAwADAAKAA0ADAALAAoACgANAA4AEAAQABAADwAOAA4AEAAMAA4AEQARAA0ADwANABMAEQAPAA4ADAAOAAgACQAHAAoADQAKAAkACwAOAA4AEQASABEADQANABIAFAAOAA8AEwARABIAEgATABQAEwATAA0AEwARAAwACgAOABcAEwASAA0AEwARABAAEQASABYAEwARABMAGQAYAA0AFAAUABMAGQAVABgAFwAXABYAEwAZABoAGgAWABQAEwAYABgAGQAcABQAFgAYABQAFAAYABcAGgAVABIAGQAZABcAFwAYABkAFgAYABsAFwAbABsAEgAZABcAGAAXABUAFAAbABoAFQAUABYAGAAWABoAFQAUABsAHQAZABMAGwAVABYAGQAZABcAHAAVABUAGQARABIAFAAVABIAGgAaABUAGQAbABwAHwAZABsAGAAcAB0AHgAeABwAIAAhACIAJgAdACEAGwAgACAAHgAhACEAGgAaABsAGgAcAB4AIwAjACAAHAAfACAAIQAeABsAGwAfACAAIgAfAB8AIgAhACQAIAAbACMAJgAiAB4AIAAhAB8AIgAdAB0AIgAgACQAHwAfACUAIgAeACIAIgAkACUAJAAhACIAIwAlACAAIAAgACAAIAAaAB0AIQAlACEAGgAdACAAIAAeACYAJgAkACIAIAAkACUAJgAlACIAJgAiACUAKAAnACYAJgAmACMAJAAkACUAIAAjAC0AKAArACgAKgAnACsAJwAlACsAKAAmACYAIwAjACgAIQAkACIAJwAlACYAJQAjACgAJgAmACcAKAAnACgAKgAnACMAJgAqACcAJQApACoAKQAkACIAJQApACcAKgApACkAKQApACYAJgApACcAJQAgACQAJwArACYAJwAsACMAJAAmAC0ALgAsADAAKQAqAC4ALAAuAC8ALgAuAC8AMgAqACwAMgAtACwAJwAsADEALgAvAC0AMQAtAC4AMAAsAC8AKwAmACgAJgAvADIAKwAoACcAKgArACgALQAtAC0ALQAsACwALQAtAC4AKwAlACYALQAyACkAJgApAC8ALAAkACYAKgAtACkAKQAqACkALgAtAC0AKwAqACYAJwApACcAIgAmACcAJAAmACUAJwAgAB8AIwAjACMAIQAhACQAJAAnACQAIwAlACIAIwAgACEAJQAhACUAIgAeAB8AIQAdABwAHQAhAB8AIwAjAB4AIgAZAB0AIgAhACEAHAAcABwAHAAZABoAGAAaABkAFQAYABcAHAAZABQAFwATABAAEgAUABYAGgAVABQAFAAUABUAFgATABUAFgAXABIAEQATABMAEwAUABAAEgAUABQAEAARABoAGQAWABUAEQAVABQAEgAYABYAFgAXABMAEQAQABQAFAASABUAFAAUAAwADwAQABAAEQATABIADAAMAA0AEwANAAsACQANABEADgAOABEAEQASABEAEAARAA4AEAARABAADgAOAAwADAAOAAwADgANAAsADAANAA8ADAANAAsADgAPAAsACwALAAoACgAOAA8ADAAOAAwAEgAMABIADgAJAA0AEQATABEAFQAOAA4ADAAUAAsADgAOAAsAEQARAA4ACgARAAwACwAOABIADQASAA4AEAASAA0AEwAPABMAGwAUABIADgATABIADgAOAA8AEgAMABUAEgAQAA8ADAAVAA4ADgAQABIAEAAUAA8AEgAOAA4ADQAKAA4ADAARAAwADQAKAA0ADAAQABMAEQAUABEAEgAOAA8AEwARAAwACgANAA4ADAAMAAsADQASABAAEgANAA4ADgALAAkACAAOAA8AEAAQABAADQASAA8ACQALAAwACgALABEADwASAA0ADwAOAA8ADwAQABAAEwARABEAEwAQABUADQAPABEADwAPAAoADgAQABAAFAAQAA0ADgALAA4ADAALAAoADwATAAwAEQAOABAADgARABQADgARABEADAAKAA8AEAAMABEACQAJAAoADQAIAAwADwANAA0ADAAOABAAEQARAAwADwASAA4ADgAKAAkACQAJAAsADQAHAAsADgARAA0ADAASABEAEQAPAAoAEAAOABIAEwAOAA8AFgAUABAAEwAYABIADwATABEAEgAUABIAFAAUABQAFgAUABgAFAAUABIAFAAOAA8AEQARABMADwAUABMAFAATAA8ADwARAA8AEQAOAA0ADAAOABUAEAATABQAFAASAA8AEAAVABkAEwASABYAGAAaABoAHgAcAB8AGgAcACAAHgAbABoAGAAXABoAHAAaABUAGQAbABgAFQAWABUAGAAWABUAEAAMABMAEAAOABAAEQAQABQAEwASABIAFAATABUAEAARAAsADgAXABAAFQASAAsADgAMAA4ADAAPAA4AEQASABEAFAANAA8AEgASABMAEAARABQADwATABQAEwASABEAEgARABMAEgAVAAwAEAAZABYADQARABcADQAVAAwADgASAAwACwAPABEADwANAA8AFAAUABgAFAASABUAFAAUABAADQASABQAFwAaABQAEQAQABQAFgAPABAAFgATAA4AEQARABUAFAAXABcAEwAWABUAEwAXABcAEwAUABoAHAAUABcAFwAVABkAGQAZABQAFwAbABYAFgAbABkAEgAVABoAGQAbABgAFgAbABcAGQAcABoAGgAdABcAGQAYABgAGAAXABQAGgAbABUAGQAWABoAEwAVABUAGAAZABsAGAAWABYAFwAYABkAGgAXABcAHAAaABYAGwAaABsAFgASABUAHwAbABoAHQAaABYAGAAZABoAHQAZABoAFQAcABYAFwAYABgAHgAdAB0AHwAeABsAHQAcABwAGgAaABoAFwAYAB8AGwAdABwAHgAeABwAHQAhACEAGAAbAB4AGwAbABsAGwAbAB0AIAAfAB0AGQAYAB0AGwAcABwAHgAaABgAHQAZABYAFgAYABsAHQAYABYAFQAcABYAGAAYABYAGAAYABgAGQAdABMAFwAaABcAFAAQABgAFQARABIAGQAYABEAGQAaABYAGAAUABMAEwATABMADwASABgADwATABQADwATABUAGAAWABUAEgAUABQAEgATABEAEAAaABEADgAUABIAEgASABIAEQAUABAAFAASAA0AFQASABMAFAAPABAAEAAVABAAEAAXABMAEAATABMAFgASABAAEQATABIAEAAVAA8ADAANAAwADwALAAwAEQANAA0AEgANAA0AEQARAAsAEAAXABQAEAARABIAEwAUABAAEAAQAA0AEAAUAA4AEgATABMAEAARAA8AFAASAA4ACwALABEACwAPAAwACgALAAsADQAKAAkABwALAA0ACgALAAgACAAKAAoADAAGAAYACgAIAAoADQAMAA4ABwAPAAsADgAJAAwACQACAAMAAQAAAP7/BQABAAMABQAEAAQAAQADAAYACgAEAAQACQAHAAkACQAJAAMABgAGAAUACQALAAgACgAMAAkACQAGAAkACQAIAAkABgAHAAgADAAJAAYABwAIAAcABwAGAAUACgAHAAsACAAIAAQAAAAFAAUAAQAGAAUACgADAAQABQAEAAcABwAGAAQACgABAP//AAACAAIA///+/wIABAACAAUABAAFAAUABgAHAA0ADQAIAAoABQAIAAQABgAJAAMABAADAAIAAAAFAAgAAgAJAAgABwAKAA8AEQAOAAoADAAMAAsADAANAAsACwALAA4AEgAPAA8AEQAPAA0ADgAJABAADQAMAA0ACQAPABAAEgAQAA4AFQAOAA0AEAARABIAEwATABQAEgASABMAEQAPABIAFQATAA8ADwAVABYAEwAQAA4AEwAUABMAEwATABYAEwAOAA0AFQAPAA4ADgAQABMADAAOAA4ADQAMAAsABwAHAAgABAAEAAoACQALAAoADQANAA0ADQALAA8ADAAMAAgACQAKAAsAEAAMABAADwAOABIADQAHAA4ADwANAA8ADgAKAA0AEAALABEADwAUAA4ACwANAAgABAAHAA4ADQANAAgABgAJAAsABwACAAMABQAJAAoACgANAA4ADwAPAAsACgAJABAAEAAOABEAEgAQAA8ADwAPABYAEQAPABIAEwANAA4AEAANAAkACQAQAA8ADAANABEAEgATAAkAEAAQAAwAEAANABAADgAPAAkABwAHAAcABgAFAAgABgABAAYACAAFAAgACgAKAAwACwAOAAoACgAKAAYABwALAAgABgAKAAwACgAJAAsACgAMAAsACAALAAwACwALAAoACwAJAA0AEAALAAoACAAPABAADQADAAkADAAMAAoACAAJAAcADQAJAAQACgAIAAYACQAFAA0ACwAIAAkACQANAAUABAANAAQABQAFAAoACwAKAAgABgAGAAUABwAEAAMABgAEAAkAAgABAAUACAAPAAsACQAHAAcADAAGAAQAAwAFAAQABwAFAAUABQADAAIABwAKAAgABwAGAAoACwAKAAsACgAKAAoADAARAAwACwAKAAoADwAMAAsACAALAAQAAwAHAAIAAQADAAsABgACAAgACQAFAAsACAAEAAQABAADAAAABQAHAAEAAwAHAAYABgAIAAsADAAHAAgACQAJAAcACQAJAAgADgAJAAcABwAHAAoACgAIAAkACgAQAAwABgAIAAkADAAJAAoACwALAAkACAAMAAwADAANAAoADwAMAAYACAAOAAwAEAAPABIAEQAMAAkACQAQAAgACgAJAAsACAAJAAsABwAIAAgACAAKAAwACgANAA8ADAAJAA0ADAANAAoADgALAAsAEAARAAwADgAPABEADwAPAA8ACAAOAAsACwANABEAFAANABEAEAAOABQAEwASABAAEAAOABQAFwARABEAEAAVABIAEAAPAA4AEgARAA8ADwARABcAEwASABIAEwAWABQAFQAVABYAFAATABIADgAQABUAFAATABEAEAASABUAFgAQAA4AFQAVABIAEgASABUAEgAOABAAEQAQABEAEgAYABcAFwARABIAFwAUABYAGAAUAA0ADgAUABQAEAAKABMAFAAUABYADwASABQAEQATABQAEQAOABYAFAALABEAEgAQAA8AEwAVABMAFQARABEAEgAZABkAEwATAA8AEQARABYAEgANAAkADAASAAsACgALAA0AEwARAAwAEAASAA8ACQAMAAQACQAOAAgACgALAAYABgAJAAcABAAHAAYABgAIAAUABwAFAAsABQAAAAEABQAFAAQABQABAAMA//8CAP7/AwACAAAABAAAAAAAAQAHAP//AQADAP3/AQD//wAAAQABAP//AgACAP///v/7//v//v/9//z//f////r//f///wAAAQAAAPz//P8DAP7/AAABAP7/+//9//j/+//6//j/+P/7//r/+//5//3//v8CAAEAAAD+//z/AAD6////AAABAPv//P/6//v//P/9//7//P/9/////P/7//7//v/9//r/+f/+////+v/5//v//f/9//n/+////////f///wMAAgACAP7//v8AAP//AAD8//7/AgD/////AAACAAEAAAADAAIABAADAAcAAQAAAAIAAwAEAAIABAACAAEAAwABAAEA/P8DAAUAAAD+//7/BAD9////AAAAAP////8AAPz//v/8//z//P/9//z/AQACAPv/AAABAAUAAwABAAMAAwAAAP//AAADAAAAAgACAPz/BAAHAAYA/v8AAAQAAgABAAEAAAABAAIA/v/9/wAAAAACAAAAAQACAP//BQAEAAcABgAFAAQAAwAFAAMAAwAFAAsABwADAAIABAAIAAUABgAFAAgABQADAAUAAgACAAQAAwAEAAIABQAEAAQACgAGAAkAAgAFAAUABgAJAAcACAAMAAoADgALAAUACgACAAUACAAFAAUADAAKAAcABwADAAkACQAHAAIABAAJAAoACQADAAUABwAFAAYABgAHAAgABwABAAcABAAFAAcABgAIAAUADAAGAAoABgAGAA0ACAAIAP7/BQAIAAoABgAGAAgACQAMAAgACAAFAAgABQAIAAwADAAKAAYADgALAAoADgALAAgACwAOAAcACgALAAoADAAHAA0ADgAOAAwACQAJAA4ACwAOAA4ACQANABEADwAHAAsADgAJAAsADAAQAA0ADAAPAAwAEAAKAA4ACwAMAAwADQALAAwAEAAKAAsADAARAA8ADwAKAAoADgAOAA8ADAAKAAwADQAMABMACwAKABEAEAAOAAwACgAKAAwACAAKAAgAAwAFAAcABgAEAAcACwAHAAkADQAKAAwABgAKAAkADAAMAAoACQAIAAgABwAKAAkABgAEAAQABwAKAAsADQAHAAwACAANAAsACQALAAoACAAKAAgABgAOAAwACAALABEACgAPAAsADAAMAAkADgANAA8AEQARABIAEQAQAA8ADQAQABAAFQAUAA0AFAAWABQAFAAVABQAEwAVABUAFQAXABQAFgAZABIAEAATABAAFAATABEAEgAQAA0AEwATABcAFwATABgAFQAYABcAFQATABQAFAARAA8AEgARABEAFAAXABMADQASABAAEAANABAAFAASABEACgAMABIADgAOABUAFAAQAA0AEgAUAA8AEgARABIAFAAOABEAEgATAA8ADAARABIAEgATABMAFAAUABMAEwARABEADQATAAwADgAQABAAEAAKAA4AEAARAAsADAAQAAoAEAANABEADQANAA4ADwASAAwADgASAA8AEwAVAA4ADwAIAAsACgAKAAYADAALAA0AFAAPAA4ACwAPABIAEwAMAAgADQANAAkAEAAKAAUADgANAAYAEAAVAAoADAAOAA4ADgAJAAsADAASABUADAAJAAoADQAKAAsAEQAIAA4ADwAOABEACwALAAwACQAMABEACQAGAAUABgAJAAsACwAHAAoABgAFAAkACQALAAoADAAJAAkACQALAAoACgAPAAsABgAHAA8ADwALAAsACgAMAAgABwAKAAkACAANAAsAAgAMAA4ACQAIAAwAEQANAAsACwAOAAwACwAQAAkABgAKAAcACgAQAAkADAAKAA4ACgAMABQACwALABAAEgAPABUAEwAJAAsACQAJAAoADAAIAAoADQAMABEADwAOABAACwALABEADwAHAAkAEAAQAAsADgAVAA4AEAANABAADQAMABEADgAJABIAEgALAAoADgAKABAAEwAMABgAFQASABAAEwATABEAEAAVABUAEAASABsAGAASABMAGAASABQAFQAUAA4AEAAbABgAGQAWABkAHAAWABcAGQATABQAEgAVABIAEAARABAADwAUABUAFAAXABIAEwARABYAEwASABEAEQAYABAADQARABAAEAALAAwADQARABEADwAPAAcADgAMAA0ACgAHAAkACwAMAAcACQAIAAgABwALAAkABwAFAAUABgAFAAYABwAEAAYACQAJAAgACgAHAAYACQAGAAQABwAHAAgACgAHAAsACwAMAAoABgAKABAADQAJAAoACwANAAsACgAFAAUABwAMAAoACwAJAAgACwALAAsACQAJAAUABgAHAAgABgAJAAcABwAJAAwADgAEAAoADAAMAAwACQAMAA==";

let __audioUnlocked = false;
let __pendingSfx = [];
let __soundHinted = false;
let __enterAudioProto = null;

function __getEnterAudio(){
  try{
    if(!__enterAudioProto){
      __enterAudioProto = new Audio(__ENTER_SFX_SRC);
      __enterAudioProto.preload = "auto";
      __enterAudioProto.volume = 0.90;
    }
    const a = __enterAudioProto.cloneNode(true);
    a.volume = __enterAudioProto.volume;
    return a;
  }catch(e){
    return null;
  }
}

function __playEnterSfx(){
  const a = __getEnterAudio();
  if(!a) return Promise.reject(new Error("audio init failed"));
  try{ a.currentTime = 0; }catch(e){}
  return a.play();
}

function playSfx(kind){
  // 퇴장 소리는 제거: enter만 재생
  if(kind !== "enter") return;
  // 🔈 local toggle
  if(state && state.sfxEnabled === false) return;

  // 자동 재생 제한 상태면: 큐에 쌓아두고, 사용자에게 "한 번 클릭" 안내
  if(!__audioUnlocked){
    __pendingSfx.push("enter");
    if(!__soundHinted){
      __soundHinted = true;
      try{ showToast("🔈 사운드를 켜려면 화면을 한 번 클릭해줘!", 2600); }catch(e){}
    }
    return;
  }

  __playEnterSfx().catch(()=>{
    // 혹시 또 막히면 다시 큐로
    __audioUnlocked = false;
    __pendingSfx.push("enter");
  });
}

// ✅ 자동 재생 제한 대비: 첫 사용자 입력에서 오디오 활성화 + 대기 중인 사운드 재생
(function __wireAudioUnlock(){
  const unlock = ()=>{
    if(__audioUnlocked) return;
    __audioUnlocked = true;

    const q = __pendingSfx.slice(-3);
    __pendingSfx = [];
    q.forEach(()=>{
      __playEnterSfx().catch(()=>{});
    });
  };
  window.addEventListener("pointerdown", unlock);
  window.addEventListener("keydown", unlock);
  window.addEventListener("touchstart", unlock, {passive:true});
})();

async function emitSfx(kind){
  // 퇴장 소리 제거: enter만 브로드캐스트
  if(kind !== "enter") return;
  try{
    if(!state.roomId) return;
    await rPush(rMessagesRootRef(state.roomId), {
      type: "sfx",
      kind: "enter",
      tsMs: Date.now(),
      serverTs: rServerTimestamp(),
      uid: state.uid || "",
      name: state.nickname || (els.name ? (els.name.value||"").trim() : "")
    });
  }catch(e){}
}


async function emitSys(text){
  try{
    if(!state.roomId) return;
    const name = (state.nickname || els.name?.value || "").trim();
    if(!name) return;
    const now = Date.now();
    const last = Number(sessionStorage.getItem("lastSysTs") || 0);
    if(now - last < 5000) return; // 5초 내 중복 방지
    sessionStorage.setItem("lastSysTs", String(now));
    try{ showJoinTicker(String(text||"").slice(0,120)); }catch(e){}
    await rPush(rMessagesRootRef(state.roomId), { type:"ticker", kind:"join", uid: state.uid||null, text: String(text||"").slice(0,120), tsMs: now });
  }catch(e){}
}




function showJoinTicker(msg){
  try{
    const box = document.getElementById("joinTicker");
    const track = document.getElementById("joinTickerTrack");
    const textEl = document.getElementById("joinTickerText");
    if(!box || !track || !textEl) return;
    const s = String(msg||"").trim();
    if(!s) return;

    // show + set text
    box.classList.remove("hidden");
    textEl.textContent = s;

    // compute duration based on distance (px) / speed
    // speed: 70px/s (feels '스으으윽' but not too slow)
    const boxW = box.clientWidth || 320;
    const textW = textEl.scrollWidth || 320;
    const distance = boxW + textW;
    const speed = 70; // px per sec
    const dur = Math.max(6, Math.min(18, distance / speed)); // 6~18s

    // restart animation
    track.style.animation = "none";
    track.offsetHeight; // reflow
    track.style.animation = `joinMarquee ${dur}s linear 1`;

    // auto-hide after run
    const onEnd = ()=>{
      try{
        track.style.animation = "none";
        box.classList.add("hidden");
        textEl.textContent = "";
        track.removeEventListener("animationend", onEnd);
      }catch(e){}
    };
    track.addEventListener("animationend", onEnd);
  }catch(e){}
}


    // ✅ 중복 전송 방지(Enter/Click 등 이벤트가 겹칠 때)
    let __chatLastSig = "";
    let __chatLastAt = 0;
    function __chatSig(text){
      return `${state.roomId||""}|${state.uid||""}|${String(text||"")}`;
    }

    async function sendChat(){
      const text = (els.chatInput.value || "").trim();
      if(!text) return;

      // ✅ 같은 내용이 아주 짧은 시간 안에 2번 트리거되면(Enter+click / IME / 모바일) 1번만 전송
      const __now = Date.now();
      const __sig = __chatSig(text);
      if(__sig === __chatLastSig && (__now - __chatLastAt) < 800){
        return;
      }
      __chatLastSig = __sig;
      __chatLastAt = __now;

      // ✅ 전송 중이면 대기열로 (채팅 씹힘 방지)
      if(__chatSending){
        queueChat(text);
        els.chatInput.value = "";
        /* 전송 대기열 토스트 숨김 */
        return;
      }

      const ok = await sendChatCore(text);
      if(ok){
        els.chatInput.value = "";
        try{ els.chatList.scrollTop = els.chatList.scrollHeight; }catch(e){}
      }else{
        // 실패 시 입력값은 보존 (사용자가 그대로 재전송 가능)
        els.chatInput.value = text;
      }
    }

    // ✅ 채팅 전송 최적화: 대기열 + 순차 플러시
    let __chatSending = false;
    function chatQueueKey(){
      return `mkm_pending_chat:${state.roomId||"room"}:${state.uid||"anon"}`;
    }
    function loadChatQueue(){
      try{
        const raw = localStorage.getItem(chatQueueKey());
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      }catch(e){ return []; }
    }
    function saveChatQueue(arr){
      try{ localStorage.setItem(chatQueueKey(), JSON.stringify(arr.slice(-20))); }catch(e){}
    }
    function queueChat(text){
      const q = loadChatQueue();
      q.push({ text: String(text).slice(0,500), clientTsMs: Date.now() });
      saveChatQueue(q);
    }

    async function flushChatQueue(){
      if(__chatSending) return;
      const q = loadChatQueue();
      if(!q.length) return;

      // 순차 전송
      for(let i=0;i<q.length;i++){
        const item = q[i];
        const ok = await sendChatCore(item.text, true);
        if(!ok){
          // 실패하면 남은 것 포함해서 다시 저장하고 중단
          saveChatQueue(q.slice(i));
          return;
        }
      }
      // 전부 성공
      saveChatQueue([]);
    }

    // ✅ 네트워크 복구 시 대기열 재전송(한 번만 등록)
    window.addEventListener("online", ()=>{ try{ flushChatQueue(); }catch(e){} });

    
async function sendChatCore(text, isFlush=false){
  __chatSending = true;
  try{
    // 버튼은 잠깐만 잠그고, 입력은 IME 때문에 계속 열어둠
    els.sendBtn.disabled = true;

    // 내 프로필 이름(로컬 기준) — RTDB에서 굳이 read하지 않음(읽기 절감)
    let myName = (state.nickname || els.name.value || "").trim();
    if(!myName) myName = "익명";

    const payload = {
      type: "chat",
      uid: state.uid,
      name: normalizeNick(myName),
      text: String(text).slice(0,500),
      tsMs: Date.now(),
      // serverTs는 정렬 안정화 보조(원하면 활용)
      serverTs: rServerTimestamp()
    };

    await rPush(rMessagesRootRef(state.roomId), payload);
    return true;
  }catch(e){
    console.warn("[chat] send failed", e);
    showToast("전송 실패(권한/rules 확인)");
    return false;
  }finally{
    __chatSending = false;
    try{ els.sendBtn.disabled = false; }catch(e){}
  }
}


    // Tiles
    function statusBadge(p){
      const online = isOnlinePresence(p);
      if(!online) return { text: "offline", cls: "bOff", emoji:"🫥" };
      if(p.status === "work")  return { text:"Work", cls:"bWork recBadge", emoji:"" };
      if(p.status === "break") return { text:"휴식중", cls:"bBreak", emoji:"☕", emojiHtml:'<span class="coffeeSteam" aria-hidden="true">☕</span>' };
      return { text:"자리비움", cls:"bIdle", emoji:"🌙" };
    }
    function tileKey(p){
      return JSON.stringify({
        name:p.name, status:p.status, total:p.totalSecondsToday, started:p.sessionStartedAtMs,
        bubble:p.bubbleText,
        // theme (visual)
        emo:p.theme?.emoji, emoBg:p.theme?.emojiBg, emoSize:p.theme?.emojiSize, photoSize:p.theme?.photoSize,
        bg:p.theme?.bgColor, bubbleColor:p.theme?.bubbleColor, pat:(p.theme?.pattern||p.theme?.bgPattern), patColor:p.theme?.patternColor, photo:p.theme?.photoUrl, photoEnabled:p.theme?.photoEnabled,
        // ✅ text colors (added v47): must be part of key so tile rerenders when only text colors change
        nameColor:p.theme?.nameColor, statusTextColor:p.theme?.statusTextColor, bubbleTextColor:p.theme?.bubbleTextColor, timeColor:p.theme?.timeColor,
        online:isOnlinePresence(p)
      });
    }
    function renderTile(p){
      const key = tileKey(p);
      const prev = state.lastRendered.get(p.id);
      if(prev && prev.key === key && prev.el) return prev.el;

      const t = document.createElement("div");
      t.className = "tile";
      t.dataset.uid = String(p?.id || "");
      t.dataset.name = normalizeNick(p?.name || p?.id || "");
      // 우클릭 메뉴(강퇴)
      t.addEventListener("contextmenu", (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        openCtxMenu(ev.clientX, ev.clientY, p);
      });

      const bg = document.createElement("div");
      bg.className = "bg";
      bg.style.background = bgStyle(p.theme?.bgColor || "#ffd0e2", (p.theme?.pattern || p.theme?.bgPattern || "none"), (p.theme?.patternColor || p.theme?.patColor || "#ffffff"));
      // pattern sizing tweaks
      if(((p.theme?.pattern||p.theme?.bgPattern||"")) === "dots"){ bg.style.backgroundSize = "22px 22px, 22px 22px, auto"; }
      if(((p.theme?.pattern||p.theme?.bgPattern||"")) === "grid"){ bg.style.backgroundSize = "18px 18px, 18px 18px, auto"; }
      if(((p.theme?.pattern||p.theme?.bgPattern||"")) === "stripes"){ bg.style.backgroundSize = "auto, auto"; }
      if(((p.theme?.pattern||p.theme?.bgPattern||"")) === "hearts"){ bg.style.backgroundRepeat = "repeat, no-repeat"; bg.style.backgroundSize = "36px 36px, auto"; }

      const shade = document.createElement("div");
      shade.className = "shade";

      const content = document.createElement("div");
      content.className = "content";

      const statusBar = document.createElement("div");
      statusBar.className = "statusBar";

      const statusLeft = document.createElement("div");
      statusLeft.className = "statusLeft";

      const statusRight = document.createElement("div");
      statusRight.className = "statusRight";

      const badge = statusBadge(p);
      const b = document.createElement("div");
      b.className = `badge ${badge.cls}`;
      const isRec = (badge.cls || "").includes("recBadge");
      const iconCls = (isRec) ? "" : (badge.text==="휴식중") ? "stBreak" : (badge.text==="자리비움") ? "stIdle" : "";
      const _emo = (badge.emojiHtml || badge.emoji || "");
      b.innerHTML = isRec ? `<span class="recDot"></span><span style=\"font-weight:1100;\">Work</span>` : `<span class=\"stIcon ${iconCls}\">${_emo}</span><span>${badge.text}</span>`;
      try{ if(!isRec && p.theme?.statusTextColor) b.style.color = clampHexColor(p.theme.statusTextColor); }catch(e){}

      const namePill = document.createElement("div");
      namePill.className = "namePill";
      const _fullName = normalizeNick(p.name || p.id);
      const _miniName = miniNick(_fullName);
      const _nameFull = document.createElement("span");
      _nameFull.className = "nameFull";
      _nameFull.textContent = shortNick(_fullName, 4) + (!isOnlinePresence(p) ?"🚫":"");
      namePill.title = _fullName;
      const _nameMini = document.createElement("span");
      _nameMini.className = "nameMini";
      _nameMini.textContent = _miniName + (!isOnlinePresence(p) ?"🚫":"");
      namePill.appendChild(_nameFull);
      namePill.appendChild(_nameMini);
      const nameAccent = clampHexColor(p.theme?.bubbleColor || p.theme?.bgColor || "#ffd0e2");
      namePill.style.background = hexToRgba(nameAccent, 0.22);
      namePill.style.borderColor = hexToRgba(nameAccent,0.55);
      try{ if(p.theme?.nameColor) namePill.style.color = clampHexColor(p.theme.nameColor); }catch(e){}

      statusLeft.appendChild(b);
      statusLeft.appendChild(namePill);

      const medal = document.createElement("div");
      medal.className = "missionMedal hidden";
      medal.textContent = "👑";
      statusLeft.appendChild(medal);
      updateMissionMedalForTile(medal, p);

      // 오른쪽 영역(추후 배지/아이콘 확장용)
      statusRight.appendChild(document.createElement("div"));

      statusBar.appendChild(statusLeft);
      statusBar.appendChild(statusRight);// tile sizes (emoji/photo)
const emoSize = 82;
const photoSize = 82;
t.style.setProperty("--emoSize", emoSize + "px");
t.style.setProperty("--photoSize", photoSize + "px");

const avatar = document.createElement("div");
avatar.className = "avatar";
avatar.textContent = (p.theme?.emoji || "✍️");

const emoBg = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
const emoBgTransparent = (p.theme?.emojiBgTransparent === true || p.theme?.emojiBgTransparent === "true");
const emoBgFinal = (emoBgTransparent ? "transparent" : emoBg);

t.style.setProperty("--emoBg", emoBgFinal);
avatar.style.background = emoBgFinal;
avatar.style.borderStyle = "solid";

// 투명일 땐 테두리만 은은하게, 아니면 배경색 기반 테두리
if(emoBgTransparent){
  avatar.style.borderColor = "transparent";
  avatar.style.borderWidth = "0px";
} else {
  avatar.style.borderWidth = "1px";
  avatar.style.borderColor = hexToRgba(emoBg, 0.95);
}

const photoEnabled = !(p.theme && (p.theme.photoEnabled === false || p.theme.photoEnabled === "false" || p.theme.photoEnabled === 0));

const idPhoto = document.createElement("div");
idPhoto.className = "idPhoto" + (photoEnabled ? "" : " photoOff");

if(photoEnabled){
  const photoUrl = (p.theme?.photoUrl || "").trim();
  if(photoUrl){
    const img = document.createElement("img");
    img.src = photoUrl;
    img.loading = "lazy";
    img.onerror = ()=>{ idPhoto.textContent = "사진"; };
    idPhoto.appendChild(img);
  }else{
    idPhoto.textContent = "사진";
    // ✅ 이모지 배경 투명화가 켜졌을 때 '사진 슬롯'의 어두운 배경도 같이 투명 처리(사진 미설정 시 체감 개선)
    if(emoBgTransparent){
      idPhoto.style.background = "transparent";
      idPhoto.style.border = "1px solid rgba(255,255,255,.18)";
      idPhoto.style.color = "rgba(255,255,255,.72)";
    }
  }
}else{
  // keep the slot but hide the content (slot stays to prevent layout shift)
  idPhoto.textContent = "사진";
  idPhoto.style.visibility = "hidden";
  idPhoto.style.pointerEvents = "none";
}

const timer = document.createElement("div");
timer.className = "bigTimer";
      const isMeTile = (p && p.id && state.uid) ? (p.id === state.uid) : false;
timer.innerHTML = `<span class="time">--:--:--</span>` + `<button class="missionBtn" type="button" data-owner="${escapeHtml(p.id||'')}" data-name="${escapeHtml(normalizeNick(p.name||p.id||''))}" data-me="${isMeTile?'1':'0'}" title="오늘의 미션" aria-label="오늘의 미션"></button>`;
      const mbtn = timer.querySelector(".missionBtn");
      if(mbtn) updateMissionBtnForTile(mbtn, p);


const bubble = document.createElement("div");
bubble.className = "bubble";
const bubbleAccent = clampHexColor(p.theme?.bubbleColor || p.theme?.bgColor || "#ffd0e2");
bubble.style.background = hexToRgba(bubbleAccent, 0.34);
bubble.style.borderColor = hexToRgba(bubbleAccent, 0.70);
try{ if(p.theme?.bubbleTextColor) bubble.style.color = clampHexColor(p.theme.bubbleTextColor); }catch(e){}
const bubbleText = (p.bubbleText || "").trim().slice(0,15);
if(bubbleText){
  bubble.textContent = bubbleText;
}else{
  bubble.textContent = "…";
  bubble.classList.add("muted");
}

const bottomStack = document.createElement("div");
bottomStack.className = "bottomStack";

const mediaRow = document.createElement("div");
mediaRow.className = "mediaRow";
mediaRow.appendChild(avatar);
mediaRow.appendChild(idPhoto);

bottomStack.appendChild(bubble);
bottomStack.appendChild(mediaRow);

content.appendChild(statusBar);
content.appendChild(timer);
content.appendChild(bottomStack);
t.appendChild(bg);
      t.appendChild(shade);
      t.appendChild(content);

      state.lastRendered.set(p.id, { key, el: t });
      return t;
    }
    function updateTimersLive(){
      for(const [uid, rec] of state.lastRendered.entries()){
        const p = state.currentParticipants.get(uid);
        if(!p || !rec.el) continue;
        const timeEl = rec.el.querySelector(".time");
        if(!timeEl) continue;
        const __disp = computeDisplayedTotal(p);
        timeEl.textContent = fmtHMS(__disp);
        // ✅ 로컬(브라우저) "오늘 작업시간" 24h 누적 저장 (타이머가 실제로 도는 지점에서 확실히 저장)
        try{
          if(p.id === state.uid){
            const s = Math.max(0, Math.floor(Number(__disp)||0));
            const nowMs = Date.now();
            if(!state.__lastFocusPersistAtMs || (nowMs - state.__lastFocusPersistAtMs) > 15000 || Math.abs((state.__lastFocusPersistSec||0) - s) >= 3){
              state.__lastFocusPersistAtMs = nowMs;
              state.__lastFocusPersistSec = s;
              focusSaveSeconds(s);
            }
          }
        }catch(e){}

        // time color: work = user color, break/idle = fixed grey
        const tc = clampHexColor(p.theme?.timeColor || "#ffffff");
        timeEl.style.color = (p.status==="work") ? tc : "#9aa0a6";
      }
    }


    // Compact mode: on very small windows, replace tiles with a fast roster list (요청 7)
    const COMPACT_W = 560; // px

    // ✅ 뷰포트 폭을 더 안정적으로 계산(초기 로딩 시 innerWidth=0 케이스 방어)
    function getViewportW(){
      try{
        const w1 = (window.innerWidth || 0);
        const w2 = (document.documentElement && document.documentElement.clientWidth) ? document.documentElement.clientWidth : 0;
        return Math.max(w1, w2);
      }catch(e){
        return (window.innerWidth || 0);
      }
    }

    function isCompactNow(){
      const g = els.grid || document.getElementById("grid");
      const vw = getViewportW();
      // ✅ 사이드바/여백 때문에 '실제 그리드가 확보한 폭'이 더 좁아지는 경우를 반영
      let w = vw;
      try{
        if(g && g.getBoundingClientRect){
          const r = g.getBoundingClientRect();
          // ✅ grid가 비어 있을 때 width가 0~아주 작게 잡히면서 compact가 '오작동'하는 케이스 방지
          if(r && r.width){
            const rw = r.width;
            if(rw > 120) w = Math.min(w || rw, rw);
          }
        }
      }catch(e){}
      if(!w) return false;

      const isMini = !!(g && g.classList && g.classList.contains("compact5"));
      const colsNeeded = 3;   // ✅ 기본/미니 모두: 3개 남기면 접기(요청)
      let tileMin = isMini ? 150 : 170;
      try{
        if(g){
          const v = getComputedStyle(g).getPropertyValue("--tileMin").trim();
          const n = parseFloat(v);
          if(isFinite(n)) tileMin = n;
        }
      }catch(e){}
      const gap = 8;
      const threshold = Math.ceil(tileMin * colsNeeded + gap * Math.max(0, colsNeeded-1) + 50);
      return w <= threshold;
    }

    function preserveChatScrollForLayout(fn){
      try{
        const el = els.chatList;
        if(!el){ fn(); return; }
        const fromBottom = (el.scrollHeight - el.scrollTop - el.clientHeight);
        const atBottom = fromBottom < 40;
        fn();
        state.chatScrollLockUntil = Date.now() + 500;
        requestAnimationFrame(()=>{
          try{
            if(atBottom){ el.scrollTop = el.scrollHeight; }
            else{
              const nextTop = Math.max(0, el.scrollHeight - el.clientHeight - fromBottom);
              el.scrollTop = nextTop;
            }
          }catch(e){}
        });
      }catch(e){ try{ fn(); }catch(_e){} }
    }

    function applyCompactMode(force){
      const compact = (typeof force === "boolean") ? force : isCompactNow();
      const was = document.body.classList.contains("compact");
      if(was === compact) return compact;
      preserveChatScrollForLayout(()=>{ document.body.classList.toggle("compact", compact); });
      return compact;
    }

    function renderStatusRoster(onlineArr){
      if(!els.statusRosterList) return;
      els.statusRosterList.innerHTML = "";
      for(const p of onlineArr){
        const item = document.createElement("div");
        item.className = "statusRosterItem";

        const left = document.createElement("div");
        left.className = "statusRosterLeft";

        const emo = document.createElement("div");
        emo.className = "statusRosterEmoji";
        emo.textContent = (p.theme?.emoji || "🙂");
        const eb = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
        emo.style.background = eb;
        emo.style.borderColor = hexToRgba("#ffffff", 0.16);

        const nm = document.createElement("div");
        nm.className = "statusRosterName";
        nm.textContent = (p.name || p.id) + (!isOnlinePresence(p) ?"🚫":"");

        left.appendChild(emo);
        left.appendChild(nm);

        const st = document.createElement("div");
        st.className = "statusRosterStatus";
        const bd = statusBadge(p);
        st.textContent = `${bd.emoji} ${bd.text}`;

        item.appendChild(left);
        item.appendChild(st);
        els.statusRosterList.appendChild(item);
      }
    }

    function renderCompactRoster(onlineArr){
      if(!els.grid) return;
      els.grid.innerHTML = "";

      const wrap = document.createElement("div");
      wrap.className = "gridRosterWrap";

      const title = document.createElement("div");
      title.className = "gridRosterTitle";
      title.textContent = `👥 접속자 목록 (${onlineArr.length})`;

      const list = document.createElement("div");
      list.className = "gridRosterList";

      for(const p of onlineArr){
        const item = document.createElement("div");
        item.className = "gridRosterItem";

        const left = document.createElement("div");
        left.className = "gridRosterLeft";

        const emoji = document.createElement("div");
        emoji.className = "gridRosterEmoji";
        emoji.textContent = (p.theme?.emoji || "✍️");
        const emoBg = clampHexColor(p.theme?.emojiBg || "#2b2b2b");
        emoji.style.background = hexToRgba(emoBg, 0.18);
        emoji.style.borderColor = hexToRgba(emoBg, 0.40);

        const nm = document.createElement("div");
        nm.className = "gridRosterName";
        nm.textContent = (p.name || "익명");

        left.appendChild(emoji);
        left.appendChild(nm);

        const st = document.createElement("div");
        st.className = "gridRosterStatus";
        const s = (p.status || "idle");
        st.textContent = (s==="work") ? "✍️ 작업중" : (s==="break") ? "☕ 휴식중" : (s==="idle") ? "🌙 자리비움" : "—";

        item.appendChild(left);
        item.appendChild(st);

        // 우클릭(강퇴 메뉴)
        item.addEventListener("contextmenu", (ev)=>{
          ev.preventDefault();
          ev.stopPropagation();
          openCtxMenu(ev.clientX, ev.clientY, p);
        });

        list.appendChild(item);
      }

      wrap.appendChild(title);
      wrap.appendChild(list);
      els.grid.appendChild(wrap);
    }

    function renderGridTilesOrRoster(onlineArr){
      if(!els.grid) return;
      const compact = applyCompactMode();
      if(compact){
        // ✅ compact(아주 좁은 폭)에서도 '채팅만' 남기지 말고, 빠른 접속자 목록(로스터)로 대체
        renderCompactRoster(onlineArr);
        return;
      }

      // normal tiles
      els.grid.innerHTML = "";
      for(const p of onlineArr){
        try{
          const t = renderTile(p);
          if(t) els.grid.appendChild(t);
        }catch(err){
          console.warn("[tile] renderTile failed, fallback tile used:", err);
          // ✅ 렌더 실패해도 전체가 비지 않도록 안전 타일
          const fallback = document.createElement("div");
          fallback.className = "tile";
          const bg = document.createElement("div");
          bg.className = "bg";
          bg.style.background = "linear-gradient(135deg, rgba(255,182,214,.35), rgba(255,119,184,.25))";
          const inner = document.createElement("div");
          inner.className = "inner";
          const top = document.createElement("div");
          top.className = "top";
          const status = document.createElement("div");
          status.className = "status";
          status.textContent = "⚠️";
          const name = document.createElement("div");
          name.className = "name";
          name.textContent = (p?.name || p?.id || "unknown");
          top.appendChild(status);
          top.appendChild(name);
          inner.appendChild(top);
          fallback.appendChild(bg);
          fallback.appendChild(inner);
          els.grid.appendChild(fallback);
        }
      }
    }

    // Join / Leave
    async function subscribeParticipants(){
      if(state.unsubParticipants) state.unsubParticipants();
      state.unsubParticipants = null;
      if(!state.nonChatEnabled){ return; }

      const q = rQuery(
        rPresenceRootRef(state.roomId),
        rOrderByChild("lastSeenAtMs"),
        rLimitToLast(80)
      );

      const onP = (snap)=>{
        const v = (snap && snap.val) ? (snap.val() || {}) : {};
        const arr = [];
        const map = new Map();
        for(const [uid, data] of Object.entries(v)){
          if(!data) continue;
          const p = { id: uid, ...data };
          arr.push(p);
          map.set(uid, p);
        }
        // 정렬: lastSeen desc
        arr.sort((a,b)=> Number(b.lastSeenAtMs||0) - Number(a.lastSeenAtMs||0));

        state.currentParticipants = map;
        syncMyStatusUI();

        // ✅ (중요) "오늘 작업시간" 로컬 누적 복구/동기화 (브라우저 기준)
        try{
          if(!state.didFocusMerge && state.uid){
            const meNow = map.get(state.uid);
            if(meNow){
              const today = seoulDateKey();
              const localSec = Math.floor(Number(focusLoadSeconds()||0));
              let remoteSec = 0;
              try{ remoteSec = Math.floor(Number(computeDisplayedTotal(meNow)||0)); }catch(e){ remoteSec = Math.floor(Number(meNow.totalSecondsToday||0)); }
              const merged = Math.max(localSec, remoteSec);
              if(merged !== localSec) focusSaveSeconds(merged);

              const needsRemotePatch =
                (Math.floor(Number(meNow.totalSecondsToday||0)) !== merged) ||
                (meNow.sessionStartedAtMs != null) ||
                ((meNow.status||"break") !== "break") ||
                ((meNow.dateKey||today) !== today);

              if(needsRemotePatch){
                rUpdate(rMePresenceRef(state.roomId, state.uid), {
                  dateKey: today,
                  status: "break",
                  totalSecondsToday: merged,
                  sessionStartedAtMs: null,
                  updatedAt: Date.now(),
                  lastSeenAtMs: Date.now(),
                }).catch(()=>{});
              }
              state.didFocusMerge = true;
            }
          }
        }catch(e){}

        // ✅ 오프라인은 "접속 종료"처럼 처리: 리스트/타일에서 제외
        const onlineArr = arr.filter(p=> isDisplayablePresence(p));

        // ✅ 입장 전: 인원만 '대략치'로 보여주고, 타일/목록/상태 등은 렌더하지 않음
        try{ updateOnlineCountUI(onlineArr.length); }catch(e){}
        try{ els.lastSync.textContent = new Date().toLocaleTimeString("ko-KR"); }catch(e){}
        if(!state.joined){
          try{ if(els.grid) els.grid.innerHTML = ""; }catch(e){}
          try{ if(els.statusRosterList) els.statusRosterList.innerHTML = ""; }catch(e){}
          try{ if(els.missionSuccessCount) els.missionSuccessCount.textContent = "0"; }catch(e){}
          return;
        }


        // ✅ 미션 성공 인원: missions 구독값을 기본으로
        let successCount = 0;
        try{
          successCount = Number(state.missionSuccessCount || 0);
          if(!successCount){
            const todayKey = seoulDateKey();
            successCount = onlineArr.filter(p => p && p.mission && String(p.mission.dayKey||"")===String(todayKey) && !!p.mission.done).length;
          }
        }catch(e){ successCount = 0; }
        state.missionSuccessCount = successCount;
        renderMissionSuccessCount(successCount);

        onlineArr.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));

        // (joined) 상단 인원 표시 업데이트
        try{ updateOnlineCountUI(onlineArr.length); }catch(e){}
        els.lastSync.textContent = new Date().toLocaleTimeString("ko-KR");

        renderStatusRoster(onlineArr);
        renderGridTilesOrRoster(onlineArr);
        try{ setMissionButtonState(); }catch(e){}
      };

      rOnValue(q, onP);
      state.unsubParticipants = ()=>{ try{ rOff(q, "value", onP); }catch(e){} };
    }



    // Join / Leave
    
async function joinRoom(){
      try{
        const name = normalizeNick(els.name.value); els.name.value = name;
        state.nickname = name;
        setMyNickUI(name);
        try{ const lp = loadLocalProfile() || {}; lp.nickname = name; saveLocalProfile(lp); }catch(e){}
        if(!name){ showToast("닉네임 입력!"); return; }
        if(name === "익명"){ showToast("‘익명’은 닉네임으로 사용할 수 없어 🙏"); return; }
        if(!(await requirePassOK())) return;

        const miss = validateFirebaseConfig();
        if(miss.length){
          showToast("Firebase 설정 미완성: " + miss.join(", "), 4500);
          console.error("Firebase config missing/placeholder:", miss, firebaseConfig);
          return;
        }

        state.roomId = FIXED_ROOM_ID;

        // ✅ 채팅 로드량 줄이기: 같은 날 재입장(로그아웃/새로고침) 시 최근 10개만 표시
        try{
          const dk = seoulDateKey();
          const k = `mk_last_join_day_${state.roomId}`;
          const last = localStorage.getItem(k) || "";
          state.chatLimit = (last === dk) ? 10 : 70;
          localStorage.setItem(k, dk);
        }catch(e){ state.chatLimit = 70; }
        await signInAnonymously(auth);
      if(!state.uid){
        await new Promise((resolve)=>{
          const off = onAuthStateChanged(auth, (user)=>{
            if(user){
              state.uid = user.uid;
              off();
              resolve();
            }
          });
        });
      }

      
      // 강퇴 상태(시간 제한)면 입장 막기
      try{
        const ks = await getDoc(kickRef(state.roomId, state.uid));
        if(ks.exists()){
          const k = ks.data() || {};
          const exp = Number(k.expiresAtMs || 0);
          if(exp && exp > Date.now()){
            showToast("🚫 강퇴 상태라 잠시 입장할 수 없어");
            setControlsEnabled(false);
            return;
          }
        }
      }catch(e){}

      setControlsEnabled(true);
      await ensureRoom(state.roomId);
      await ensureMeDoc();
      // ✅ RTDB 재연결 감지(일시 끊김 후 status/off 고정 방지)
      try{ startRtdbConnectionWatch(); }catch(e){}

      const meSnap = await rGet(rMePresenceRef(state.roomId, state.uid));
      if(meSnap && meSnap.exists && meSnap.exists()){
        const me = meSnap.val() || {};
        els.emoji.value = me.theme?.emoji || "✍️";
        els.bgColor.value = me.theme?.bgColor || "#ffd0e2";
        if(els.emojiBgColor) els.emojiBgColor.value = me.theme?.emojiBg || "#2b2b2b";
        try{ if(els.emojiBgTransparent) els.emojiBgTransparent.checked = (me.theme?.emojiBgTransparent === true || me.theme?.emojiBgTransparent === "true"); }catch(e){}
        if(els.bubbleColor) els.bubbleColor.value = me.theme?.bubbleColor || me.theme?.bgColor || "#ffd0e2";
        if(els.timeColor) els.timeColor.value = me.theme?.timeColor || "#ffffff";
        if(els.timePicker && els.timeColor) els.timePicker.value = els.timeColor.value;
        if(els.emojiSize){ els.emojiSize.value = String(me.theme?.emojiSize || 40); if(els.emojiSizeNum) els.emojiSizeNum.value = els.emojiSize.value; }
        if(els.photoSize){ els.photoSize.value = String(me.theme?.photoSize || 68); if(els.photoSizeNum) els.photoSizeNum.value = els.photoSize.value; }
        if(els.bgPattern) els.bgPattern.value = me.theme?.pattern || "none";
        if(els.patternColor) els.patternColor.value = me.theme?.patternColor || "#ffffff";
        if(els.patternPicker && els.patternColor) els.patternPicker.value = els.patternColor.value;
        els.bubbleText.value = me.bubbleText || "";
        state.myPhotoUrl = me.theme?.photoUrl || "";
        try{ if(els.photoEnabled) els.photoEnabled.checked = (me.theme?.photoEnabled !== false); }catch(e){}
        // ✅ 글씨 색(닉네임/채팅 닉네임/상태/말풍선) 복원
        try{
          if(els.nameColor){ els.nameColor.value = clampHexColor(me.theme?.nameColor || "#ffffff"); }
          if(els.nameColorPicker){ els.nameColorPicker.value = (els.nameColor ? els.nameColor.value : clampHexColor(me.theme?.nameColor || "#ffffff")); }
          if(els.chatNameColor){ els.chatNameColor.value = clampHexColor(me.theme?.chatNameColor || me.theme?.nameColor || "#ffffff"); }
          if(els.chatNameColorPicker){ els.chatNameColorPicker.value = (els.chatNameColor ? els.chatNameColor.value : clampHexColor(me.theme?.chatNameColor || me.theme?.nameColor || "#ffffff")); }
          if(els.statusTextColor){ els.statusTextColor.value = clampHexColor(me.theme?.statusTextColor || "#ffffff"); }
          if(els.statusTextColorPicker){ els.statusTextColorPicker.value = (els.statusTextColor ? els.statusTextColor.value : clampHexColor(me.theme?.statusTextColor || "#ffffff")); }
          if(els.bubbleTextColor){ els.bubbleTextColor.value = clampHexColor(me.theme?.bubbleTextColor || "#ffffff"); }
          if(els.bubbleTextColorPicker){ els.bubbleTextColorPicker.value = (els.bubbleTextColor ? els.bubbleTextColor.value : clampHexColor(me.theme?.bubbleTextColor || "#ffffff")); }
        }catch(e){}
      } else {
        // 신규/테마없음: 브라우저 프리셋을 UI에 반영
        try{
          const lp = loadLocalProfile();
          if(lp && lp.theme){
            els.emoji.value = lp.theme.emoji || els.emoji.value;
            els.bgColor.value = lp.theme.bgColor || els.bgColor.value;
            if(els.emojiBgColor) els.emojiBgColor.value = lp.theme.emojiBg || "#2b2b2b";
                try{ if(els.emojiBgTransparent) els.emojiBgTransparent.checked = (lp.theme.emojiBgTransparent === true || lp.theme.emojiBgTransparent === "true"); }catch(e){}
            if(els.bubbleColor) els.bubbleColor.value = lp.theme.bubbleColor || lp.theme.bgColor || "#ffd0e2";
            if(els.timeColor) els.timeColor.value = lp.theme.timeColor || "#ffffff";
            if(els.timePicker && els.timeColor) els.timePicker.value = els.timeColor.value;
            if(els.emojiSize){ els.emojiSize.value = String(lp.theme.emojiSize || 40); if(els.emojiSizeNum) els.emojiSizeNum.value = els.emojiSize.value; }
            if(els.photoSize){ els.photoSize.value = String(lp.theme.photoSize || 68); if(els.photoSizeNum) els.photoSizeNum.value = els.photoSize.value; }
            if(els.bgPattern) els.bgPattern.value = lp.theme.pattern || (els.bgPattern.value||"none");
            if(els.patternColor) els.patternColor.value = lp.theme.patternColor || "#ffffff";
            if(els.patternPicker && els.patternColor) els.patternPicker.value = els.patternColor.value;
            els.bubbleText.value = lp.bubbleText || (els.bubbleText.value||"");
            state.myPhotoUrl = lp.theme.photoUrl || state.myPhotoUrl;
            try{ if(els.photoEnabled) els.photoEnabled.checked = (lp.theme.photoEnabled !== false); }catch(e){}
            // ✅ 글씨 색(닉네임/채팅 닉네임/상태/말풍선) 복원 (브라우저 저장값)
            try{
              if(els.nameColor){ els.nameColor.value = clampHexColor(lp.theme.nameColor || "#ffffff"); }
              if(els.nameColorPicker){ els.nameColorPicker.value = (els.nameColor ? els.nameColor.value : clampHexColor(lp.theme.nameColor || "#ffffff")); }
              if(els.chatNameColor){ els.chatNameColor.value = clampHexColor(lp.theme.chatNameColor || lp.theme.nameColor || "#ffffff"); }
              if(els.chatNameColorPicker){ els.chatNameColorPicker.value = (els.chatNameColor ? els.chatNameColor.value : clampHexColor(lp.theme.chatNameColor || lp.theme.nameColor || "#ffffff")); }
              if(els.statusTextColor){ els.statusTextColor.value = clampHexColor(lp.theme.statusTextColor || "#ffffff"); }
              if(els.statusTextColorPicker){ els.statusTextColorPicker.value = (els.statusTextColor ? els.statusTextColor.value : clampHexColor(lp.theme.statusTextColor || "#ffffff")); }
              if(els.bubbleTextColor){ els.bubbleTextColor.value = clampHexColor(lp.theme.bubbleTextColor || "#ffffff"); }
              if(els.bubbleTextColorPicker){ els.bubbleTextColorPicker.value = (els.bubbleTextColor ? els.bubbleTextColor.value : clampHexColor(lp.theme.bubbleTextColor || "#ffffff")); }
              if(els.chatNameColor){ els.chatNameColor.value = clampHexColor(lp.theme.chatNameColor || lp.theme.nameColor || "#ffffff"); }
              if(els.chatNameColorPicker){ els.chatNameColorPicker.value = (els.chatNameColor ? els.chatNameColor.value : clampHexColor(lp.theme.chatNameColor || lp.theme.nameColor || "#ffffff")); }
            }catch(e){}
          }
        }catch(e){}
      }
// ✅ 재접속 복구: 이전 세션이 off로 남아 있으면 즉시 break로 되살리기
try{
  if(meSnap && meSnap.exists && meSnap.exists()){
    const me = meSnap.val() || {};
    if(me && (me.status === "off" || Number(me.lastSeenAtMs||0) === 0)){
      await rUpdate(rMePresenceRef(state.roomId, state.uid), {
        status: "break",
        statusSource: "reconnectJoin",
        sessionStartedAtMs: null,
        updatedAt: Date.now(),
        lastSeenAtMs: Date.now()
      });
      state.myStatus = "break";
    }
  }
}catch(e){}
      // 🔁 브라우저 프리셋도 동기화(다음 접속 편의)
      try{
        const lp = loadLocalProfile() || {};
        lp.theme = { emoji: els.emoji.value, bgColor: els.bgColor.value, pattern: (els.bgPattern?els.bgPattern.value:"none"), patternColor: (els.patternColor?els.patternColor.value:"#ffffff"), photoUrl: state.myPhotoUrl||"", photoEnabled: (els.photoEnabled ? !!els.photoEnabled.checked : true), emojiBg: (els.emojiBgColor?els.emojiBgColor.value:"#2b2b2b"),
            emojiBgTransparent: (els.emojiBgTransparent ? !!els.emojiBgTransparent.checked : false), bubbleColor: (els.bubbleColor?els.bubbleColor.value:els.bgColor.value), timeColor: (els.timeColor?els.timeColor.value:"#ffffff"),
            nameColor: (els.nameColor ? els.nameColor.value : "#ffffff"), chatNameColor: (els.chatNameColor ? els.chatNameColor.value : ((els.nameColor?els.nameColor.value:"#ffffff"))),
            statusTextColor: (els.statusTextColor ? els.statusTextColor.value : "#ffffff"), bubbleTextColor: (els.bubbleTextColor ? els.bubbleTextColor.value : "#ffffff"),
            emojiSize: (els.emojiSize?Number(els.emojiSize.value):40), photoSize: (els.photoSize?Number(els.photoSize.value):68) };
        lp.bubbleText = (els.bubbleText.value||"");
        saveLocalProfile(lp);
      }catch(e){}

      // ✅ 입장 시 시작 상태: 무조건 "휴식중" + 헬퍼 OFF
      try{ setHelperMode("manual", true); }catch(e){}
      try{ await transitionTo("break","manualInit"); }catch(e){}

      subscribeRoom();
      await subscribeParticipants();
      // ✅ 자동 휴식/자리비움 감지 시작(입장 후)
      try{ bumpActivity(); }catch(e){}
      try{ startActivityWatch(); }catch(e){ console.warn("startActivityWatch failed", e); }
      // ✅ 미션 성공 인원(로그아웃/재입장에도 유지)
      subscribeMissionFeed();
      scheduleMissionDayWatcher();
      subscribeChat();
      subscribeKicks();

      await heartbeat();
      if(state.tickTimer) clearInterval(state.tickTimer);
      state.tickTimer = setInterval(()=>{ updateTimersLive(); updateClocks(); }, 1000);
      updateClocks();

      if(state.hbTimer) clearInterval(state.hbTimer);
      state.hbTimer = setInterval(heartbeat, 30_000);

      try{ localStorage.setItem("mk_last_name", name); }catch(e){}
      els.meHint.textContent = name;
      try{ if(els.checkInBtn) __applyCheckInBtnUI(els.checkInBtn); }catch(e){}
      // ✅ 출근 팝업(iframe) 미리 웜업해서 버튼 반응 체감 속도 올리기
      try{ window.warmAttendanceFrame && window.warmAttendanceFrame(); }catch(e){}
      showToast("입장!");
      // ✅ 출근(출석) 자동 팝업: 입장 UI가 안정된 뒤(클릭 이벤트 종료 후) 열기 + 1회 재시도
      try{ scheduleAttendanceAutoOpenAfterJoin(); }catch(e){}
      // ✅ 30초마다 로컬에 집중시간 저장(예기치 않은 종료 대비)
      try{ if(state.focusPersistTimer) clearInterval(state.focusPersistTimer); }catch(e){}
      try{ state.focusPersistTimer = setInterval(()=>{ try{ if(state.joined) persistMyFocusToLocal(); }catch(e){} }, 30000); }catch(e){}
      // ✅ 입장 사운드(모두에게): 나는 즉시 재생, 다른 사람은 sfx 이벤트로 재생
      try{ playSfx("enter"); }catch(e){}
      try{ emitSfx("enter"); }catch(e){}
      try{ emitSys(`❣️ ${state.nickname} 입장 🥰`); }catch(e){}
      }catch(e){
        console.error(e);
        const code = e?.code || "";
        const msg = e?.message || "";
        showToast("입장 실패: " + (code || "오류"), 3500);
        if(msg) console.warn("joinRoom error message:", msg);
        // 개발자도구 없이도 바로 감 잡게 짧게 한 번 더
        if(!code && msg) showToast("입장 실패: " + msg.slice(0, 60), 3500);
        const hint = friendlyAuthHint(code);
        if(hint) console.warn(hint);
        // 화면에서도 힌트를 보여주고 싶으면 아래 한 줄 주석 해제
        if(hint) showToast(hint, 4500);
      }
    }

    async function leaveRoom(){
      // ✅ 퇴장 직전 집중시간 로컬 저장
      persistMyFocusToLocal();
      // ✅ 자동 휴식/자리비움 감지 타이머 정리(퇴장 시)
      try{ stopActivityWatch(); }catch(e){}
      // ✅ 퇴장 사운드(모두에게)
      try{ playSfx("exit"); }catch(e){}
      /* 퇴장 메시지 삭제 (요청) */
      /* exit sfx disabled */
      if(!state.roomId || !state.uid) return;

      try{ await transitionTo("idle","manual"); }catch(e){}

      if(state.unsubParticipants) state.unsubParticipants();
      if(state.unsubRoom) state.unsubRoom();
      if(state.unsubChat) state.unsubChat();
      if(state.unsubKick) state.unsubKick();
      if(state.unsubMissionFeed) state.unsubMissionFeed();
      state.unsubParticipants = null;
      state.unsubRoom = null;
      state.unsubChat = null;
      state.unsubKick = null;
      state.unsubMissionFeed = null;

      try{ await rUpdate(rMePresenceRef(state.roomId, state.uid), { status:"off", sessionStartedAtMs:null, lastSeenAtMs: 0, updatedAt: Date.now() }); }catch(e){}
      try{ if(state._rtdbOnDisc){ state._rtdbOnDisc.cancel?.(); state._rtdbOnDisc=null; } }catch(e){}

      els.grid.innerHTML = "";
      els.chatList.innerHTML = "";
      state.currentParticipants = new Map();
      state.lastRendered.clear();

      setControlsEnabled(false);
    updateClocks();

      if(state.tickTimer) clearInterval(state.tickTimer);
      if(state.hbTimer) clearInterval(state.hbTimer);
      state.tickTimer = null;
      state.hbTimer = null;

      els.meHint.textContent = "—";
      try{ if(state.focusPersistTimer) clearInterval(state.focusPersistTimer); }catch(e){}
      state.focusPersistTimer = null;
      // 다음 입장 때 sfx 최초 로드 처리 다시
      state.sfxInitDone = false; state.lastSfxTs = 0;
      showToast("퇴장!");
    }

    // UI bindings
    initPalette();

    // ✅ 닉네임/상태/말풍선 글씨 색 컨트롤
    (function(){
      const wire = (pickerEl, textEl)=>{
        if(!pickerEl || !textEl) return;
        const sync = (v)=>{
          const c = clampHexColor(v || "#ffffff");
          textEl.value = c;
          pickerEl.value = c;
        };
        pickerEl.addEventListener("input", ()=>sync(pickerEl.value));
        textEl.addEventListener("change", ()=>sync(textEl.value));
        textEl.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); sync(textEl.value); textEl.blur(); }});
        sync(textEl.value || pickerEl.value || "#ffffff");
      };
      wire(els.nameColorPicker, els.nameColor);
      wire(els.statusTextColorPicker, els.statusTextColor);
      wire(els.bubbleTextColorPicker, els.bubbleTextColor);
    })();

    // keep dashboard docked
    
window.addEventListener("resize", ()=>{
  dockRightRail();
  ensureChatLayout();
  // ✅ 창 폭 변화 시: compact 모드/타일↔접속자목록 즉시 갱신
  try{
    const arr = [...state.currentParticipants.values()];
    const onlineArr = arr.filter(p=> isDisplayablePresence(p));
    onlineArr.sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "ko"));
    renderGridTilesOrRoster(onlineArr);
  }catch(e){
    applyCompactMode();
  }
});

// =============================
// 🔋 Firestore Read Saver (채팅 제외 구독 제어)
// - nonChatEnabled=false: 참가자/방설정 등 onSnapshot 구독을 끊어서 Firestore 읽기 폭증 방지
// - 탭이 숨겨지면 자동으로 non-chat 구독을 끊고, 다시 보이면 필요 시 재구독
// =============================
function pauseNonChatSubscriptions(reason){
  try{
    if(state.unsubParticipants){ state.unsubParticipants(); state.unsubParticipants = null; }
    if(state.unsubRoom){ state.unsubRoom(); state.unsubRoom = null; }
    // kick은 1문서라 가볍지만, 원하면 같이 끊기
    if(state.unsubKick){ state.unsubKick(); state.unsubKick = null; }
    state.nonChatPausedByHidden = (reason === "hidden");
  }catch(e){}
}
function resumeNonChatSubscriptions(){
  try{
    if(!state.nonChatEnabled) return;
    subscribeRoom();
    subscribeParticipants();
    subscribeKicks();
    state.nonChatPausedByHidden = false;
  }catch(e){}
}
function setNonChatEnabled(on){
  state.nonChatEnabled = !!on;
  try{
    localStorage.setItem("mk_nonchat_enabled", state.nonChatEnabled ? "1" : "0");
  }catch(e){}
  if(state.nonChatEnabled){
    resumeNonChatSubscriptions();
    showToast("절약모드 해제: 참가자/설정 실시간 ON");
  }else{
    pauseNonChatSubscriptions("manual");
    showToast("절약모드 ON: 채팅만 실시간");
  }
  try{
    const b = document.getElementById("dataSaverBtn");
    if(b){ b.textContent = state.nonChatEnabled ? "절약모드" : "실시간 켜기"; }
  }catch(e){}
}
// tab visibility: auto pause/resume (채팅은 유지)
document.addEventListener("visibilitychange", ()=>{
  if(document.hidden){
    // non-chat only
    pauseNonChatSubscriptions("hidden");
  }else{
    // 돌아오면, 사용자가 nonChatEnabled를 꺼두지 않은 경우만 재구독
    if(state.nonChatEnabled) resumeNonChatSubscriptions();
  }
});

window.addEventListener("scroll", dockRightRail, {passive:true});
    setTimeout(dockRightRail, 80);
    // ✅ 초기 로딩 때 compact 오판 방지(레이아웃 확정 후 판단)
    requestAnimationFrame(()=>applyCompactMode());
    setTimeout(()=>applyCompactMode(), 180);

    if(els.onlineBtn){
      els.onlineBtn.addEventListener("click", ()=>{
        const n = (els.countOnline && els.countOnline.textContent) ? els.countOnline.textContent : "0";
        showToast(`👥 지금 ${n}명 접속중`);
      });
    }

    els.joinBtn.addEventListener("click", joinRoom);

    // ✅ Nickname clamp (IME-safe)
    if(els.name){
      let composing = false;
      els.name.addEventListener("compositionstart", ()=>{ composing = true; });
      els.name.addEventListener("compositionend", ()=>{ composing = false; els.name.value = normalizeNick(els.name.value); });
      els.name.addEventListener("input", ()=>{ if(composing) return; els.name.value = normalizeNick(els.name.value); });
      els.name.addEventListener("blur", ()=>{ els.name.value = normalizeNick(els.name.value); });
    }

    els.leaveBtn.addEventListener("click", leaveRoom);

    if(els.layoutToggleBtn){
      applyLayoutMode(getLayoutMode());
      els.layoutToggleBtn.addEventListener("click", toggleLayoutMode);
    }

    els.btnWork.addEventListener("click", ()=>{ transitionTo("work","manual"); });
    if(els.btnHelperToggle) els.btnHelperToggle.addEventListener("click", ()=>{
      if(!state.joined) return;
      const me = (state.currentParticipants && state.currentParticipants.get) ? state.currentParticipants.get(state.uid) : null;
      const st = (me && me.status) ? me.status : (state.myStatus || "idle");
      if(st !== "work"){ showToast("✍️ 작업중에서만 헬퍼를 켤 수 있어요"); return; }
      const hm = getHelperMode();
      const next = (hm === "auto") ? "manual" : "auto";
      setHelperMode(next, true);
      try{ syncMyStatusUI(); }catch(e){}
      try{ updateHelperStatusUI(); }catch(e){}
    });

    els.btnBreak.addEventListener("click", ()=>{ try{ setHelperMode("manual", true); }catch(e){} transitionTo("break","manual"); });
    els.btnIdle.addEventListener("click", ()=>{ try{ setHelperMode("manual", true); }catch(e){} transitionTo("idle","manual"); });
// ✅ 타이머 초기화 (오늘 작업시간/상태/세션 시작시간)
async function resetTodayTimer(){
  try{
    // 로컬 누적 0
    try{ focusSaveSeconds(0); }catch(e){}
    // 진행중 세션도 끊고 상태는 휴식으로
    if(state.roomId && state.uid){
      await rUpdate(rMePresenceRef(state.roomId, state.uid), {
        totalSecondsToday: 0,
        sessionStartedAtMs: null,
        status: "break",
        statusSource: "resetTimer",
        dateKey: seoulDateKey(),
        updatedAt: Date.now(),
        lastSeenAtMs: Date.now(),
      });
    }
    // UI 갱신
    try{ state.myStatus = "break"; syncMyStatusUI(); }catch(e){}
    showToast("⏱️ 오늘 작업 타이머를 초기화했어!");
  }catch(e){
    console.warn("[timerReset] failed", e);
    showToast("타이머 초기화 실패(권한/연결 확인)");
  }
}
try{
  els.btnTimerReset?.addEventListener("click", ()=>{
    if(!confirm("오늘 작업 타이머(누적시간)를 0으로 초기화할까?")) return;
    resetTodayTimer();
  });
}catch(e){}
    // 상태 메뉴 토글
    
    if(els.checkInBtn){
      try{ __applyCheckInBtnUI(els.checkInBtn); }catch(e){}
      // ===== 출근(출석) 팝업(구글 시트 연동) =====
      // ✅ 여기에 '웹앱으로 배포'한 Apps Script URL을 넣어주세요.
      // 예) https://script.google.com/macros/s/XXXXX/exec
      const ATTEND_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbwlNMg0G7Kt3wcAQtzQ5_zttwxLNT2VndA1ZPBpxo5PdNejRkKvKg220xoJ-L2ElHDz/exec?embedded=1";
      // 출근(출석) 팝업 내부 이동(1회=닉선택 화면, 2회 이상=완료 화면) 감지용
      let __attLoadCount = 0;
      let __attDoneReady = false;
      function __resetAttendFlow(){
        __attLoadCount = 0;
        __attDoneReady = false;
      }


      // ✅ 출근(출석) 팝업: "열리는 반응"을 먼저 빠르게, 로딩은 뒤에서
const ATTEND_KEEP_WARM = true; // 팝업을 닫아도 iframe을 유지해서 다
const ATTEND_AUTO_OPEN_ON_JOIN = true;
const ATTEND_DEBUG = false; // (production)


window.__attDbgPanelPush = function(msg){
  try{
    const last = document.getElementById("attDbgLast");
    const log = document.getElementById("attDbgLog");
    if(last) last.textContent = msg;
    if(log){
      const line=document.createElement("div");
      line.textContent = msg;
      log.prepend(line);
    }
  }catch(e){}
};
// --- /ATTEND DEBUG PANEL ---

const __attDbgSeen = Object.create(null);
function __attDbg(msg, toast=false){
  try{
    if(!ATTEND_DEBUG) return;
    console.log("[ATTEND]", msg);
    try{ window.__attDbgPanelPush && window.__attDbgPanelPush(msg); }catch(e){}
    if(toast && typeof showToast === "function") showToast("🐞 " + msg);
  }catch(e){}
}
function __attDbgOnce(key, msg){
  try{
    if(!ATTEND_DEBUG) return;
    if(__attDbgSeen[key]) return;
    __attDbgSeen[key]=1;
    __attDbg(msg, true);
  }catch(e){}
}
 // 자정 이후 첫 입장/재입장 시, 출석 안 했고 모달도 안 열었으면 자동 팝업
      // (fix) 출석 팝업을 빠르게 열기 위한 워밍업 로직
let __attWarmAtMs = 0;

function __buildAttendSrc(cacheBust=true){
  const u = new URL(ATTEND_WEBAPP_URL);
  u.searchParams.set("embedded", "1");
  if(cacheBust) u.searchParams.set("_", String(Date.now()));
  return u.toString();
}

const LS_ATTEND_OPEN_DAY = "mk_attend_open_day_v1";
const LS_ATTEND_AUTO_SHOWN_DAY = "mk_attend_auto_shown_day_v1";
function __hasOpenedAttendToday(){
  try{ return (localStorage.getItem(LS_ATTEND_OPEN_DAY) || "") === __seoulDateKey(); }catch(e){ return false; }
}
function __markOpenedAttendToday(){
  try{ localStorage.setItem(LS_ATTEND_OPEN_DAY, __seoulDateKey()); }catch(e){}
}

function __hasAutoShownAttendToday(){
  try{ return (localStorage.getItem(LS_ATTEND_AUTO_SHOWN_DAY) || "") === __seoulDateKey(); }catch(e){ return false; }
}
function __markAutoShownAttendToday(){
  try{ localStorage.setItem(LS_ATTEND_AUTO_SHOWN_DAY, __seoulDateKey()); }catch(e){}
}
// ✅ "오늘 출근 안했고, 오늘 한 번도 출근 모달을 안 열었으면" 자동 오픈

// ✅ 입장 직후 자동 출근 팝업 스케줄러(클릭/모달 토글 충돌 방지용)
let __attAutoOpenLastMs = 0;
function scheduleAttendanceAutoOpenAfterJoin(){
  try{
    if(!ATTEND_AUTO_OPEN_ON_JOIN) return;
    if(!state.joined) return;
    if(__isCheckedInToday()) return;

    const now = Date.now();
    if(now - __attAutoOpenLastMs < 5000) return; // 과도한 중복 방지
    __attAutoOpenLastMs = now;

    // 1차: 입장 UI 안정화 후
    setTimeout(()=>{ try{ autoOpenAttendanceIfNeeded(); }catch(e){} }, 1100);

    // 2차: 혹시 다른 모달/포커스 충돌로 실패했으면 한 번 더
    setTimeout(()=>{
      try{
        if(__isCheckedInToday()) return;
        const m = document.getElementById("attModal");
        const opened = !!(m && !m.classList.contains("hidden"));
        if(!opened) autoOpenAttendanceIfNeeded();
      }catch(e){}
    }, 2300);
  }catch(e){}
}

function autoOpenAttendanceIfNeeded(){
  try{
    __attDbg("autoOpenAttendanceIfNeeded() called | joined=" + !!state.joined + " | uid=" + (state.uid||"") +
      " | checkin=" + (localStorage.getItem("mk_checkin_day")||"null") +
      " | autoShown=" + (localStorage.getItem("mk_attend_auto_shown_day_v1")||"null"), false);

    if(!ATTEND_AUTO_OPEN_ON_JOIN){
      __attDbgOnce("auto_disabled", "자동출석: ATTEND_AUTO_OPEN_ON_JOIN=false");
      return;
    }
    if(!state.joined){
      __attDbgOnce("not_joined", "자동출석: 아직 입장(joined) 전이라 스킵");
      return;
    }

    // ✅ 오늘 이미 '출근완료'로 찍혀있으면 자동 팝업 X
    if(__isCheckedInToday()){
      __attDbgOnce("checked_today", "자동출석: 오늘 출근완료로 판정되어 스킵");
      return;
    }
    // ✅ 자동 팝업은 필요하면 매번 시도(중복은 '모달 이미 열림' 체크로 방지)


    // ✅ 이미 모달이 열려있으면 중복 오픈 방지
    try{
      const m = document.getElementById("attModal");
      if(m && !m.classList.contains("hidden")){
        __attDbgOnce("already_open", "자동출석: 모달이 이미 열려있어서 스킵");
        return;
      }
    }catch(e){}

    // ✅ openAttendanceModal이 window에 안 붙어있는 환경(스코프/번들)도 대비
    const fn = (typeof window.openAttendanceModal === "function")
      ? window.openAttendanceModal
      : (typeof openAttendanceModal === "function" ? openAttendanceModal : null);

    if(!fn){
      __attDbgOnce("no_fn", "자동출석: openAttendanceModal 함수를 찾지 못함");
      return;
    }

    // ✅ DOM이 아직 준비되지 않았거나(초기 join 직후) 모달 엘리먼트가 없으면 잠깐 재시도
    let tries = 0;
    setTimeout(()=>{ (function tryOpen(){
      tries++;
      const modal = document.getElementById("attModal");
      const frame = document.getElementById("attFrame");

      if(!modal || !frame){
        if(tries === 1) __attDbgOnce("dom_not_ready", "자동출석: 모달 DOM 준비 대기중…");
        if(tries <= 40) return setTimeout(tryOpen, 150);
        __attDbgOnce("dom_timeout", "자동출석: 모달 DOM을 끝내 찾지 못함(타임아웃)");
        return;
      }

      __attDbg("tryOpen #" + tries + " | modal=" + !!modal + " frame=" + !!frame, false);

      try{ fn(); }catch(e){
        __attDbgOnce("fn_throw", "자동출석: openAttendanceModal 호출 중 예외(" + (e && e.message ? e.message : "unknown") + ")");
      }

      // ✅ 실제로 열렸는지 확인 후에만 '자동 표시' 기록
      setTimeout(()=>{
        try{
          const m2 = document.getElementById("attModal");
          const opened = !!(m2 && !m2.classList.contains("hidden"));
          if(opened){
            __attDbgOnce("opened_ok", "자동출석: ✅ 모달이 열렸어!");
          }else{
            __attDbgOnce("opened_fail", "자동출석: ⚠️ 열기 시도했지만 hidden 상태(다른 모달/포커스 충돌 가능)");
          }
        }catch(e){}
      }, 120);
    })(); }, 380);
  }catch(e){
    try{ __attDbgOnce("outer_throw", "자동출석: 바깥 try에서 예외(" + (e && e.message ? e.message : "unknown") + ")"); }catch(_e){}
  }
}


window.warmAttendanceFrame = function warmAttendanceFrame(){
  try{
    if(!ATTEND_KEEP_WARM) return;
    if(!state.joined) return;
    const frame = document.getElementById("attFrame");
    if(!frame) return;
    if(!ATTEND_WEBAPP_URL || ATTEND_WEBAPP_URL.includes("PASTE_YOUR")) return;
    // 이미 뭔가 로딩 중/완료면 그대로 둠
    if(frame.src && frame.src !== "about:blank") return;
    frame.src = __buildAttendSrc(false);
    __attWarmAtMs = Date.now();
  }catch(e){}
}

function openAttendanceModal(){
  __resetAttendFlow();
  const modal = document.getElementById("attModal");
  const frame = document.getElementById("attFrame");
  if(!modal || !frame) return;
  // ✅ '실제로' 모달을 열 수 있을 때만 오늘 오픈 기록을 찍는다
  try{ __markOpenedAttendToday && __markOpenedAttendToday(); }catch(e){}

  if(!ATTEND_WEBAPP_URL || ATTEND_WEBAPP_URL.includes("PASTE_YOUR")) {
    showToast("⚠️ 출근 웹앱 URL을 아직 안 넣었어!");
    return;
  }

  // ✅ 먼저 모달을 즉시 보여주고(체감 반응 개선), iframe 로딩은 다음 프레임에서
  modal.classList.remove("hidden");
  modal.setAttribute("aria-hidden","false");
  try{ modal.inert = false; }catch(e){}
  // 포커스는 닫기 버튼으로
  setTimeout(()=>{ try{ document.getElementById("attCloseBtn")?.focus?.(); }catch(e){} },0);

  // 이미 웜업되어 있거나(about:blank가 아님) 최근에 로딩했다면 그대로 사용
  const hasWarm = (frame.src && frame.src !== "about:blank");
  const isFresh = (__attWarmAtMs && (Date.now() - __attWarmAtMs) < 30*60*1000);

  if(ATTEND_KEEP_WARM && hasWarm && isFresh){
    // 그대로 보여주기
    return;
  }

  // cache-bust + embedded flag (다음 프레임에서 세팅)
  requestAnimationFrame(()=>{
    try{
      frame.src = __buildAttendSrc(true);
      __attWarmAtMs = Date.now();
    }catch(e){}
  });
}

// ✅ 자동팝업/외부호출을 위해 전역(window)에 확실히 연결
try{ window.openAttendanceModal = openAttendanceModal; }catch(e){}

function closeAttendanceModal(opts={}){
  const modal = document.getElementById("attModal");
  const frame = document.getElementById("attFrame");
  if(!modal || !frame) return;

  // ✅ Chrome 'aria-hidden + focus' 경고/차단 방지: 먼저 포커스 빼기
  try{
    const active = document.activeElement;
    if(active && modal.contains(active)) active.blur?.();
  }catch(e){}

  // 숨김 처리
  modal.classList.add("hidden");
  try{ modal.setAttribute("aria-hidden","true"); }catch(e){}
  try{ modal.inert = true; }catch(e){}

  // ✅ 사용자가 '완료 화면(2번째 로드 이후)'까지 보고 닫는 경우 → 그 시점에 출근완료 처리
  try{
    const fromUser = !!opts.fromUser;
    if(fromUser && __attDoneReady){
      __markCheckedInToday();
      if(els && els.checkInBtn) __applyCheckInBtnUI(els.checkInBtn);
      showToast("✅ 출근 기록 완료!");
    }
  }catch(e){}

  // iframe reset (기본은 웜업 유지, 옵션에 따라 초기화)
  try{
    const keepWarm = (typeof opts.keepWarm === "boolean") ? opts.keepWarm : true;
    if(!keepWarm){
      frame.src = "about:blank";
    }
  }catch(e){}

  // 포커스 복귀(출근 버튼) → 접근성 + 다음 키보드 조작 안정화
  setTimeout(()=>{
    try{ document.getElementById("checkInBtn")?.focus?.(); }catch(e){}
  }, 0);
}

      // 닫기 버튼/배경 클릭
      (function wireAttendanceModal(){
        const modal = document.getElementById("attModal");
        const closeBtn = document.getElementById("attCloseBtn");
        const frame = document.getElementById("attFrame");

        // ✅ iframe 로드 횟수로 "완료 화면까지 왔는지" 추정 (cross-origin 안전)
        if(frame){
          frame.addEventListener("load", ()=>{
            try{
              // 모달이 열려있는 동안만 카운트
              const isOpen = modal && !modal.classList.contains("hidden");
              if(!isOpen) return;
              __attLoadCount = (__attLoadCount || 0) + 1;
              if(__attLoadCount >= 2) __attDoneReady = true;
              // ✅ 닉네임 선택(보통 2번째 로드) 감지: 한 번 반짝 애니메이션
              if(__attLoadCount === 2){
                try{
                  modal.classList.add("attSelectPulse");
                  setTimeout(()=>{ try{ modal.classList.remove("attSelectPulse"); }catch(e){} }, 650);
                  showToast("✅ 닉네임 선택!", 1200);
                }catch(e){}
              }
            }catch(e){}
          });
        }
        if(closeBtn) closeBtn.addEventListener("click", ()=>closeAttendanceModal({fromUser:true}));
        const doneBtn = document.getElementById("attDoneBtn");
        if(doneBtn) doneBtn.addEventListener("click", ()=>{
          try{ __markCheckedInToday(); if(els && els.checkInBtn) __applyCheckInBtnUI(els.checkInBtn); }catch(e){}
          showToast("✅ 출근완료로 표시했어!");
          closeAttendanceModal({fromUser:true});
          // 출근하면 자동 '작업중'으로 변경(기존 의도 유지)
          try{ if(state && state.uid) setStatus("work"); }catch(e){}
        });

        // ✅ Daily Notice(입장 공지) 버튼 연결
        const dn = document.getElementById("dailyNoticeModal");
        const dnGo = document.getElementById("dailyNoticeGoBtn");
        const dnLater = document.getElementById("dailyNoticeLaterBtn");
        const dnCloseX = document.getElementById("dailyNoticeCloseX");
        if(dn){
          // backdrop 클릭 닫기
          dn.addEventListener("click", (e)=>{
            try{
              const t = e.target;
              if(t && (t.getAttribute?.("data-close")==="1" || t.classList?.contains("backdrop"))){
                hideDailyNotice(true);
              }
            }catch(err){}
          });

          if(dnGo) dnGo.addEventListener("click", ()=>{
            hideDailyNotice(true);
            // 출근 모달은 사용자가 눌렀을 때만 열어(충돌 방지)
            setTimeout(()=>{ try{ openAttendanceModal(); }catch(e){} }, 80);
          });
          if(dnLater) dnLater.addEventListener("click", ()=>hideDailyNotice(true));
          if(dnCloseX) dnCloseX.addEventListener("click", ()=>hideDailyNotice(true));
        }

        if(modal) modal.addEventListener("click", (ev)=>{
          const t = ev.target;
          if(t && t.dataset && t.dataset.close) closeAttendanceModal({fromUser:true});
        });
        // ESC 닫기
        document.addEventListener("keydown", (ev)=>{
          if(ev.key === "Escape") closeAttendanceModal({fromUser:true});
        });

        // Apps Script(iframe) → 작업방으로 완료 신호 받기
        window.addEventListener("message", async (ev)=>{
          try{
            let data = ev && ev.data;
            // ✅ Apps Script 쪽이 문자열로 보내거나(JSON 문자열) 타입 키가 다를 때도 받기
            if(typeof data === "string"){
              const s = data.trim();
              if(s === "ATTENDANCE_DONE"){
                data = {type:"ATTENDANCE_DONE"};
              }else if(s.startsWith("{") || s.startsWith("[")){
                try{ data = JSON.parse(s); }catch(e){}
              }
            }
            if(!data || typeof data !== "object") return;
            const t = String(data.type || data.event || "").toUpperCase();
            if(t !== "ATTENDANCE_DONE") return;


            closeAttendanceModal();
            const nick = data.nickname ? ` (${data.nickname})` : "";
            showToast("✅ 출근 기록 완료!" + nick);
            // ✅ 토스트가 바로 보이도록 한 프레임 양보
            try{ await new Promise(r=>requestAnimationFrame(r)); }catch(e){}
            // ✅ 오늘 출근 완료로 표시(버튼 텍스트/뱃지)
            try{ __markCheckedInToday(); if(els.checkInBtn) __applyCheckInBtnUI(els.checkInBtn); }catch(e){}

            // 기존 출근 버튼 동작 유지: 출근하면 자동 '작업중'으로 변경
            if(state && state.uid){
              try{ await setStatus("work"); }catch(e){}
            }
          }catch(e){}
        });
      })();

      els.checkInBtn.addEventListener("click", async ()=>{
        try{
          try{ if(!state.uid){ state.uid = (auth && auth.currentUser && auth.currentUser.uid) ? auth.currentUser.uid : state.uid; } }catch(_e){}
          openAttendanceModal();
        }catch(e){}
      });
}
;
els.statusBtn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      els.statusMenu.classList.toggle("hidden");
    });
    // 메뉴 바깥 클릭하면 닫기
    document.addEventListener("click", ()=>{
      if(!els.statusMenu.classList.contains("hidden")) els.statusMenu.classList.add("hidden");
    });
    // 메뉴 클릭은 버블링 막기
    els.statusMenu.addEventListener("click", (ev)=>ev.stopPropagation());
    els.profileBtn.addEventListener("click", ()=>{
      if(!state.joined){ showToast("🔒 입장 후에만 사용할 수 있어!"); return; }

      // ✅ 모달 열 때 현재 저장된 값들을 다시 채워넣기
      try{
        const lp = loadLocalProfile() || {};
        const theme = lp.theme || {};
        if(els.profileNick){
          const nn = (lp.nickname || state.nickname || "").toString().trim().slice(0,20);
          if(nn) els.profileNick.value = nn;
        }
        if(els.emoji) els.emoji.value = (window.firstEmojiGrapheme || firstEmojiGrapheme)((theme.emoji || els.emoji.value || "✍️").toString().trim()) || "✍️";
        if(els.emojiSize){ els.emojiSize.value = "82"; els.emojiSize.disabled = true; }
        if(els.emojiSizeNum){ els.emojiSizeNum.value = "82"; }

        if(els.photoSize){ els.photoSize.value = "82"; els.photoSize.disabled = true; }
        if(els.photoSizeNum){ els.photoSizeNum.value = "82"; }


        if(els.emojiBgColor) els.emojiBgColor.value = clampHexColor(theme.emojiBg || els.emojiBgColor.value || "#2b2b2b");
        if(els.emojiBgPicker) els.emojiBgPicker.value = els.emojiBgColor.value;
      try{ if(els.emojiBgTransparent) els.emojiBgTransparent.checked = (theme.emojiBgTransparent === true || theme.emojiBgTransparent === "true"); }catch(e){}

        if(els.bgColor) els.bgColor.value = clampHexColor(theme.bgColor || els.bgColor.value || "#ffd0e2");
        if(els.bgPicker) els.bgPicker.value = els.bgColor.value;

        if(els.bgPattern) els.bgPattern.value = (theme.pattern || els.bgPattern.value || "none");
        if(els.patternColor) els.patternColor.value = clampHexColor(theme.patternColor || els.patternColor.value || "#ffffff");
        if(els.patternPicker) els.patternPicker.value = els.patternColor.value;

        if(els.bubbleText) els.bubbleText.value = (lp.bubbleText || "").toString().slice(0,15);
        if(els.bubbleColor) els.bubbleColor.value = clampHexColor(theme.bubbleColor || els.bubbleColor.value || "#ffd0e2");
        if(els.bubblePicker) els.bubblePicker.value = els.bubbleColor.value;

        if(els.timeColor) els.timeColor.value = clampHexColor(theme.timeColor || els.timeColor.value || "#ffffff");
        if(els.timePicker) els.timePicker.value = els.timeColor.value;

        // ✅ text colors
        if(els.nameColor) els.nameColor.value = clampHexColor(theme.nameColor || "#ffffff");
        if(els.nameColorPicker) els.nameColorPicker.value = els.nameColor.value;

        if(els.chatNameColor){
          els.chatNameColor.value = clampHexColor(theme.chatNameColor || theme.nameColor || "#ffffff");
        }
        if(els.chatNameColorPicker) els.chatNameColorPicker.value = (els.chatNameColor ? els.chatNameColor.value : clampHexColor(theme.chatNameColor || theme.nameColor || "#ffffff"));

        if(els.statusTextColor) els.statusTextColor.value = clampHexColor(theme.statusTextColor || "#ffffff");
        if(els.statusTextColorPicker) els.statusTextColorPicker.value = els.statusTextColor.value;

        if(els.bubbleTextColor) els.bubbleTextColor.value = clampHexColor(theme.bubbleTextColor || "#ffffff");
        if(els.bubbleTextColorPicker) els.bubbleTextColorPicker.value = els.bubbleTextColor.value;

        // ✅ 자동전환(분)
        const ab = Number(lp.autoBreakMin ?? 10);
        const ai = Number(lp.autoIdleMin ?? 15);
        if(els.autoBreakMin) els.autoBreakMin.value = String(Math.min(180, Math.max(1, isFinite(ab)?ab:10)));
        if(els.autoIdleMin) els.autoIdleMin.value = String(Math.min(180, Math.max(1, isFinite(ai)?ai:15)));
        // ✅ 헬퍼 모드
        const hm = String(lp.helperMode || state.helperMode || 'auto');
        setHelperMode((hm==='manual')?'manual':'auto', false);
      }catch(e){}
      try{ updatePhotoEnabledUI(); }catch(e){}
      showModal(els.profileModal);
    });
    els.closeProfile.addEventListener("click", ()=>hideModal(els.profileModal));
    if(els.guideBtn){
      els.guideBtn.addEventListener("click", ()=>{ if(!state.joined){ showToast("입장하고 읽어줘! 💗"); return; } showModal(els.guideModal); try{ els.guideModal.querySelector('.modalBody')?.scrollTo(0,0);}catch(e){} });
    }
    if(els.dataSaverBtn){
      els.dataSaverBtn.addEventListener("click", ()=>{
        // toggle: ON = chat-only realtime
        setNonChatEnabled(!state.nonChatEnabled);
      });
    }

    if(els.closeGuide){
      els.closeGuide.addEventListener("click", ()=>hideModal(els.guideModal));
    }
    if(els.guideModal){
      els.guideModal.addEventListener("click", (e)=>{ if(e.target === els.guideModal) hideModal(els.guideModal); });
    }

    els.applyProfile.addEventListener("click", applyProfile);

    // ✅ 상단 상태 메뉴: 헬퍼/수동 토글 + 자동 전환 시간(분)
    function __setAutoMinutes(ab, ai){
      ab = Math.min(180, Math.max(1, Number(ab||10)));
      ai = Math.min(180, Math.max(1, Number(ai||15)));
      if(ai < ab) ai = Math.min(180, ab + 5);
      try{
        const lp = loadLocalProfile() || {};
        lp.autoBreakMin = ab;
        lp.autoIdleMin = ai;
        saveLocalProfile(lp);
      }catch(e){}
      // 프로필 모달 입력도 동기화
      try{ if(els.autoBreakMin) els.autoBreakMin.value = String(ab); }catch(e){}
      try{ if(els.autoIdleMin)  els.autoIdleMin.value  = String(ai); }catch(e){}
      try{ if(els.autoBreakMinTop) els.autoBreakMinTop.value = String(ab); }catch(e){}
      try{ if(els.autoIdleMinTop)  els.autoIdleMinTop.value  = String(ai); }catch(e){}
      try{ updateHelperStatusUI(); }catch(e){}
      try{ syncMyStatusUI(); }catch(e){}
    }

    try{
      if(els.modeAutoBtn) els.modeAutoBtn.addEventListener("click", async ()=>{
        // (내부 유지) 헬퍼 ON: 작업중에서만 허용
        if(!state.joined) return;
        const me = state.currentParticipants?.get?.(state.uid);
        const st = me?.status || state.myStatus || "idle";
        if(st !== "work"){ showToast("✍️ 작업중에서만 헬퍼를 켤 수 있어요"); return; }
        setHelperMode("auto", true);
        try{ syncMyStatusUI(); }catch(e){}
        try{ updateHelperStatusUI(); }catch(e){}
      });
      if(els.modeManualBtn) els.modeManualBtn.addEventListener("click", ()=>{
        // 수동 모드: 화면 즉시 전환
        setHelperMode("manual", true);
        try{ syncMyStatusUI(); }catch(e){}
        try{ updateHelperStatusUI(); }catch(e){}
      });
      if(els.autoBreakMinTop) els.autoBreakMinTop.addEventListener("change", ()=>{ __setAutoMinutes(els.autoBreakMinTop.value, els.autoIdleMinTop?.value); });
      if(els.autoIdleMinTop)  els.autoIdleMinTop.addEventListener("change", ()=>{ __setAutoMinutes(els.autoBreakMinTop?.value, els.autoIdleMinTop.value); });
    }catch(e){}

    // ✅ 헬퍼 모드 즉시 반영
    try{
      if(els.helperMode) els.helperMode.addEventListener('change', ()=>{ setHelperMode(els.helperMode.value, true); try{ syncMyStatusUI(); }catch(e){} updateHelperStatusUI(); });
      if(els.photoEnabled) els.photoEnabled.addEventListener("change", ()=>{ try{ updatePhotoEnabledUI(); }catch(e){} });
      if(els.emojiBgTransparent) els.emojiBgTransparent.addEventListener("change", ()=>{
        try{
          // ✅ 체크가 "자동으로 풀리는" 현상 방지: 즉시 로컬 프리셋에도 반영
          const lp = loadLocalProfile() || {};
          lp.theme = lp.theme || {};
          lp.theme.emojiBgTransparent = !!els.emojiBgTransparent.checked;
          saveLocalProfile(lp);
        }catch(e){}
        
        // ✅ 가능하면 즉시 DB에도 반영해서 체크가 다시 풀리지 않게 하기
        try{
          if(state.uid && state.roomId){
            rUpdate(rMePresenceRef(state.roomId, state.uid), {
              "theme/emojiBgTransparent": !!els.emojiBgTransparent.checked,
              updatedAt: Date.now(),
              lastSeenAtMs: Date.now()
            }).catch(()=>{});
          }
        }catch(e){}
try{
          // 가능하면 즉시 내 타일에도 프리뷰(저장 전이라도 UI에 반영)
          if(state.currentParticipants && state.uid){
            const me = state.currentParticipants.get(state.uid);
            if(me && me.theme){
              me.theme.emojiBgTransparent = !!els.emojiBgTransparent.checked;
              renderTiles();
            }
          }
        }catch(e){}
      });
    }catch(e){}

    // ✅ 오늘의 미션 모달 바인딩
    try{
      const mm = document.getElementById("missionModal");
      const close = document.getElementById("closeMission");
      const save = document.getElementById("saveMission");
      if(close) close.addEventListener("click", closeMissionModal);
      if(mm) mm.addEventListener("click", (e)=>{ if(e.target===mm) closeMissionModal(); });

      // 버튼 클릭(이벤트 위임) - 타일이 리렌더되어도 안 죽게
      document.addEventListener("click", (e)=>{
        const btn = e.target && e.target.closest ? e.target.closest(".missionBtn") : null;
        if(btn){
          e.preventDefault();
          const isMe = (btn.dataset.me==="1") || ((btn.dataset.owner||"") && state.uid && (btn.dataset.owner===state.uid));
          if(isMe){
            openMissionModal();
          }else{
            const nameRaw = (btn.dataset.name || "").trim() || "상대";
              const nameKey = (typeof normalizeNick==="function") ? normalizeNick(nameRaw) : nameRaw;
              const info = getRemoteMissionInfoByName(nameKey);
              const name = nameRaw;
            if(info && info.action==="done"){
              showToast(info.text ? `${name} 미션 성공! 👑 ${info.text}` : `${name} 미션 성공! 👑`);
            }else if(info && info.text){
              showToast(`${name} 오늘의 미션: ${info.text}`);
            }else{
              showToast(`${name} 아직 미션이 없어!`);
            }
          }
        }
      });

      if(save) save.addEventListener("click", async ()=>{
        try{
          const text = (document.getElementById("missionText")?.value || "").trim();
          const done = !!document.getElementById("missionDone")?.checked;
          const dayKey = seoulDateKey();
          const prev = state.myMission || loadMissionLocal();
          const becameDone = (!prev.done && done);
          const becameUndone = (prev.done && !done);

          const m = { dayKey, text, done, doneAt: done ? (prev.doneAt || new Date().toISOString()) : "" };
          state.myMission = m;
          saveMissionLocal(m);
          setMissionButtonState();
          refreshAllMissionMedals();
          closeMissionModal();

          // 성공 폭죽(프로필 타일 중심)
          if(becameDone){
            const myTile = (state.uid && state.lastRendered && state.lastRendered.get(state.uid)) ? (state.lastRendered.get(state.uid).el || null) : null;
            const btn = document.querySelector(".missionBtn[data-me=\"1\"]");
            fxFireworksAt(myTile || btn);
          }

          // ✅ RTDB에 내 미션 반영(emitMissionEvent 사용)
          try{
            if(state.roomId && state.uid){
              // ✅ 로그아웃/재입장에도 유지되도록 '오늘 미션 성공'을 별도 컬렉션에 저장
              if(becameUndone) await emitMissionEvent('undo', m);
              else if(done) await emitMissionEvent('done', m);
              else if(text) await emitMissionEvent('set', m);
            }
          }catch(e){}
        }catch(e){}
      });
    }catch(e){}

    // ✅ 대시보드 접기/펼치기
    try{
      const foldBtn = document.getElementById("dashFoldBtn");
      const btnIcon = document.getElementById("dashFoldIcon");
      const btnTxt  = document.getElementById("dashFoldTxt");
      const body = document.getElementById("dashFoldBody");
      function applyFoldUI(){
        const folded = loadDashFold();
        const card = document.getElementById("dashboardCard");
        if(card) card.classList.toggle("folded", folded);
        if(body) body.classList.toggle("isHidden", folded);
        if(btnIcon) btnIcon.textContent = folded ? "▾" : "▴";
        if(btnTxt) btnTxt.textContent = folded ? "펼치기" : "접기";
      }
      applyFoldUI();
      if(foldBtn) foldBtn.addEventListener("click", ()=>{
        const next = !loadDashFold();
        saveDashFold(next);
        applyFoldUI();

        // ✅ 접기/펼치기 둘 다: 도킹 레이아웃 재계산 (겹침/잔상 방지)
        try{ if(typeof dockRightRail==="function") dockRightRail(); }catch(e){}
        setTimeout(()=>{ try{ if(typeof dockRightRail==="function") dockRightRail(); }catch(e){} }, 50);
      });

    // ✅ 미션 완료자 명단 보기(👑 클릭)
    try{
      const box = document.querySelector("#dashboardCard .dashSuccess");
      if(box){
        box.style.cursor = "pointer";
        box.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); openMissionListModal(); });
      }
      // close buttons
      document.addEventListener("click", (ev)=>{
        const t = ev.target;
        const closeId = t && t.getAttribute ? t.getAttribute("data-close") : null;
        if(closeId){
          const mo = document.getElementById(closeId);
          if(mo) hideModal(mo);
        }
      });
    }catch(e){}


    }catch(e){}


    // ✅ 크기 조절 바는 고정(82px)이라 모달에서 숨김
    function hideRowByControl(el){
      try{
        if(!el) return;
        const row = el.closest ? el.closest(".row") : null;
        if(row) row.style.display = "none";
      }catch(e){}
    }
    hideRowByControl(els.emojiSize);
    hideRowByControl(els.photoSize);
    hideRowByControl(els.emojiSizeNum);
    hideRowByControl(els.photoSizeNum);


    // ✅ 이모지 1개만 허용
    if(els.emoji){
      els.emoji.addEventListener("input", ()=>{
        const v = (window.firstEmojiGrapheme || firstEmojiGrapheme)(els.emoji.value);
        if(v && els.emoji.value !== v) els.emoji.value = v;
      });
      els.emoji.addEventListener("blur", ()=>{
        const v = (window.firstEmojiGrapheme || firstEmojiGrapheme)(els.emoji.value);
        els.emoji.value = v || "✍️";
      });
    }

    if(els.uploadPhotoBtn) els.uploadPhotoBtn.addEventListener("click", uploadPhoto);

    els.menuBtn.addEventListener("click", ()=>{
      els.adminPass.value = "";
      els.adminArea.style.display = "none";
      state.adminOk = false;
      showModal(els.settingsModal);
    });
    els.closeSettings.addEventListener("click", ()=>hideModal(els.settingsModal));
    els.adminUnlock.addEventListener("click", unlockAdmin);
    if(els.adminPass){
      els.adminPass.addEventListener("keydown",(e)=>{
        if(e.key==="Enter"){ e.preventDefault(); unlockAdmin(); }
      });
    }

    // 모달에서 Enter → 첫 번째 primary 버튼
    document.addEventListener("keydown",(e)=>{
      if(e.key!=="Enter") return;
      const openModal = [els.profileModal, els.settingsModal].find(m=>m && m.style.display==="flex");
      if(!openModal) return;
      const ae = document.activeElement;
      if(ae && (ae.tagName==="TEXTAREA")) return;
      // 이미 특정 input에서 Enter 처리하는 경우는 건드리지 않기
      if(ae && ae.id==="adminPass") return;
      const btn = openModal.querySelector("button.primary");
      if(btn){ e.preventDefault(); btn.click(); }
    });
    els.saveDash.addEventListener("click", saveDashboard);

    els.sendBtn.addEventListener("click", sendChat);

    if(els.chatJumpBtn){
      els.chatJumpBtn.addEventListener("click", ()=>{
        scrollChatToBottom();
        hideChatNewBar(true);
      });
    }
    if(els.chatList){
      els.chatList.addEventListener("scroll", ()=>{
        const nb = isChatNearBottom();
        state.chatUserNearBottom = nb;
        if(nb) hideChatNewBar(true);
      }, { passive: true });
      // ✅ reactions click (hover toggle + picker)
      function closeAllReactPickers(exceptMsgEl){
        try{
          document.querySelectorAll(".reactPicker.open").forEach(p=>{
            if(exceptMsgEl && exceptMsgEl.contains(p)) return;
            p.classList.remove("open");
          });
        }catch(e){}
      }

      els.chatList.addEventListener("click", (ev)=>{
        // toggle button
        const tgl = ev.target && ev.target.closest ? ev.target.closest(".reactToggle") : null;
        if(tgl){
          const msgEl = tgl.closest(".msg");
          const picker = msgEl ? msgEl.querySelector(".reactPicker") : null;
          if(picker){
            const open = picker.classList.toggle("open");
            if(picker.classList.contains("open")){ try{ picker.scrollLeft = 0; }catch(e){} }
            if(open) closeAllReactPickers(msgEl);
          }
          ev.preventDefault();
          return;
        }

        // reaction chip / picker item
        const btn = ev.target && ev.target.closest ? ev.target.closest(".reactBtn") : null;
        if(!btn) return;
        if(btn.classList.contains("reactToggle")) return;

        const msgId = btn.getAttribute("data-msg-id");
        const key = btn.getAttribute("data-react-key");
        if(msgId && key){
          toggleReaction(msgId, key);
          // picking from the picker closes it
          if(btn.classList.contains("reactPick")){
            closeAllReactPickers();
          }
        }
      });

      // click outside to close pickers
      document.addEventListener("click", (ev)=>{
        try{
          if(ev.target && (ev.target.closest(".reactPicker") || ev.target.closest(".reactToggle"))) return;
          closeAllReactPickers();
        }catch(e){}
      }, { passive:true });
}

    
    // ✅ Online members: click count -> show list
    function renderOnlineList(){
      try{
        if(!els.onlineList) return;
        const arr = [];
        if(state.currentParticipants){
          state.currentParticipants.forEach((p)=>{
            if(!p) return;
            if(p.status==="off" || !isOnlinePresence(p)) return;
            arr.push(p);
          });
        }
        // sort: work -> break -> idle, then name
        const rank = (s)=> (s==="work")?0:(s==="break")?1:2;
        arr.sort((a,b)=>{
          const ra = rank(a.status||"idle");
          const rb = rank(b.status||"idle");
          if(ra!==rb) return ra-rb;
          return String(a.name||"").localeCompare(String(b.name||""), "ko");
        });

        els.onlineList.innerHTML = "";
        if(!arr.length){
          els.onlineList.innerHTML = `<div class="tiny" style="opacity:.8;">지금 접속 중인 사람이 없어 🫥</div>`;
          return;
        }

        const frag = document.createDocumentFragment();
        for(const p of arr){
          const item = document.createElement("div");
          item.className = "onlineItem";

          const left = document.createElement("div");
          left.className = "onlineLeft";

          const emo = document.createElement("div");
          emo.className = "onlineEmoji";
          emo.textContent = (p.theme?.emoji || "💬");

          const name = document.createElement("div");
          name.className = "onlineName";
          name.textContent = (p.name || "익명");

          // apply tile nickname color (profile) if set
          try{
            const nc = p.theme?.nameColor ? clampHexColor(p.theme.nameColor) : null;
            if(nc) name.style.color = nc;
          }catch(e){}

          const meta = document.createElement("div");
          meta.className = "onlineMeta";
          meta.textContent = (p.status === "work") ? "작업중" : (p.status === "break") ? "휴식중" : "자리비움";

          left.appendChild(emo);
          left.appendChild(name);
          left.appendChild(meta);

          const bd = document.createElement("div");
          bd.className = "onlineBadge";
          bd.textContent = (p.status === "work") ? "✍️ Work" : (p.status === "break") ? "☕ Break" : "🌙 Idle";

          item.appendChild(left);
          item.appendChild(bd);
          frag.appendChild(item);
        }
        els.onlineList.appendChild(frag);
      }catch(e){ console.error(e); }
    }

    if(els.onlineBtn && els.onlineModal){
      els.onlineBtn.addEventListener("click", ()=>{
        if(!state.joined) return;
        renderOnlineList();
        showModal(els.onlineModal);
      });
    }
    if(els.closeOnline && els.onlineModal){
      els.closeOnline.addEventListener("click", ()=>hideModal(els.onlineModal));
    }
    if(els.onlineModal){
      els.onlineModal.addEventListener("click", (ev)=>{
        if(ev.target === els.onlineModal) hideModal(els.onlineModal);
      });
    }


// --- 컨텍스트 메뉴(프로필 우클릭) 닫기/동작 ---
    if(els.ctxClose){
      els.ctxClose.addEventListener("click", (e)=>{
        e.preventDefault();
        hideCtxMenu();
      });
    }
    if(els.ctxKick){
      els.ctxKick.addEventListener("click", async (e)=>{
        e.preventDefault();
        const t = state.ctxTarget || {};
        hideCtxMenu();
        if(t.uid) await requestKick(t.uid, t.name);
      });
    }
    // 메뉴 안에서 클릭은 바깥 클릭 닫기 트리거를 막기
    if(els.ctxMenu){
      els.ctxMenu.addEventListener("click", (e)=>e.stopPropagation());
      els.ctxMenu.addEventListener("contextmenu", (e)=>e.preventDefault());
    }
    // 바깥 클릭/우클릭/ESC 로 닫기
    document.addEventListener("click", (e)=>{
      if(!els.ctxMenu || els.ctxMenu.classList.contains("hidden")) return;
      if(!els.ctxMenu.contains(e.target)) hideCtxMenu();
    }, true);
    document.addEventListener("contextmenu", (e)=>{
      if(!els.ctxMenu || els.ctxMenu.classList.contains("hidden")) return;
      if(!els.ctxMenu.contains(e.target)) hideCtxMenu();
    }, true);
    document.addEventListener("keydown", (e)=>{
      if(e.key==="Escape") hideCtxMenu();
    });


    // embed controls (현재는 내부 임베드 사용 안 함. 요소가 없을 수도 있어 가드)
    if(els.embedClose) els.embedClose.addEventListener("click", closeInlineEmbed);
    if(els.embedOpen)  els.embedOpen.addEventListener("click", ()=>{ /* set on openInlineEmbed */ });
    if(els.closeEmbedModal) els.closeEmbedModal.addEventListener("click", closeEmbedModal);
    if(els.embedModal) els.embedModal.addEventListener("click", (e)=>{ if(e.target===els.embedModal) closeEmbedModal(); });
    // ✅ IME(한글 등) 조합 입력에서 Enter가 2번 처리되며 '마지막 글자만 따로 전송'되는 현상 방지
    let __chatIsComposing = false;
    let __chatSendAfterCompose = false;

    els.chatInput.addEventListener("compositionstart", ()=>{
      __chatIsComposing = true;
      __chatSendAfterCompose = false;
    });
    els.chatInput.addEventListener("compositionend", ()=>{
      __chatIsComposing = false;
      if(__chatSendAfterCompose){
        __chatSendAfterCompose = false;
        // 조합 확정 후 다음 틱에 전송 (한 번만)
        setTimeout(()=>sendChat(), 0);
      }
    });

    els.chatInput.addEventListener("keydown", (e)=>{
      if(e.key !== "Enter") return;



      // 조합 중 Enter: 조합 확정만 하고(기본 동작), 전송은 compositionend에서 한 번만 처리
      if(e.isComposing || __chatIsComposing || e.keyCode === 229){
        __chatSendAfterCompose = true;
        return;
      }

      e.preventDefault();
      sendChat();
    });

    els.profileModal.addEventListener("click", (e)=>{ if(e.target === els.profileModal) hideModal(els.profileModal); });
    els.settingsModal.addEventListener("click", (e)=>{ if(e.target === els.settingsModal) hideModal(els.settingsModal); });

    
    // ✅ 입장키(24h) 기억
    loadPassOK();

    // ✅ 입장 소리 토글(로컬)
    try{
      const v = (localStorage.getItem(LS_SFX_ENABLED) || "0");
      state.sfxEnabled = (v !== "0");
    }catch(e){ state.sfxEnabled = false; }
    if(els.sfxToggle){
      els.sfxToggle.checked = (state.sfxEnabled !== false);
      els.sfxToggle.addEventListener("change", ()=>{
        state.sfxEnabled = !!els.sfxToggle.checked;
        try{ localStorage.setItem(LS_SFX_ENABLED, state.sfxEnabled ? "1" : "0"); }catch(e){}
        try{ showToast(state.sfxEnabled ? "🔈 입장 소리 ON" : "🔇 입장 소리 OFF", 1600); }catch(e){}
      });
    }


    if(els.roomPass){
      els.roomPass.addEventListener("input", ()=>{
        if(!(els.roomPass.value||"").trim()) clearPass();
      });
    }

    // ✅ 프로필 설정(브라우저) 프리셋 불러오기
    try{
      const lp = loadLocalProfile();
      if(lp){
        if(els.emoji) els.emoji.value = lp.theme?.emoji || els.emoji.value;
        if(els.bgColor) els.bgColor.value = lp.theme?.bgColor || els.bgColor.value;
        if(els.bgPattern && lp.theme?.pattern) els.bgPattern.value = lp.theme.pattern;
        if(els.bubbleText) els.bubbleText.value = lp.bubbleText || "";
        if(lp.theme?.photoUrl) state.myPhotoUrl = lp.theme.photoUrl;
      }
    }catch(e){}


    // 닉네임 기억 (입퇴장 편의)
    try{
      const lp = loadLocalProfile() || {};
      const fromProfile = (lp.nickname || "").toString().trim().slice(0,20);
      const saved = localStorage.getItem("mk_last_name") || "";
      if(els.name){
        if(fromProfile) els.name.value = fromProfile;
        else if(saved) els.name.value = saved;
      }
    }catch(e){}
    if(els.name){
      els.name.addEventListener("input", ()=>{
        try{ localStorage.setItem("mk_last_name", els.name.value.trim()); }catch(e){}
      });
      els.name.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          if(!els.joinBtn.disabled) joinRoom();
        }
      });
    }

    if(els.roomPass){
      els.roomPass.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          if(!els.joinBtn.disabled) 
// restore read-saver preference
try{
  const v = localStorage.getItem("mk_nonchat_enabled");
  if(v === "0"){ state.nonChatEnabled = false; }
}catch(e){}
try{
  const b = document.getElementById("dataSaverBtn");
  if(b){ b.textContent = state.nonChatEnabled ? "절약모드" : "실시간 켜기"; }
}catch(e){}

joinRoom();
        }
      });
    }

    setControlsEnabled(false);
    updateClocks();
    const __goOfflineNow = ()=>{
      try{ if(state && state.joined) persistMyFocusToLocal(); }catch(e){}
      if(state.roomId && state.uid){
        try{ rUpdate(rMePresenceRef(state.roomId, state.uid), { status:"off", sessionStartedAtMs:null, lastSeenAtMs: 0, updatedAt: Date.now() }); }catch(e){}
      }
    };

    window.addEventListener("beforeunload", __goOfflineNow);
    // ✅ 모바일/크롬에서 beforeunload가 안 타는 경우 대비
    window.addEventListener("pagehide", __goOfflineNow);

  
  // READY FLAG (bindings complete)
  window.__MK_READY__ = true;
})();
</script>
  <script>
    // Fallback: if ES module didn't execute (common when opening via file://), show a clear hint
    (function(){
      function show(msg){
        try{
          var t = document.getElementById('toast');
          if(t){ t.textContent = msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 4500); }
          else { alert(msg); }
        }catch(e){ alert(msg); }
      }
      window.addEventListener('load', function(){
        setTimeout(function(){
                    if(window.__MK_BOOT_OK__ && !window.__MK_READY__){
            show("⚠️ 스크립트는 로드됐는데 초기화가 중간에 멈췄어(에러 가능). 개발자도구(F12)→Console 에러를 캡처해서 보내주면 바로 잡아줄게!\n(또는 배포 파일 교체 후 Ctrl+F5)");
            var jb2 = document.getElementById('joinBtn');
            if(jb2){ jb2.addEventListener('click', function(){ show("⚠️ 초기화 에러로 입장이 막혔어. F12→Console 에러 캡처를 보내줘!"); }); }
            return;
          }
if(!window.__MK_BOOT_OK__){
            show("⚠️ 지금 파일이 '로컬 파일(file://)'로 열려서 스크립트가 막힌 것 같아! Netlify/GitHub 같은 웹주소(https://)로 열거나, 로컬 서버로 열어줘. (예: 폴더에서 터미널 → python -m http.server)");
            var jb = document.getElementById('joinBtn');
            if(jb){
              jb.addEventListener('click', function(){
                show("⚠️ 로컬 파일(file://)로 열면 입장이 안 돼. Netlify/GitHub 배포 주소(https://)로 열어줘!");
              });
            }
          }
        }, 400);
      });
    })();
  </script>


  

  <!-- ✅ 입장 공지(매일 1회) : 출근 유도 팝업 -->
  <div id="dailyNoticeModal" class="dailyNoticeModal hidden" aria-hidden="true">
    <div class="backdrop" data-close="1"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="오늘의 공지">
      <div class="head">
        <div class="ttl">📌 오늘의 공지</div>
        <button id="dailyNoticeCloseX" class="xBtn" type="button" aria-label="닫기">닫기 ✖</button>
      </div>
      <div class="body">
        <div style="font-weight:900; font-size:15px; margin-bottom:6px;">출근 체크 잊지 말기 💗</div>
        <div>작업방 입장 후 <b>출근(출석)</b>만 한 번 눌러주면, <b>출석 현황</b>에는 하루 1회만 반영되고, 나머지 기록은 <b>AttendanceLog</b>로 남아요!</div>
        <div class="small">※ 오늘은 이 팝업이 <b>처음 1번</b>만 뜹니닷. (닫기/출근 버튼을 누르면 오늘은 더 안 떠요)</div>
      </div>
      <div class="btnRow">
        <button id="dailyNoticeLaterBtn" type="button">나중에</button>
        <button id="dailyNoticeGoBtn" class="primary" type="button">💌 출근 체크하러 가기</button>
      </div>
    </div>
  </div>

<!-- ✅ 출근(출석) 팝업 -->
  <div id="attModal" class="attModal hidden" aria-hidden="true">
    <div class="backdrop" data-close="1"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="출근">
      <div class="head">
        <div class="ttl">💌 출근(출석) 체크</div>
        <div class="attHeadBtns">
          <button id="attCloseBtn" class="xBtn" type="button">닫기 ✖</button>
          <button id="attDoneBtn" class="ghost tight" type="button" title="출근을 완료했다면 눌러서 표시할 수 있어요">✅ 완료</button>
        </div>
      </div>
      <iframe id="attFrame" title="출근(출석)" sandbox="allow-scripts allow-forms allow-same-origin allow-popups" referrerpolicy="no-referrer"></iframe>
    </div>
  </div>


  <!-- 📖 Guide Modal -->
  <div id="guideModal" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" style="width:min(720px, 92vw);">
      <div class="modalHeader">
        <div class="t">📍가이드</div>
        <button id="closeGuide" class="ghost">닫기</button>
      </div>
      <div class="modalBody" style="max-height:72vh; overflow:auto;">
        <pre id="guidePre" class="guidePre">

📍 새로운 작업방 오픈 📌

🟥사용 안내서🟥

➊ /출근 링크로 접속

➋ 닉네임 넣고 비밀번호 입력: mkm1919 
✅영구 패스키라 브라우저 별로 처음만 입력하시면 돼요.
✅캐시 삭제 시 재입력 필요.

➌ 상단바에서 헬퍼 사용 선택(자율)
👉헬퍼 사용 시
✅자동으로 전환될 시간 설정 가능(타이트한 작업 원할 시 짧게 세팅)
🟥헬퍼를 설치하지 않아도 헬퍼 모드에서 자동 휴식을 설정하시면 그 시간에 맞춰 넘어갑니다만!
🟥브라우저 기준으로 활동을 감지하므로, 타이핑만 하시게 되면 혼자 휴식으로 넘어갑니다ㅜㅜ
🟥그러니 헬퍼를 사용하실 때만 헬퍼 모드를 켜기!
🟥맥 버전은 감지와 반영 사이에 3-5초 정도의 딜레가 있습니다.
✅사용하시는 운영체제에 맞는 로컬 헬퍼 다운 후 실행(대시보드 밑에 다운 버튼이 있어요)
✅작업방에 입장할 닉네임과 동일하게 설정
✅초기 설정후 재입력 불필요, 작업할 때 실행만 하면 됩니다
✅But 언제나 수정이 가능하므로 오늘은 임티 잔뜩 붙은 닉넴으로 일할까 싶으시다면!
✅입장 닉넴과 헬퍼 닉넴을 동일하게 설정하시면 됩니당!

👉수동 사용 시
✅자동 감지가 싫으신 분들은 수동 선택
✅직접 현재 상황을 자유롭게 선택하면서 작업하시면 됩니다.

➍출근 도장
✅기존 출근처럼 팝업에서 닉네임 선택(자동 기록)

➎ 그외 기능
👉퇴장 버튼 옆 톱니바퀴에서 입장 소리 온오프 선택 가능
👉내 프로필에서 자유롭게 프로필 타일을 꾸미기(⚡​플꾸타임~~~!!)
👉대시 보드 화면 위로 접기, 대시보드/채팅창 사이드 접기 가능

🟥우리가 함께 사용하는 링크들의 바로가기는 대시보드에 연결되어 있습니다.
🟥오류/건의는 수시로 수정이 가능합니다.
🟥혹여라도 새 작업방에서 작업하시다가 문제가 생긴 듯하다면 갠톡 주십셔! 
</pre>
      </div>
    </div>
  </div>

  <button id="railEdgeBtn" class="railEdgeBtn" type="button" title="오른쪽 사이드 펼치기" aria-label="오른쪽 사이드 펼치기">⟪</button>


  <!-- ✅ Online members modal -->
  <div id="onlineModal" class="modalOverlay" aria-hidden="true">
    <div class="modal">
      <div class="modalHeader">
        <h4>👥 접속 명단</h4>
        <button id="closeOnline" class="ghost tight">닫기</button>
      </div>
      <div class="modalBody">
        <div id="onlineList" class="onlineList"></div>
        <div class="tiny" style="margin-top:8px; opacity:.75;">※ 오프라인(마지막 접속 오래됨)은 제외했어.</div>
      </div>
    </div>
  </div>

</body>
</html>
